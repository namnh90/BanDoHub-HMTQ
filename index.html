<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BAN DO HUB - HMTQ</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/leaflet-geometryutil@0.9.3/src/leaflet.geometryutil.js"></script>
    <script src="https://unpkg.com/@lottiefiles/dotlottie-wc@0.8.5/dist/dotlottie-wc.js" type="module"></script>
    <style>
        /* KHỐI STYLE CỦA BẠN (SỬA ĐỔI RẤT ÍT) */
        html,
        body,
        #map {
            height: 100vh;
            width: 100vw;
            margin: 0;
            padding: 0;
            font-family: 'Times New Roman', Times, serif;
            overflow: hidden;
        }

        .leaflet-tile-pane {
            filter: grayscale(1) contrast(1.1) brightness(0.95);
        }

        /* (MỚI v40) CSS cho Lớp Viền (Pane) */
        .leaflet-border-pane {
            pointer-events: none;
            /* Không bắt click chuột */
        }

        /* Bảng xếp hạng */
        #rank-table-container {
            position: absolute;
            top: 60px;
            left: 10px;
            width: 280px;
            max-height: calc(100vh - 80px);
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 2001;
            font-size: 14px;
            display: none;
        }

        #rank-table-header {
            padding: 8px 12px;
            font-weight: bold;
            font-size: 16px;
            border-bottom: 1px solid #ddd;
            background-color: #f9f9f9;
            border-radius: 8px 8px 0 0;
        }

        #rank-table-body {
            overflow-y: auto;
            max-height: calc(100vh - 130px);
        }

        .rank-item {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .rank-item:hover {
            background-color: #f0f8ff;
        }

        .rank-item-move {
            background-color: #fffbeb;
            /* Vàng nhạt */
        }

        .rank-item button {
            width: 100%;
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 600;
            color: white;
            border: none;
            border-radius: 4px;
            margin-top: 6px;
            cursor: pointer;
        }

        /* CSS cho các nút trong 1 hàng (cho chức năng Move) */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .button-group button {
            width: auto;
            flex-grow: 1;
            background: #d97706;
            /* Cam */
        }

        .button-group button:hover {
            background: #b45309;
        }

        .rank-item-new button {
            background: #2563eb;
        }

        /* Xanh dương */
        .rank-item-new button:hover {
            background: #1d4ed8;
        }

        /* Icon cho điểm TÂM (dùng ngôi sao) */
        .center-point-icon {
            width: 24px !important;
            height: 24px !important;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: white;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
            }
        }


        /* (MỚI v39) CSS cho Icon Pin (Battery) và Nhãn Tiền */
        .battery-icon-div-wrapper {
            /* Div ngoài cùng của L.divIcon */
            display: flex;
            align-items: center;
            /* Căn giữa div này so với tọa độ lat/lng */
            position: absolute;
            left: 50%;
            top: 50%;
            /* Dịch chuyển [-(width_pin/2 + đầu pin/2), -(height_pin/2)] */
            transform: translate(-23px, -11px);
        }

        .battery-icon-container {
            width: 40px;
            /* (SỬA v39) To hơn */
            height: 20px;
            /* (SỬA v39) To hơn */
            border: 2px solid #555;
            border-radius: 4px;
            background-color: #f0f0f0;
            position: relative;
            display: flex;
            align-items: center;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .battery-icon-container::after {
            content: '';
            position: absolute;
            right: -6px;
            top: 4px;
            width: 4px;
            height: 10px;
            background-color: #555;
            border-radius: 0 2px 2px 0;
        }

        .battery-fill {
            height: 100%;
            border-radius: 1px 0 0 1px;
            transition: width 0.3s ease;
            position: absolute;
            left: 0;
            top: 0;
        }

        .battery-overflow {
            height: 100%;
            border-radius: 1px 0 0 1px;
            transition: width 0.3s ease;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 10;
        }

        .battery-text {
            width: 100%;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
            color: black;
            z-index: 20;
            text-shadow: 0 0 2px white, 0 0 2px white;
            position: relative;
        }

        /* (SỬA v39) Nhãn tiền có viền */
        .battery-amount-label {
            margin-left: 8px;
            /* Khoảng cách từ đầu pin */
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #333;
            border-radius: 3px;
            padding: 1px 4px;
            font-size: 11px;
            font-weight: bold;
            color: black;
            white-space: nowrap;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        /* CSS cho điểm "phình to, nhấp nháy" khi hover MOVE */
        .point-move-preview {
            transform: scale(1.5);
            animation: blink-animation 0.7s infinite alternate;
            z-index: 1001 !important;
        }

        @keyframes blink-animation {
            from {
                opacity: 1.0;
                transform: scale(1.5);
            }

            to {
                opacity: 0.6;
                transform: scale(1.4);
            }
        }

        /* CSS cho Bảng Rank nhấp nháy */
        .rank-item-highlight {
            animation: highlight-green 1.2s ease-in-out infinite alternate;
        }

        @keyframes highlight-green {
            from {
                background-color: #f0f8ff;
            }

            to {
                background-color: #d1fae5;
                border-left: 4px solid #10b981;
                margin-left: -4px;
            }
        }

        /* CSS cho Popup Hành Động */
        .action-popup .leaflet-popup-content-wrapper {
            border-radius: 8px;
            padding: 0;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .action-popup .leaflet-popup-content {
            margin: 0;
            padding: 10px;
            width: 250px !important;
            /* ✨ Tăng chiều rộng lên 250px (từ 220px) ✨ */
            font-size: 14px;
        }

        .action-popup-header {
            font-weight: bold;
            font-size: 16px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
            margin-bottom: 8px;
        }

        .action-popup-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 150px;
            overflow-y: auto;
        }

        .action-popup-buttons button {
            padding: 5px 10px;
            font-size: 13px;
            font-weight: 600;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn-new {
            background: #2563eb;
        }

        .btn-new:hover {
            background: #1d4ed8;
        }

        .btn-add {
            background: #059669;
        }

        .btn-add:hover {
            background: #047857;
        }

        .btn-move {
            background: #d97706;
        }

        .btn-move:hover {
            background: #b45309;
        }

        .action-popup-info {
            font-style: italic;
            color: #555;
        }

        /* (MỚI v39) Style cho popup info pin */
        .battery-info-popup {
            font-style: normal !important;
            color: #333 !important;
            font-size: 13px;
            /* To hơn một chút */
        }

        .battery-info-popup b {
            display: inline-block;
            width: 70px;
            /* Căn lề cho đẹp */
            color: #555;
        }

        /* Tooltip khoảng cách */
        .distance-tooltip {
            background-color: rgba(255, 255, 255, 0.95) !important;
            border: 1.5px solid;
            color: #333 !important;
            font-weight: bold;
            font-size: 12px;

            font-family: 'Times New Roman', Times, serif;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2) !important;
            padding: 3px 6px !important;
            border-radius: 4px;
            cursor: pointer;
            white-space: nowrap;
            /* Bắt buộc Tooltip không xuống dòng */
            font-size: 11px;
            /* Chữ bé đi */
        }

        .distance-tooltip .group-name {
            font-size: 11px;
            /* Đảm bảo kích thước đồng nhất với text còn lại */
            opacity: 1.0;
            display: inline;
            border-bottom: none;
            margin-bottom: 0;
            color: #000;
            /* Đảm bảo TermID luôn có màu đen rõ ràng */
            font-weight: bold;
            /* Đảm bảo TermID nổi bật */
        }

        .distance-tooltip .loading-spinner {
            font-size: 10px;
            color: #999;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 4px;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        /* (ĐÃ SỬA) Ẩn chỉ dẫn của Leaflet Routing Machine MẶC ĐỊNH */
        .leaflet-routing-container {
            display: none;
        }

        /* (SỬA v38) Bỏ width: 110px, đổi sang 100% */
        .leaflet-bar button,
        .leaflet-bar button:hover {
            width: 100% !important;
            /*(SỬA)*/
            height: 32px !important;
            font-size: 13px !important;
            font-weight: 600 !important;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background-color: white !important;
            color: #1f2937 !important;
            margin-bottom: 6px;
            /*(MỚI v38)*/
        }

        .leaflet-bar button:hover {
            background-color: #f3f4f6 !important;
        }

        /* (MỚI v38) CSS cho Bảng Điều Khiển Mới */
        .custom-controls-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid #ccc;
            padding: 8px;
            width: 150px;
            /* Chiều rộng cố định cho panel */
        }

        .custom-controls-container .leaflet-bar-part {
            border: none !important;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .custom-controls-container .leaflet-bar-part:last-child {
            margin-bottom: 0;
        }


        /* Nút Routing */
        #routing-toggle-btn.bird-mode {
            background-color: #fffbeb !important;
            color: #d97706 !important;
        }

        #routing-toggle-btn.car-mode {
            background-color: #3b82f6 !important;
            color: white !important;
        }

        /* Nút Pin */
        #battery-toggle-btn.pin-mode {
            background-color: #ecfdf5 !important;
            color: #059669 !important;
        }

        #battery-toggle-btn.battery-mode {
            background-color: #16a34a !important;
            color: white !important;
        }

        /* Nút Filter */
        #filter-toggle-btn {
            background-color: #6b7280 !important;
            color: white !important;
        }

        #filter-toggle-btn:hover {
            background-color: #4b5563 !important;
        }

        /* (MỚI v42) CSS cho Nút Bật/Tắt Gom Cụm */
        #cluster-toggle-btn.cluster-on {
            background-color: #8b5cf6 !important;
            color: white !important;
        }

        #cluster-toggle-btn.cluster-off {
            background-color: #f3f4f6 !important;
            color: #4b5563 !important;
        }

        #cluster-toggle-btn.cluster-off:hover {
            background-color: #e5e7eb !important;
        }

        /* (MỚI v43) CSS cho Nút Bật/Tắt Nhãn KM */
        #labels-toggle-btn.labels-on {
            background-color: #f59e0b !important;
            color: white !important;
        }

        #labels-toggle-btn.labels-off {
            background-color: #f3f4f6 !important;
            color: #4b5563 !important;
        }

        #labels-toggle-btn.labels-off:hover {
            background-color: #e5e7eb !important;
        }

        /* (*** MỚI v45 ***) CSS cho Nút Bật/Tắt NHNN */
        #nhnn-toggle-btn.nhnn-on {
            background-color: #059669 !important;
            color: white !important;
        }

        /* Màu xanh lá cây */
        #nhnn-toggle-btn.nhnn-off {
            background-color: #f3f4f6 !important;
            color: #4b5563 !important;
        }

        #nhnn-toggle-btn.nhnn-off:hover {
            background-color: #e5e7eb !important;
        }

        /* Toastify */
        .custom-toast {
            font-family: 'Times New Roman', Times, serif !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important;
        }

        .custom-toast.success {
            background: linear-gradient(135deg, #10b981, #059669) !important;
        }

        .custom-toast.info {
            background: linear-gradient(135deg, #3b82f6, #2563eb) !important;
        }

        .custom-toast.warning {
            background: linear-gradient(135deg, #f59e0b, #d97706) !important;
        }

        .custom-toast.error {
            background: linear-gradient(135deg, #ef4444, #dc2626) !important;
        }

        /* CSS CHO ROUTING ĐỘNG */
        @keyframes route-flow {
            to {
                stroke-dashoffset: -20;
            }
        }

        .animated-route-line {
            animation: route-flow 1s linear infinite;
        }

        /* === CSS CHO BẢNG ĐIỀU KHIỂN BỘ LỌC (SỬA VỊ TRÍ) === */
        #filter-controls-container {
            position: absolute;
            top: 10px;
            /* Đẩy lên trên cùng */
            /* (SỬA v55) Vị trí mặc định lùi khỏi Search Bar */
            right: 320px;
            width: 250px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1003;
            /* Nổi lên trên Search (1001) */
            font-size: 13px;
            padding: 10px 15px;
            font-family: 'Times New Roman', Times, serif;
            display: none;

            max-height: calc(100vh - 20px);
            overflow-y: auto;
            transition: right 0.3s ease;
            /* Thêm transition */
        }

        #filter-controls-header {
            font-size: 16px;
            font-weight: bold;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
            margin-bottom: 10px;
            /* (MỚI) Căn chỉnh tiêu đề và nút đóng */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* (MỚI) CSS cho nút đóng 'X' */
        #close-filter-btn {
            font-size: 24px;
            font-weight: bold;
            color: #777;
            cursor: pointer;
            line-height: 1;
            padding: 0 5px;
        }

        #close-filter-btn:hover {
            color: #000;
        }

        .filter-control {
            margin-bottom: 8px;
        }

        .filter-control label {
            display: block;
            margin-bottom: 4px;
            font-weight: 600;
            color: #333;
        }

        .filter-control input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        /* (MỚI v35) CSS cho dropdown filter */
        .filter-control select {
            width: 100%;
            padding: 5px 8px;
            font-size: 13px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: 'Times New Roman', Times, serif;
            background-color: white;
        }

        /* (MỚI v35) CSS cho nút Reset Filter */
        #reset-cascading-filter-btn {
            width: 100%;
            padding: 5px 8px;
            font-size: 13px;
            font-weight: 600;
            color: white;
            background-color: #dc2626;
            /* Màu đỏ */
            border: none;
            border-radius: 4px;
            margin-top: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #reset-cascading-filter-btn:hover {
            background-color: #b91c1c;
        }

        /* === (MỚI v41.1) CSS CHO ICON GOM CỤM TÙY CHỈNH === */
        .my-cluster-icon {
            /* (Bạn có thể thay màu nền tại đây) */
            background-color: rgba(245, 130, 49, 0.8);
            /* Màu cam */
            border: 2px solid rgba(245, 130, 49, 1);
            border-radius: 50%;
            /* Bo tròn */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);

            /* Dùng flex để căn giữa số đếm */
            display: flex;
            align-items: center;
            justify-content: center;

            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            font-family: Arial, sans-serif;

            /* Dịch chuyển icon một chút để nó căn đúng vào tâm */
            margin-left: -20px;
            margin-top: -20px;
        }

        /* CSS cho số đếm bên trong */
        .my-cluster-icon span {
            /* Không cần thiết lắm vì đã dùng flex, nhưng để cho chắc */
            line-height: 1;
        }

        /* Định nghĩa kích thước dựa trên "cấp độ" */
        .my-cluster-icon.small {
            width: 30px;
            height: 30px;
            margin-left: -15px;
            margin-top: -15px;
            font-size: 13px;
        }

        .my-cluster-icon.medium {
            width: 40px;
            height: 40px;
            margin-left: -20px;
            margin-top: -20px;
            font-size: 14px;
        }

        .my-cluster-icon.large {
            width: 50px;
            height: 50px;
            margin-left: -25px;
            margin-top: -25px;
            font-size: 16px;
        }

        /* (*** MỚI v49 ***) CSS cho Nút Toggle Panel Chính (Nút Hamburger) */
        #panel-toggle-btn {
            width: 100%;
            height: 100%;
            font-size: 18px !important;
            background-color: #059669 !important;
            /* (SỬA v49) MÀU XANH LÁ */
            color: white !important;
            border-radius: 8px;
            /* Khớp với container */
            border: none !important;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        #panel-toggle-btn:hover {
            background-color: #047857 !important;
            /* (SỬA v49) Xanh đậm hơn */
        }

        /* (*** MỚI v49 ***) CSS cho Nút Thu Gọn (Collapse) */
        #panel-collapse-btn {
            background-color: #6b7280 !important;
            color: white !important;
            /* (SỬA v49) Căn giữa icon (vì không còn chữ) */
            justify-content: center !important;
            padding-left: 0 !important;
        }

        #panel-collapse-btn:hover {
            background-color: #4b5563 !important;
        }

        /* (*** MỚI v47 ***) CSS Ẩn/Hiện Wrapper chứa các nút */
        .buttons-wrapper {
            display: block;
            /* Hiển thị mặc định (cho desktop) */
        }

        /* === (SỬA v55) CSS MỚI CHO BỐ CỤC CHUNG === */

        /* 1. Panel Bảng Xếp Hạng: LUÔN Ở BÊN TRÁI */
        /* (Vị trí gốc được giữ nguyên) */

        /* 2. Panel Filter: (SỬA v55) LUÔN Ở BÊN PHẢI */
        #filter-controls-container {
            /* Vị trí mặc định lùi khỏi Search Bar */
            right: 10px;
            left: auto;
            z-index: 2000;
        }

        /* 3. Panel Nút Bấm: LUÔN ở góc TRÊN bên phải */
        .leaflet-top.leaflet-right {
            top: 10px;
            bottom: auto;
            right: 0px;
            /* (*** SỬA LỖI v55 ***) Đảm bảo Menu ☰ nổi lên trên Search và Filter */
            z-index: 1005;
        }

        /* 4. Panel chính (custom-controls-container) LUÔN là nút ☰ */
        .custom-controls-container {
            width: 40px;
            /* Kích thước nút toggle */
            height: 40px;
            padding: 0;
            /* Xóa padding */
            overflow: hidden;
            /* Ẩn các nút con */
            background: transparent;
            /* Tắt nền trắng của panel */
            border: none;
            /* Tắt viền của panel */
            box-shadow: none;
            /* Tắt bóng của panel */
            transition: width 0.3s ease;
            /* Thêm transition */
        }

        /* 5. Panel chính khi được BẬT (expanded) */
        .custom-controls-container.expanded {
            width: 180px;
            /* DÀI RA CHÚT (từ 150px) */
            height: auto;
            padding: 8px;
            /* Thêm lại padding */
            background: rgba(255, 255, 255, 0.9);
            /* Thêm lại nền */
            border: 1px solid #ccc;
            /* Thêm lại viền */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            /* Thêm lại bóng */
        }

        /* 6. Ẩn wrapper nút con MẶC ĐỊNH */
        .buttons-wrapper {
            display: none;
        }

        /* 7. Hiển thị wrapper khi panel được BẬT */
        .custom-controls-container.expanded .buttons-wrapper {
            display: block;
        }

        /* 8. Ẩn nút toggle (hamburger) khi panel được BẬT */
        .custom-controls-container.expanded #panel-toggle-btn {
            display: none;
        }

        /* 9. Hiển thị nút toggle (hamburger) MẶC ĐỊNH */
        #panel-toggle-btn {
            display: flex;
            /* Hiển thị nút hamburger */
        }

        /* 10. Ẩn chữ (span) mặc định (khi co lại) */
        .custom-controls-container .button-text {
            display: none;
        }

        /* 11. Hiển thị chữ khi panel bung ra */
        .custom-controls-container.expanded .button-text {
            display: inline;
            /* Hiện lại chữ */
        }

        /* 12. Các nút con bên trong khi bung ra */
        .custom-controls-container.expanded .leaflet-bar-part {
            width: 100% !important;
            /* Các nút con 100% width */
            height: 40px !important;
            font-size: 16px !important;
            /* (MỚI v49) Căn lề chữ cho đẹp (hết díu) */
            justify-content: flex-start !important;
            padding-left: 10px !important;
        }

        /* 13. Nút hamburger (khi chưa bung) */
        #panel-toggle-btn.leaflet-bar-part {
            width: 40px !important;
            height: 40px !important;
            font-size: 16px !important;
            /* (MỚI v49) Ghi đè: Giữ nút ☰ ở giữa */
            justify-content: center !important;
            padding-left: 0 !important;
        }

        /* 14. (Ghi đè Desktop) Áp dụng luật mobile cho desktop */
        @media (min-width: 769px) {
            #panel-toggle-btn {
                display: flex;
                /* Vẫn hiển thị nút ☰ */
            }

            .buttons-wrapper {
                display: none;
                /* Vẫn ẩn wrapper */
            }

            /* Sửa lại panel Filter trên desktop */
            #filter-controls-container {
                width: 250px;
                /* Trả về độ rộng cũ */
                right: 320px;
                /* Giữ nguyên vị trí lùi khỏi Search */
                left: auto;
            }
        }

        #close-filter-btn:hover {
            color: #000;
        }

        /* (*** MỚI v50 ***) CSS cho nút đóng Bảng Xếp Hạng */
        #close-rank-btn {
            font-size: 24px;
            font-weight: bold;
            color: #777;
            cursor: pointer;
            line-height: 1;
            padding: 0 5px;
            float: right;
            /* Căn sang phải */
        }

        #close-rank-btn:hover {
            color: #000;
        }

        /* (SỬA v50) Sửa Header của Bảng Xếp Hạng để chứa nút X */
        #rank-table-header {
            display: block;
            /* Đảm bảo nút X (dùng float) hoạt động */
        }

        /* === SỬA ĐỔI VỊ TRÍ VÀ HIỂN THỊ CỦA THANH TÌM KIẾM (SỬA LỖI v55 & MỚI) === */
        /* Thêm transition cho độ trong suốt */
        #search-control-container {
            position: absolute;
            top: 30px;
            right: 200px;
            /* Vị trí mặc định: Cách Menu ☰ 10px (Menu: 40px + 10px gap) */
            width: 250px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1999;
            padding: 8px;
            height: auto;

            /* (*** MỚI: ẨN MẶC ĐỊNH & THÊM HIỆU ỨNG ***) */
            display: none;
            opacity: 0;
            transition: right 0.3s ease, opacity 0.3s ease, transform 0.3s ease;
            transform: translateX(100%);
            /* Chuẩn bị trượt ra từ bên phải */
        }

        /* HIỂN THỊ KHI ĐƯỢC BẬT BẰNG JS (Class search-panel-active) */
        #search-control-container.search-panel-active {
            display: flex;
            /* Dùng flex vì bạn có nhiều phần tử bên trong */
            flex-direction: column;
            opacity: 1;
            transform: translateX(0);
        }

        /* KHẮC PHỤC TRÙNG LẤN VỚI MENU MỞ RỘNG (EXPANDED) */
        /* (Bây giờ chúng ta dùng JS để điều khiển vị trí khi mở) */
        .custom-controls-container.expanded+#search-control-container.search-panel-active {
            /* Khi Menu mở rộng (180px), đẩy Search panel ra xa hơn */
            right: 190px;
            /* 180px (Menu) + 10px (gap) */
        }

        /* Đảm bảo Panel Filter lùi khỏi Search bar khi Search panel hiện */
        #search-control-container.search-panel-active+#filter-controls-container {
            right: 320px;
            /* 60px (Search container right) + 250px (Search width) + 10px (gap) */
        }

        /* Đảm bảo Panel Filter lùi khỏi Search bar khi cả hai đều mở */
        .custom-controls-container.expanded+#search-control-container.search-panel-active+#filter-controls-container {
            right: 450px;
            /* 190px (Search container right) + 250px (Search width) + 10px (gap) */
        }

        /* Giữ Filter ở vị trí cũ khi Search/Menu ẩn */
        #filter-controls-container {
            right: 10px !important;
            /* Vị trí mặc định của Filter (Gần rìa phải) */
            transition: right 0.3s ease;
            /* Thêm transition */
        }

        /* (MỚI v54) Vùng chứa Input & Button */
        .search-input-group {
            display: flex;
            gap: 5px;
        }

        #search-control-container input {
            flex-grow: 1;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            font-family: 'Times New Roman', Times, serif;
            outline: none;
        }

        #search-control-container button {
            padding: 6px 10px;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #search-control-container button:hover {
            background-color: #2563eb;
        }

        /* === KHẮC PHỤC TRÙNG LẤN VỚI MENU MỞ RỘNG (EXPANDED) === */
        /* (Sửa lỗi này đã được áp dụng trong CSS trên) */
        /* === STYLE CHO PHẦN KẾT QUẢ/GỢI Ý TÌM KIẾM (MỚI v54) === */
        #search-results-container {
            max-height: 200px;
            overflow-y: auto;
            border-top: 1px solid #eee;
            margin-top: 8px;
            padding-top: 5px;
            display: none;
            /* Mặc định ẩn */
        }

        /* === (MỚI v57) CSS cho Tooltip Tùy Chỉnh === */
        .search-result-item {
            position: relative;
            /* Quan trọng: Để tooltip căn theo vị trí này */
            /* ... các thuộc tính cũ ... */
        }

        /* Ẩn tooltip mặc định của trình duyệt */
        .search-result-item[title]:hover {
            pointer-events: none;
            /* Ngăn chặn Tooltip mặc định */
        }

        .search-result-item::before,
        .search-result-item::after {
            --arrow-size: 6px;
            /* Kích thước mũi tên */
            position: absolute;
            display: none;
            /* Mặc định ẩn */
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 2001;
            /* Đảm bảo nổi lên trên mọi thứ */
        }

        /* Tooltip: Dùng ::after */
        .search-result-item::after {
            content: attr(data-title);
            /* Lấy nội dung từ thuộc tính data-title */
            top: calc(100% + var(--arrow-size) + 5px);
            /* Vị trí bên dưới item + khoảng cách mũi tên */
            left: 50%;
            transform: translateX(-50%);

            padding: 6px 10px;
            min-width: 150px;
            max-width: 250px;

            background-color: #333;
            /* Màu nền đen */
            color: white;
            border-radius: 4px;
            text-align: center;
            font-size: 13px;
            line-height: 1.4;
            white-space: normal;
            /* Cho phép chữ xuống dòng */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Mũi tên: Dùng ::before */
        .search-result-item::before {
            content: '';
            top: calc(100% + 5px);
            /* Vị trí của mũi tên */
            left: 50%;
            transform: translateX(-50%) rotate(45deg);

            width: var(--arrow-size);
            height: var(--arrow-size);
            background-color: #333;
            /* Màu nền đen */
            border-radius: 2px;
        }

        /* HIỂN THỊ khi HOVER */
        .search-result-item:hover::before,
        .search-result-item:hover::after {
            display: block;
            opacity: 1;
        }

        /* --- STYLE BỔ SUNG CHO MEASURE SEARCH --- */
        .search-results-container {
            max-height: 150px;
            overflow-y: auto;
            border-top: 1px solid #eee;
            background-color: white;
            z-index: 1000;
            position: relative;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
        }

        .search-input-group input {
            border-radius: 4px;
            /* Reset Tailwind's default */
        }

        .search-input-group button {
            padding: 6px 10px;
            background-color: #6b7280;
            /* Màu xám đậm */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }

        .search-input-group button:hover {
            background-color: #4b5563;
            /* Màu xám tối hơn khi hover */
        }

        .search-result-item {
            padding: 8px 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 0.9rem;
        }

        .search-result-item:hover {
            background-color: #f0f0f0;
        }

        /* === CSS cho Tooltip Tâm Nhóm (Compact) === */
        .distance-tooltip-compact {
            font-size: 11px !important;
            /* Chữ bé hơn */
            white-space: nowrap;
            /* Đảm bảo không xuống dòng */
            padding: 3px 6px !important;
        }

        /* === CSS cho Tooltip Term ID (Tên điểm) === */
        .termid-label-tooltip {
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #999;
            border-radius: 4px;
            padding: 2px 4px;
            font-size: 10px;
            /* Chữ nhỏ */
            font-weight: bold;
            color: #444;
            white-space: nowrap;
            opacity: 1;
            pointer-events: none;
            /* Không chặn sự kiện click vào Marker phía dưới */
        }

        /* Loại bỏ mũi tên nhọn của Tooltip */
        .termid-label-tooltip .leaflet-tooltip-tip {
            background: transparent;
            border: none;
            box-shadow: none;
        }

        /* Tùy chỉnh CSS cho thanh trượt (nếu cần) */
        .control-section {
            padding: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .control-label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            font-size: 14px;
        }

        #radius-slider {
            width: 100%;
            margin-top: 5px;
        }

        /* === BỔ SUNG: CSS CHO CHẾ ĐỘ MOBILE (max-width: 768px) === */
        @media (max-width: 768px) {

            /* --- VỊ TRÍ CHUNG CHO TẤT CẢ PANEL --- */
            #rank-table-container,
            #filter-controls-container,
            #search-control-container {
                /* Đảm bảo panel nằm trên cùng, full chiều rộng */
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                width: 100vw !important;
                /* Chiếm toàn bộ chiều rộng */
                max-width: 100vw;
                height: 100vh !important;
                /* Chiếm toàn bộ chiều cao */
                max-height: 100vh;
                border-radius: 0;
                /* Loại bỏ góc bo tròn */
                padding: 10px;
                box-shadow: none;
                z-index: 5000;
                /* Đảm bảo nổi lên trên mọi thứ */
                transform: translateX(0) !important;
                /* Vô hiệu hóa animation trượt ngang */
                transition: none !important;
                /* Vô hiệu hóa transition vị trí */
            }

            /* --- PANEL TÌM KIẾM CẦN DÙNG FLEX ĐỂ CUỘN --- */
            #search-control-container {
                flex-direction: column;
                display: none;
                /* Ẩn mặc định trên mobile, dùng JS để hiển thị */
            }

            #search-control-container.search-panel-active {
                display: flex;
                /* Hiện khi active */
            }

            /* --- PANEL FILTER --- */
            #filter-controls-container {
                right: 0 !important;
                /* Ghi đè vị trí right do các logic trước đó */
                left: 0 !important;
            }

            /* --- BẢNG XẾP HẠNG (RANK) --- */
            #rank-table-body {
                max-height: calc(100vh - 60px) !important;
                /* Chiều cao còn lại sau header */
            }
        }

        /* --- Popup Actions Buttons --- */
        .action-popup-header {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }

        .action-popup-buttons button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.1s;
            font-size: 13px;
            position: relative;
            /* Cho chấm trạng thái */
        }

        .action-popup-buttons button i {
            margin-right: 6px;
        }

        .action-popup-buttons button:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        .action-popup-buttons button.btn-new {
            background-color: #f7941d;
            /* Màu cam */
        }

        .action-popup-buttons button.btn-measure {
            position: relative;
            border: 2px solid transparent;
            /* Viền mặc định */
        }

        .action-popup-buttons button.btn-measure.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            filter: grayscale(10%);
            pointer-events: none;
            /* Ngăn chặn click */
        }

        /* Chấm trạng thái (nằm trong nút) */
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: transparent;
            /* Mặc định không hiển thị */
            position: absolute;
            top: 5px;
            /* Điều chỉnh vị trí */
            right: 5px;
            /* Điều chỉnh vị trí */
            display: block;
            /* Luôn hiển thị để giữ không gian */
        }

        .status-dot.green-dot {
            background-color: #28a745;
            /* Màu xanh lá cây */
        }

        /* Hiệu ứng viền nhấp nháy cho nút đã chọn */
        @keyframes blink-border {
            0% {
                border-color: transparent;
            }

            50% {
                border-color: #fff;
                box-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
            }

            100% {
                border-color: transparent;
            }
        }

        .btn-measure.selected-blinking {
            animation: blink-border 1s infinite;
        }

        /* Nút hành động đo lường (car, walking, trash) */
        .button-group.measure-action-group button {
            background-color: #6c757d;
            /* Màu xám trung tính */
            color: white;
            font-size: 16px;
            /* Icon lớn hơn */
            padding: 8px;
            height: 40px;
            /* Chiều cao cố định */
        }

        .button-group.measure-action-group button:hover {
            background-color: #5a6268;
        }

        .button-group.measure-action-group button:nth-child(1) {
            /* Car */
            background-color: #17a2b8;
            /* Màu xanh dương nhạt */
        }

        .button-group.measure-action-group button:nth-child(1):hover {
            background-color: #138496;
        }

        .button-group.measure-action-group button:nth-child(2) {
            /* Walking */
            background-color: #28a745;
            /* Màu xanh lá cây */
        }

        .button-group.measure-action-group button:nth-child(2):hover {
            background-color: #218838;
        }

        .button-group.measure-action-group button:nth-child(3) {
            /* Trash */
            background-color: #dc3545;
            /* Màu đỏ */
        }

        .button-group.measure-action-group button:nth-child(3):hover {
            background-color: #c82333;
        }

        /* Popup tổng thể */
        .leaflet-popup-content-wrapper .action-popup-buttons {
            padding-bottom: 5px;
            /* Thêm padding dưới để tránh sát mép */
        }

        /* === SỬA LỖI VÀ TĂNG CƯỜNG HIỆU ỨNG GLOW & JUMPING (THEO YÊU CẦU MỚI) === */
        /* Đảm bảo icon chính không bị ẩn */
        .leaflet-marker-icon.pulsing-marker-A,
        .leaflet-marker-icon.pulsing-marker-B {
            /* Áp dụng animation nhảy */
            animation: marker-jump 0.8s infinite alternate ease-in-out;
            transform-origin: 50% 100%;
            z-index: 100;
            filter: none;
            /* Rất quan trọng: Vô hiệu hóa filter có thể làm đen icon */
        }

        /* Keyframes cho hiệu ứng nhảy (Jump) */
        @keyframes marker-jump {
            0% {
                transform: translateY(0);
            }

            100% {
                transform: translateY(-10px);
            }

            /* Nhảy lên 10px */
        }

        /* CSS QUẦNG SÁNG (GLOW EFFECT) */
        .leaflet-marker-icon.pulsing-marker-A::after,
        .leaflet-marker-icon.pulsing-marker-B::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            /* Dịch chuyển để căn giữa tại chân Icon */
            transform: translate(-50%, 0);
            width: 35px;
            height: 35px;
            border-radius: 50%;
            z-index: -1;
            /* Đặt dưới icon chính */
            pointer-events: none;
        }

        /* Thiết lập màu sắc và animation cho Điểm A */
        .leaflet-marker-icon.pulsing-marker-A::after {
            background-color: rgba(0, 123, 255, 1.0);
            /* Xanh dương đậm */
            box-shadow: 0 0 15px rgba(0, 123, 255, 0.9);
            animation: marker-pulse-glow-A 1s infinite;
        }

        /* Thiết lập màu sắc và animation cho Điểm B */
        .leaflet-marker-icon.pulsing-marker-B::after {
            background-color: rgba(220, 53, 69, 1.0);
            /* Đỏ đậm */
            box-shadow: 0 0 15px rgba(220, 53, 69, 0.9);
            animation: marker-pulse-glow-B 1s infinite;
        }

        /* KEYFRAMES MẠNH MẼ HƠN (GLOW) */
        @keyframes marker-pulse-glow-A {
            0% {
                transform: translate(-50%, 0) scale(0.5);
                opacity: 1.0;
            }

            100% {
                transform: translate(-50%, 0) scale(2.2);
                opacity: 0.0;
            }
        }

        @keyframes marker-pulse-glow-B {
            0% {
                transform: translate(-50%, 0) scale(0.5);
                opacity: 1.0;
            }

            100% {
                transform: translate(-50%, 0) scale(2.2);
                opacity: 0.0;
            }
        }

        /* CSS cho Màn Hình Loading */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Đảm bảo màn hình hiển thị toàn bộ viewport */

            display: flex;
            justify-content: center;
            align-items: center;
            /* Căn giữa toàn bộ nội dung */

            z-index: 9999;

            /* TRẠNG THÁI ẨN/HIỆN (Dùng lớp 'visible' để hiển thị) */
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .loading-screen.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .loading-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;

            /* 1. NỀN MỜ (SEMI-TRANSPARENT OVERLAY) */
            background-color: rgba(0, 0, 0, 0.4);
            /* Màu đen nhẹ trong suốt (20% opacity) */

            /* 2. HIỆU ỨNG BLUR QUAN TRỌNG (Blur ảnh nền phía sau) */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            /* Hỗ trợ Safari */
        }

        .loading-content {
            position: relative;
            /* Đảm bảo nội dung nổi trên lớp background */
            z-index: 10000;
            text-align: center;

            /* Cung cấp nền trắng mờ cho nội dung để dễ đọc hơn */
            background-color: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        /* Cập nhật style cho Lottie Player */
        #loadingAnimation {
            /* Đảm bảo Lottie Player được hiển thị là block */
            display: block;
            margin: 0 auto 15px auto;
            /* Căn giữa Lottie và tạo khoảng cách dưới */
            width: 80px;
            height: 80px;
        }

        #loadingText {
            font-family: 'Times New Roman', Times, serif;
            font-size: 1.1em;
            color: #333;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-background"></div>
        <div id="loadingContent" class="loading-content">
            <dotlottie-wc id="loadingAnimation"
                src="https://lottie.host/d446a9ec-3c6a-4972-8867-a22b1a98a52b/pywJYiMejV.lottie"
                style="width: 80px; height: 80px; margin-bottom: 15px;" autoplay loop>
            </dotlottie-wc>
            <div id="loadingText" class="loading-text">Đang tải dữ liệu...</div>
        </div>
    </div>
    </div>
    <div id="map"></div>
    <div id="rank-table-container">
        <div id="rank-table-header">
            Bảng Xếp Hạng Lựa Chọn
            <span id="close-rank-btn" onclick="event.stopPropagation(); closeRankPanel();">&times;</span>
        </div>
        <div id="rank-table-body">
        </div>
    </div>
    <div id="search-control-container">
        <div id="search-control-header"
            style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 10px;">
            <span style="font-size: 16px; font-weight: bold;">Tìm kiếm & Đo lường</span>
            <span id="close-search-btn" onclick="event.stopPropagation(); toggleSearchPanel();"
                style="font-size: 24px; font-weight: bold; color: #777; cursor: pointer; line-height: 1; padding: 0 5px;">&times;</span>
        </div>
        <div class="search-input-group">
            <input type="text" id="termid-search-input" placeholder="Tìm theo Mã CN hoặc Tên HUB...">
            <button id="search-button" onclick="searchByTermId()">
                <i class="fa-solid fa-magnifying-glass"></i>
            </button>
        </div>
        <div id="search-results-container">
        </div>
        <hr class="my-3 border-t border-gray-300">
        <div id="proposal-container">
            <label style="font-weight: bold; margin-bottom: 5px; display: block;">Danh sách Đề xuất (Tối đa 5):</label>
            <div id="proposal-list"
                class="flex flex-col gap-2 p-2 border border-gray-300 rounded-md bg-white min-h-[40px]">
            </div>
            <button id="optimize-button" onclick="startOptimization()"
                class="w-full mt-3 px-3 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out disabled:bg-gray-400"
                disabled>
                <i class="fa-solid fa-cogs mr-1"></i> Tối Ưu Hóa (Bán kính: <span id="optimize-radius-display">30</span>
                km)
            </button>
            <button id="clear-optimization-btn" onclick="clearOptimizationVisuals()"
                class="w-full mt-2 px-3 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out"
                style="display: none;">
                <i class="fa-solid fa-trash-alt mr-1"></i> Xóa Vòng Tròn Đề Xuất
            </button>
        </div>
        <hr class="my-3 border-t border-gray-300">
        <div id="measurement-log"
            style="font-size: 14px; font-weight: bold; padding: 5px 0; min-height: 20px; color: #333; border-bottom: 1px solid #ddd; margin-bottom: 10px; display: none;">
        </div>
        <div id="search-a-container">
            <label for="search-a-input" style="font-weight: bold; margin-bottom: 5px; display: block;">Điểm Bắt đầu
                (A):</label>
            <div class="search-input-group">
                <input type="text" id="search-a-input" placeholder="Mã CN/Tên HUB (Start)">
                <button onclick="searchMeasurePoint('A')">
                    <i class="fa-solid fa-magnifying-glass"></i>
                </button>
            </div>
            <div id="search-a-results" class="search-results-container"></div>
        </div>
        <div id="search-b-container" style="margin-top: 10px;">
            <label for="search-b-input" style="font-weight: bold; margin-bottom: 5px; display: block;">Điểm Kết thúc
                (B):</label>
            <div class="search-input-group">
                <input type="text" id="search-b-input" placeholder="Mã CN/Tên HUB (End)">
                <button onclick="searchMeasurePoint('B')">
                    <i class="fa-solid fa-magnifying-glass"></i>
                </button>
            </div>
            <div id="search-b-results" class="search-results-container"></div>
        </div>
        <div class="flex space-x-2 mt-4">
            <button id="measure-route-btn" onclick="measureRouteBetweenAandB()"
                class="flex-1 px-3 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out">
                <i class="fa-solid fa-route mr-1"></i> Đo Lái Xe
            </button>
            <button id="measure-straight-btn" onclick="measureStraightLineBetweenAandB()"
                class="flex-1 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out">
                <i class="fa-solid fa-ruler mr-1"></i> Đường Chim Bay
            </button>
            <button id="clear-measure-btn" onclick="clearMeasurement()"
                class="flex-1 px-3 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out">
                <i class="fa-solid fa-trash mr-1"></i> Xóa Đo
            </button>
        </div>
    </div>
    <div id="filter-controls-container">
        <div id="filter-controls-header">
            Tùy Chỉnh Bản Đồ
            <span id="close-filter-btn" onclick="event.stopPropagation(); toggleFilterControls();">&times;</span>
        </div>
        <div class="control-section">
            <label for="radius-slider" class="control-label">Bán kính Phân tích (<span id="radius-value">30</span>
                km)</label>
            <input type="range" id="radius-slider" min="30" max="100" step="10" value="30">
        </div>
        <div class="filter-control">
            <label for="grayscale-slider">Độ xám: 0.0</label>
            <input type="range" id="grayscale-slider" min="0" max="1" step="0.1" value="0">
        </div>
        <div class="filter-control">
            <label for="brightness-slider">Độ sáng: 0.95</label>
            <input type="range" id="brightness-slider" min="0.5" max="1.5" step="0.05" value="0.95">
        </div>
        <div class="filter-control">
            <label for="contrast-slider">Tương phản: 0.5</label>
            <input type="range" id="contrast-slider" min="0.5" max="2" step="0.1" value="0.5">
        </div>
        <div class="filter-control">
            <label for="blur-slider">Độ nhòe (Blur): 0 px</label>
            <input type="range" id="blur-slider" min="0" max="10" step="0.5" value="0">
        </div>
<div id="cascading-filter-container">
    <button id="apply-filter-btn" 
        onclick="applyFilter()"
        class="w-full mt-4 px-3 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out">
        <i class="fa-solid fa-filter mr-1"></i> ÁP DỤNG LỌC
    </button>
    
    <button id="reset-cascading-filter-btn">
        <i class="fa-solid fa-filter-circle-xmark"></i> Xóa Lọc
    </button>
</div>
    </div>

    <script>
        // Global variable
        const loadingScreen = document.getElementById('loadingScreen');
        const loadingAnimation = document.getElementById('loadingAnimation');
        const loadingText = loadingScreen.querySelector('.loading-text');

        function showLoadingScreen(lottieSrc = 'https://lottie.host/d446a9ec-3c6a-4972-8867-a22b1a98a52b/pywJYiMejV.lottie', text = 'Đang xử lý...') {
            if (loadingScreen) {
                if (loadingAnimation) loadingAnimation.src = lottieSrc;
                if (loadingText) loadingText.textContent = text;
                loadingScreen.classList.add('visible');
            }
        }

        function hideLoadingScreen() {
            if (loadingScreen) loadingScreen.classList.remove('visible');
        }
        /**
         * Lưu dữ liệu bản đồ lên SharePoint thông qua RPA Flow.
         * Xuất dữ liệu nhóm (tương tự exportGroupsData) cùng với allPoints và metadata.
         */
        function saveData() {
            // ⚠️ Đảm bảo URL này chứa token xác thực Flow (sp, sv, sig) ⚠️
            const SAVE_FLOW_URL = 'https://default460cecfbf0c64dd7a5ec66ef4d75ae.63.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/59e0b2176e17419ca76c5718ee30a172/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=xJAKlTazxzkypaF1yhUDN-5AtQZYy5wyaAKgdmh9m_g&save';

            if (allGroups.length === 0) {
                // Xóa dữ liệu cũ nếu không còn nhóm nào
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                showToast("Đã xóa dữ liệu nhóm cũ trong trình duyệt.", "warning");
                return;
            }

            // 1. Chuyển đổi dữ liệu thô sang cấu trúc gọn gàng
            const exportedData = allGroups.map(group => {
                // Lọc ra ID của tất cả các điểm trong nhóm (bao gồm điểm tâm)
                const memberIds = group.points.map(p => p.id);
                return {
                    group_id: group.id,
                    group_number: group.groupNumber,
                    color: group.color,
                    center_point: {
                        id: group.centerPoint.id,
                        lat: group.centerPoint.latlng.lat,
                        lon: group.centerPoint.latlng.lng,
                    },
                    fixedRadiusMeters: group.fixedRadiusMeters,
                    fixedRadiusKm: group.fixedRadiusKm,
                    member_ids: memberIds, // <--- ĐÃ GOM CẢ ĐIỂM TÂM
                    polyline_cache: group.polylineCache,
                    member_count: memberIds.length
                };
            });

            // ✨ LỆNH LOG MỚI: Ghi lại cấu trúc Array đã xuất ✨
            console.log("--- DỮ LIỆU EXPORTEDDATA (LOCAL STORAGE) ---");
            console.log(exportedData);
            console.log("-------------------------------------------");



            try {
                showToast("Đang gửi dữ liệu nhóm lên SharePoint...", 'info');

                fetch(SAVE_FLOW_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(exportedData)
                })
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(err => { throw new Error(err.message || response.statusText); });
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log("Lưu dữ liệu thành công:", data);
                        showToast("✅ Lưu dữ liệu thành công!", 'success');
                    })
                    .catch(error => {
                        console.error("Lỗi khi lưu dữ liệu:", error);
                        showToast(`Lỗi khi lưu dữ liệu: ${error.message}`, 'error');
                    });
            } catch (e) {
                console.error("Lỗi Fetch/Serialize:", e);
                showToast("Lỗi hệ thống khi cố gắng kết nối.", 'error');
            }
        }
        /**
         * Tải dữ liệu bản đồ từ SharePoint thông qua RPA Flow và tái tạo trạng thái.
         * Hàm này ĐẢM NHIỆM việc phục hồi nhóm bằng cách gọi lại logic chi tiết của loadSavedGroups.
         */

        function loadData() {
            const LOAD_FLOW_URL = 'https://default460cecfbf0c64dd7a5ec66ef4d75ae.63.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/59e0b2176e17419ca76c5718ee30a172/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=xJAKlTazxzkypaF1yhUDN-5AtQZYy5wyaAKgdmh9m_g&load';

            showToast("Đang tải dữ liệu nhóm từ Flow...", 'info');

            return fetch(LOAD_FLOW_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
                .then(response => {
                    // KHÔNG CÓ hideLoadingScreen() ở đây nữa
                    if (!response.ok) {
                        return response.json().then(err => { throw new Error(err.message || response.statusText); });
                    }
                    return response.json();
                })
                .then(loadedData => {
                    // --- Bắt đầu Logic Tái tạo Nhóm ---
                    allPoints.forEach(p => p.groupId = null);

                    let groupsToProcess;
                    if (Array.isArray(loadedData)) {
                        groupsToProcess = loadedData;
                    } else if (loadedData && (loadedData.groups || loadedData.allPoints)) {
                        groupsToProcess = Array.isArray(loadedData.groups) ? loadedData.groups : loadedData.groups ? Object.values(loadedData.groups) : [];
                        if (loadedData.metadata && typeof loadedData.metadata.RADIUS_METERS !== 'undefined') {
                            RADIUS_METERS = Number(loadedData.metadata.RADIUS_METERS);
                            currentRadiusKm = RADIUS_METERS / 1000;
                            if (typeof setupRadiusControl === 'function') setupRadiusControl();
                        }
                        if (loadedData.allPoints && Array.isArray(loadedData.allPoints)) {
                            loadedData.allPoints.forEach(loadedP => {
                                const existingP = allPoints.find(p => p.id === loadedP.id);
                                if (existingP) {
                                    existingP.groupId = loadedP.groupId || null;
                                    existingP.isHub = loadedP.isHub || false;
                                    existingP.isBatteryPoint = loadedP.isBatteryPoint || false;
                                }
                            });
                        }
                    } else {
                        showToast("Không tìm thấy dữ liệu đã lưu hoặc dữ liệu rỗng.", 'warning');
                        // Nếu không có dữ liệu, vẫn ẩn loading.
                        hideLoadingScreen(); // ✨ VỊ TRÍ ẨN 1/2 (Không có dữ liệu) ✨
                        return;
                    }

                    allGroups = [];
                    groups = {};
                    let loadCount = 0;

                    groupsToProcess.forEach(savedGroup => {
                        const centerPointObj = savedGroup.center_point;
                        const centerPointId = centerPointObj.id;
                        const centerPointData = allPoints.find(p => p.id === centerPointId);

                        if (!centerPointData) { return; }

                        const newGroup = {
                            id: savedGroup.group_id,
                            centerPoint: centerPointData,
                            color: savedGroup.color,
                            groupNumber: savedGroup.group_number,
                            routingControls: savedGroup.routingControls || [],
                            polylineCache: savedGroup.polyline_cache || {},
                            fixedRadiusMeters: Number(savedGroup.fixedRadiusMeters) || RADIUS_METERS,
                            fixedRadiusKm: Number(savedGroup.fixedRadiusKm) || currentRadiusKm,
                            points: []
                        };

                        const memberIds = savedGroup.member_ids;
                        const pointsInGroup = [];
                        centerPointData.groupId = savedGroup.group_id;
                        pointsInGroup.push(centerPointData);

                        memberIds.forEach(memberId => {
                            if (memberId === centerPointId) return;
                            const memberPoint = allPoints.find(p => p.id === memberId);
                            if (memberPoint) {
                                memberPoint.groupId = savedGroup.group_id;
                                pointsInGroup.push(memberPoint);
                            }
                        });

                        newGroup.points = pointsInGroup;
                        allGroups.push(newGroup);

                        groups[`NHÓM ${newGroup.groupNumber}`] = {
                            id: newGroup.id,
                            color: newGroup.color,
                            pointIds: memberIds
                        };
                        loadCount++;
                    });

                    applyFilter();
                    drawAllGroups(); // Đảm bảo tất cả nhóm được vẽ xong
                    updateRankTable();
                    updateFilterOptions();

                    showToast(`✅ Tải và khôi phục ${allGroups.length} nhóm thành công!`, 'success');

                    // ✨ VỊ TRÍ ẨN 2/2 (Hoàn thành thành công) ✨
                    hideLoadingScreen();
                })
                .catch(error => {
                    // Đảm bảo ẩn loading nếu có lỗi ở bất kỳ bước nào
                    hideLoadingScreen();
                    console.error("Lỗi khi tải dữ liệu nhóm:", error);
                    showToast(`Lỗi khi tải dữ liệu nhóm: ${error.message}`, 'error');
                    return Promise.reject(error);
                });
        }
        /**
 * (FIXED LOGGING) Tự động tạo nhóm (vòng tròn bán kính) dựa trên N điểm đề xuất TỐT NHẤT trong Bảng xếp hạng.
 * Đã khôi phục lệnh showToast bị thiếu khi Hub được tạo thành công.
 * @param {number} hubCount - Số lượng Hub tối đa cần tạo nhóm (mặc định là 22).
 */
        function createTopHubGroups(hubCount = 22) {
            if (currentRankings.length === 0) {
                showToast("Không có điểm nào trong Bảng xếp hạng để tạo nhóm.", "error");
                return;
            }

            // 1. Lấy danh sách ID Ứng viên từ Ranking
            const topCandidatesIds = currentRankings.slice(0, hubCount)
                .filter(r => r.type === 'NEW') // Chỉ lấy các đề xuất Hub mới
                .map(r => r.centerId);

            if (topCandidatesIds.length === 0) {
                showToast("Không tìm thấy điểm Hub mới nào để tạo nhóm.", "warning");
                return;
            }

            showToast(`Bắt đầu tạo nhóm cho ${topCandidatesIds.length} Hub từ Top ${hubCount}...`, 'info');

            const autoGroupBtn = document.getElementById('auto-group-btn');
            if (autoGroupBtn) autoGroupBtn.disabled = true;

            let createdCount = 0;

            // 2. Bắt đầu vòng lặp đệ quy trên danh sách ID ứng viên
            const processNextGroup = (index) => {
                if (index >= topCandidatesIds.length) {
                    showToast(`Hoàn tất tạo nhóm. Tổng cộng ${createdCount} Hub đã được tạo.`, 'success');
                    if (autoGroupBtn) autoGroupBtn.disabled = false;
                    return;
                }

                const centerId = topCandidatesIds[index];
                const centerPoint = allPoints.find(p => String(p.id) === centerId);

                // --- 3. LOGIC CHẨN ĐOÁN LỖI (Quan trọng) ---
                if (!centerPoint) {
                    console.error(`[HUB LOG] HUB ID ${centerId} không tìm thấy trong allPoints.`);
                } else if (!centerPoint.isHub) {
                    console.warn(`[HUB LOG] BỎ QUA ${centerId}: isHub = false (Không phải Hub).`);
                } else if (centerPoint.groupId !== null) {
                    console.warn(`[HUB LOG] BỎ QUA ${centerId}: groupId = ${centerPoint.groupId} (Đã được nhóm).`);
                } else {
                    // --- 4. TẠO NHÓM (Chỉ khi HỢP LỆ) ---
                    const currentRadius = RADIUS_METERS;

                    // rawCreateGroup đã được đảm bảo không consume Hubs khác làm vệ tinh
                    const isCreated = rawCreateGroup(centerPoint, currentRadius, currentRadius / 1000);

                    if (isCreated) {
                        createdCount++;
                        // ✨ PHỤC HỒI LỆNH TOAST VÀ LOG TIẾN TRÌNH ✨
                        console.log(`[HUB LOG] ✅ TẠO THÀNH CÔNG: ${centerId} (${createdCount}/${topCandidatesIds.length})`);
                        showToast(`Đang tạo nhóm: ${centerId} (${createdCount}/${topCandidatesIds.length})`, 'info');
                    }
                }

                // Chờ 50ms cho mỗi nhóm
                setTimeout(() => {
                    processNextGroup(index + 1);
                }, 50);
            };

            processNextGroup(0);
        }
        /**
         * Hàm tiện ích tạo nhóm mà không tương tác với Popup/Toast.
         * Đã sửa lỗi chặn HUB trở thành Vệ tinh.
         * @returns {boolean} True nếu nhóm được tạo.
         */
        function rawCreateGroup(centerPoint, radiusMeters, radiusKm) {
            if (centerPoint.groupId !== null) return false;

            // Tìm các điểm CHƯA NHÓM nằm trong bán kính
            const coveredPoints = allPoints.filter(p => {
                if (p.id === centerPoint.id || p.nhnn) return false;
                // Chặn các điểm đã có nhóm (kể cả nhóm cũ)
                if (p.groupId !== null && p.groupId !== 'REFERENCE') return false;

                // ✨ SỬA LỖI TRỌNG YẾU: CHẶN ĐIỂM ĐƯỢC ĐÁNH DẤU LÀ HUB KHÔNG THỂ LÀ VỆ TINH ✨
                if (p.isHub) return false;
                const distance = centerPoint.latlng.distanceTo(p.latlng);
                return distance <= radiusMeters;
            });
            // Nếu không có vệ tinh, không tạo nhóm (tránh nhóm rỗng, nhưng vẫn tạo nếu chỉ có tâm)
            // Nếu bạn muốn tạo nhóm ngay cả khi không có vệ tinh, hãy xóa dòng if này.
            // if (coveredPoints.length === 0) return false; 
            const newGroupNumber = allGroups.length + 1;
            const newGroupColor = GROUP_COLORS[allGroups.length % GROUP_COLORS.length];
            const newGroupId = `G_${newGroupNumber}`;

            const pointsInGroup = [centerPoint, ...coveredPoints];
            const newGroup = {
                id: newGroupId,
                centerPoint: centerPoint,
                points: pointsInGroup,
                color: newGroupColor,
                groupNumber: newGroupNumber,
                routingControls: [],
                polylineCache: {},
                fixedRadiusMeters: radiusMeters,
                fixedRadiusKm: radiusKm
            };
            allGroups.push(newGroup);
            // CẬP NHẬT DỮ LIỆU ĐIỂM
            centerPoint.groupId = newGroupId;
            const coveredIds = new Set(coveredPoints.map(p => p.id));
            allPoints.forEach(p => {
                if (coveredIds.has(p.id)) {
                    p.groupId = newGroupId;
                }
            });
            // ĐỒNG BỘ biến groups (cho UI Popup)
            const pointIdsInGroup = pointsInGroup.map(p => p.id);
            groups[`NHÓM ${newGroupNumber}`] = {
                id: newGroupId,
                color: newGroupColor,
                pointIds: pointIdsInGroup
            };
            // Cập nhật giao diện sau khi tạo xong
            drawAllGroups();
            updateRankTable();
            updateFilterOptions();

            return true;
        }
        function clearOptimizationVisuals() {
            // Gọi hàm clearPreview để xóa vòng tròn preview/tooltip
            clearPreview();
            // Ẩn nút xóa
            document.getElementById('optimize-button').style.display = 'block';
            document.getElementById('clear-optimization-btn').style.display = 'none';
            // ✨ TẮT CHẶN HOVER ✨
            isOptimizationResultVisible = false;
            showToast("Đã xóa vòng tròn đề xuất.", "info");
        }
        async function startOptimization() {
            if (proposedPoints.length === 0) {
                showToast("Vui lòng thêm điểm đề xuất.", "error");
                return;
            }
            showToast("Đang chạy thuật toán tối ưu hóa...", 'info');
            // ✨ 1. RESET TRẠNG THÁI UI VÀ VÒNG TRÒN CŨ ✨
            clearMapVisuals(); // Xóa đường đo A/B
            clearOptimizationVisuals(); // Xóa vòng tròn cũ và ẩn nút xóa
            // Ẩn nút Optimize trong khi tính toán
            document.getElementById('optimize-button').style.display = 'none';
            const results = [];
            // Lọc ra các điểm chưa nhóm hiện tại (sẽ là vệ tinh)
            const ungroupedPoints = allPoints.filter(p => p.groupId === null && p.isVisible && !p.nhnn);
            const nhnnPoints = allPoints.filter(p => p.nhnn && p.isVisible);
            // 2. Lặp qua từng điểm đề xuất làm TÂM
            for (const centerCandidate of proposedPoints) {
                let totalCoverage = 0;
                let totalDistanceToCoverage = 0;
                let totalDistanceToNHNN_Covered = 0;
                let coveredNHNNCount = 0;
                let coveredItems = [];
                // 2a. Tính toán phủ sóng và khoảng cách đến các điểm chưa nhóm (PGD/ATM)
                for (const satellite of ungroupedPoints) {
                    const distance = centerCandidate.latlng.distanceTo(satellite.latlng);
                    if (distance <= RADIUS_METERS) {
                        totalCoverage++;
                        totalDistanceToCoverage += distance;
                        coveredItems.push({ id: satellite.id, type: 'Satellite', distance: distance });
                    }
                }
                // 2b. Tính toán khoảng cách đến NHNN (CHỈ KHI NẰM TRONG BÁN KÍNH)
                for (const nhnn of nhnnPoints) {
                    const distance = centerCandidate.latlng.distanceTo(nhnn.latlng);
                    if (distance <= RADIUS_METERS) {
                        totalCoverage++;
                        totalDistanceToNHNN_Covered += distance;
                        coveredNHNNCount++;
                        coveredItems.push({ id: nhnn.id, type: 'NHNN', distance: distance });
                    }
                }
                // Tính khoảng cách trung bình
                const totalCoveredSatellites = coveredItems.filter(i => i.type === 'Satellite').length;
                const avgDistanceToCoverage = totalCoveredSatellites > 0
                    ? (totalDistanceToCoverage / totalCoveredSatellites)
                    : Infinity; // Chỉ tính TB dựa trên vệ tinh (PGD/ATM)
                const avgDistanceToNHNN = coveredNHNNCount > 0
                    ? (totalDistanceToNHNN_Covered / coveredNHNNCount)
                    : Infinity; // TB dựa trên NHNN được cover
                results.push({
                    centerId: centerCandidate.id,
                    totalCoverage: totalCoverage,
                    avgDistanceToCoverage: avgDistanceToCoverage,
                    avgDistanceToNHNN: avgDistanceToNHNN,
                    coveredItems: coveredItems,
                    centerPoint: centerCandidate // Lưu tham chiếu điểm tâm
                });
            }
            // 3. Xếp hạng (Ưu tiên Phủ sóng > Khoảng cách TB Phủ sóng > Khoảng cách TB NHNN)
            results.sort((a, b) => {
                if (b.totalCoverage !== a.totalCoverage) return b.totalCoverage - a.totalCoverage;
                if (a.avgDistanceToCoverage !== b.avgDistanceToCoverage) return a.avgDistanceToCoverage - b.avgDistanceToCoverage;
                return a.avgDistanceToNHNN - b.avgDistanceToNHNN;
            });
            renderOptimizationResult(results);
            // Sau khi tính toán, hiện lại nút Optimize
            document.getElementById('optimize-button').style.display = 'block';
        }
        function renderOptimizationResult(results) {
            if (results.length === 0) {
                showToast("Không tìm thấy kết quả tối ưu nào.", "warning");
                return;
            }
            const bestResult = results[0];
            const centerPoint = allPoints.find(p => p.id === bestResult.centerId);
            // 5. Hiển thị kết quả tối ưu nhất (Vẽ vòng tròn và Highlight)
            showToast(`Đã tìm thấy điểm tối ưu nhất: ${bestResult.centerId}`, 'success');
            // Ẩn nút Optimize và hiện nút Clear
            document.getElementById('optimize-button').style.display = 'none';
            document.getElementById('clear-optimization-btn').style.display = 'block';
            // Tạo đối tượng Preview tạm thời để gọi showPreview
            const previewItem = {
                type: 'NEW',
                centerPoint: centerPoint,
                // Dùng map/filter để đảm bảo chỉ các điểm hợp lệ được đưa vào coveredPoints
                coveredPoints: bestResult.coveredItems.map(item => allPoints.find(p => p.id === item.id)).filter(p => p),
                color: '#911EB4', // Tím đậm cho kết quả tối ưu
                tooltipContent: `
            <div style="font-size: 13px; padding: 5px; min-width: 200px; line-height: 1.5;">
                <strong style="display: block;">Tâm Tối Ưu: ${centerPoint.id}</strong>
                <hr style="margin: 4px 0;">
                <div>Phủ sóng: <b>${bestResult.totalCoverage}</b> điểm</div>
                <div>TB khoảng cách (vệ tinh): <b>${(bestResult.avgDistanceToCoverage / 1000).toFixed(2)} km</b></div>
                <div>TB khoảng cách (NHNN): <b>${(bestResult.avgDistanceToNHNN / 1000).toFixed(2)} km</b></div>
                <hr style="margin: 4px 0;">
                <div>Xếp hạng: <b>#1 / ${results.length}</b></div>
            </div>
        `
            };
            showPreview(previewItem, null);
            // Zoom đến kết quả tối ưu
            if (centerPoint && centerPoint.latlng) {
                // Chỉ panTo để không thay đổi mức zoom đột ngột
                map.panTo(centerPoint.latlng);
            }
            // ✨ BẬT CHẶN HOVER ✨
            isOptimizationResultVisible = true;
        }
        /**
 * (CẬP NHẬT: THÊM NÚT XÓA VÀO ITEM LIST) Cập nhật danh sách điểm đề xuất trong Sidebar.
 */
        function renderProposalList() {
            // ⚠️ Giả sử container DIV chứa danh sách đề xuất có ID là 'proposal-list' (theo HTML của bạn)
            const listDiv = document.getElementById('proposal-list');
            const optimizeBtn = document.getElementById('optimize-button');
            const radiusDisplay = document.getElementById('optimize-radius-display');

            if (!listDiv || !optimizeBtn) return;
            listDiv.innerHTML = '';

            // Cập nhật hiển thị bán kính tối ưu
            if (radiusDisplay) radiusDisplay.textContent = currentRadiusKm;
            if (proposedPoints.length === 0) {
                listDiv.innerHTML = '<span class="text-gray-500 italic text-sm">Chưa có điểm đề xuất.</span>';
                optimizeBtn.disabled = true;
                return;
            }

            proposedPoints.forEach(point => {
                const item = document.createElement('div');
                item.className = 'flex justify-between items-center bg-gray-100 p-2 rounded';
                item.innerHTML = `
            <span class="text-sm font-medium">${point.id} (${point.tenHub || 'PGD'})</span>
            <button class="text-red-500 hover:text-red-700 text-xs font-bold" onclick="removeProposal('${point.id}')">
                <i class="fa-solid fa-times"></i>
            </button>
        `;
                listDiv.appendChild(item);
            });
            // Kích hoạt nút Tối Ưu Hóa nếu có ít nhất 1 điểm
            optimizeBtn.disabled = (proposedPoints.length < 1);
        }
        function addProposal(pointId) {
            if (proposedPoints.length >= 5) {
                showToast("Chỉ được đề xuất tối đa 5 điểm.", "error");
                return;
            }
            const point = allPoints.find(p => p.id === pointId);
            if (!point) return;
            if (proposedPoints.some(p => p.id === pointId)) {
                showToast(`Điểm ${pointId} đã có trong danh sách.`, "warning");
                return;
            }
            // Clone dữ liệu để tránh lỗi tham chiếu
            proposedPoints.push({ ...point });
            renderProposalList();
            showToast(`Đã thêm ${pointId} vào danh sách đề xuất.`, "info");
        }
        function removeProposal(pointId) {
            proposedPoints = proposedPoints.filter(p => p.id !== pointId);
            renderProposalList();
            showToast(`Đã xóa ${pointId} khỏi danh sách đề xuất.`, "warning");
        }
        // Biến toàn cục (Cần đảm bảo đã được khai báo ngoài các hàm):
        // let currentRadiusKm = 30; 
        // let RADIUS_METERS = 30000; 
        function setupRadiusControl() {
            const slider = document.getElementById('radius-slider');
            const valueDisplay = document.getElementById('radius-value');
            // Khởi tạo giá trị mặc định của thanh trượt
            slider.value = currentRadiusKm;
            valueDisplay.textContent = currentRadiusKm;
            slider.addEventListener('input', function () {
                const newRadiusKm = parseInt(this.value);
                // 1. Cập nhật biến toàn cục (chỉ ảnh hưởng đến Preview)
                currentRadiusKm = newRadiusKm;
                RADIUS_METERS = newRadiusKm * 1000; // Cập nhật RADIUS_METERS
                // 2. Cập nhật hiển thị km
                valueDisplay.textContent = newRadiusKm;
                // 3. (QUAN TRỌNG) Kích hoạt lại việc vẽ
                // Điều này sẽ vẽ lại các nhóm ĐÃ LƯU với bán kính CỐ ĐỊNH, 
                // nhưng sẽ vẽ lại các vòng tròn Preview/Analysis với bán kính MỚI.
                drawAllGroups();
                // Xóa preview cũ (nếu có)
                clearPreview();
            });
        }
        // Gọi hàm setup khi DOM đã tải xong
        document.addEventListener('DOMContentLoaded', function () {
            // ... các lệnh khởi tạo khác
            setupRadiusControl(); // ✨ THÊM LỆNH NÀY ✨
        });
        /**
         * [FINAL FIX LỖI NÚT] Hàm bật/tắt hiển thị Term ID Label (CHỈ XỬ LÝ TOOLTIP/NÚT UI).
         * BẮT BUỘC gọi applyFilter() để đồng bộ hóa.
         */
        function toggleTermIDLabels() {
            // ✨ BẬT LOADING ✨
    showLoadingScreen('https://lottie.host/e0b12a8f-22a4-4a8f-8898-15b5e39d0901/label_toggle.lottie', 'Đang thay đổi hiển thị TermID...');
            const button = document.getElementById('termid-toggle-btn');
            if (!button) return;

            showTermIDLabels = !showTermIDLabels;

            // 1. Cập nhật giao diện nút
            if (showTermIDLabels) {
                button.style.cssText = 'background-color: #3b82f6 !important; color: white !important;';
                button.innerHTML = '<i class="fa-solid fa-tag w-4 h-4"></i> <span class="button-text">TermID (Bật)</span>';
                showToast("Đã BẬT: Hiển thị Term ID", 'info');
            } else {
                button.innerHTML = '<i class="fa-solid fa-tag-slash w-4 h-4"></i> <span class="button-text">TermID (Tắt)</span>';
                button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';
                showToast("Đã TẮT: Ẩn Term ID", 'warning');
            }

            // 2. ✨ GỌI APPLY FILTER để buộc tất cả Tooltip được mở/đóng theo trạng thái nút mới ✨
            applyFilter();
            // ✨ ẨN LOADING SAU KHI VẼ XONG ✨
    setTimeout(() => { 
        hideLoadingScreen(); 
    }, 300);
        }
        /**
        
         * Hàm bật/tắt khối Tìm kiếm/Đo lường.
        
         */
        function toggleSearchPanel() {
            const panel = document.getElementById('search-control-container');
            const button = document.getElementById('search-panel-toggle-btn');
            if (!panel || !button) return;
            // Lấy panel/nút của Rank và Filter (để tắt chúng nếu cần)
            const rankPanel = document.getElementById('rank-table-container');
            const rankButton = document.getElementById('rank-toggle-btn');
            const filterPanel = document.getElementById('filter-controls-container');
            const filterButton = document.getElementById('filter-toggle-btn');
            isSearchPanelOpen = !isSearchPanelOpen;
            if (isSearchPanelOpen) {
                // BẬT PANEL
                panel.classList.add('search-panel-active');
                button.style.cssText = 'background-color: #3b82f6 !important; color: white !important;';
                button.innerHTML = '<i class="fa-solid fa-crosshairs w-4 h-4"></i> <span class="button-text">Tìm/Đo (Bật)</span>';
                showToast("Đã BẬT: Panel Tìm kiếm/Đo lường", 'info');
                // Tắt panel Rank và Filter nếu chúng đang mở
                if (rankPanel && rankPanel.style.display === 'block') {
                    rankPanel.style.display = 'none';
                    if (rankButton) rankButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';
                }
                if (filterPanel && filterPanel.style.display === 'block') {
                    filterPanel.style.display = 'none';
                    if (filterButton) filterButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';
                }
            } else {
                // TẮT PANEL
                panel.classList.remove('search-panel-active');
                button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';
                button.innerHTML = '<i class="fa-solid fa-crosshairs w-4 h-4"></i> <span class="button-text">Tìm/Đo (Tắt)</span>';
                showToast("Đã TẮT: Panel Tìm kiếm/Đo lường", 'warning');
            }
        }
        // (*** MỚI: HÀM CẬP NHẬT LOG KẾT QUẢ ĐO LƯỜNG CỐ ĐỊNH ***)
        function updateMeasurementLog(message, type) {
            const logDiv = document.getElementById('measurement-log');
            if (!logDiv) return;
            // Định dạng màu sắc và icon
            let color = '#333';
            let icon = '';
            if (type === 'route') {
                color = '#d97706'; // Cam (Lái xe)
                icon = '<i class="fa-solid fa-car mr-1"></i>';
            } else if (type === 'straight') {
                color = '#1d4ed8'; // Xanh dương (Chim bay)
                icon = '<i class="fa-solid fa-feather-alt mr-1"></i>';
            } else {
                logDiv.style.display = 'none'; // Ẩn nếu không có dữ liệu
                return;
            }
            logDiv.style.display = 'block';
            logDiv.style.color = color;
            logDiv.innerHTML = `${icon} ${message}`;
        }
        // (*** HÀM CHỈ XÓA GIAO DIỆN CŨ ***)
        // Cần định nghĩa lại hàm này nếu bạn chưa có, hoặc đảm bảo nó nằm ngoài clearMeasurement()
        /**
        
         * Hàm chỉ xóa các đường vẽ và marker trên map (GIỮ LẠI DỮ LIỆU selectedPointA/B).
        
         */
        function clearMapVisuals() {
            // 1. Xóa routing machine nếu có
            if (currentRoutingControl) {
                try {
                    map.removeControl(currentRoutingControl);
                } catch (e) { }
                currentRoutingControl = null;
            }
            // 2. Xóa đường chim bay nếu có
            if (currentStraightLine) {
                measureLayer.removeLayer(currentStraightLine);
                currentStraightLine = null;
            }
            // 3. Xóa các marker tự tạo bởi routing machine (nếu có)
            measureLayer.clearLayers();
        }
        // (Trong function clearMeasurement)
        function clearMeasurement() {
            // ✨ LOGIC MỚI: XÓA HIỆU ỨNG NHẤP NHÁY TRÊN MARKER HIỆN TẠI ✨
            allPoints.forEach(p => {
                const markerElement = p.marker?.getElement();
                if (markerElement) {
                    markerElement.classList.remove('pulsing-marker-A', 'pulsing-marker-B');
                }
            });
            // 1. Xóa giao diện khỏi Map
            clearMapVisuals();
            // 2. Xóa dữ liệu điểm và input
            document.getElementById('search-a-input').value = '';
            document.getElementById('search-b-input').value = '';
            document.getElementById('search-a-results').style.display = 'none';
            document.getElementById('search-b-results').style.display = 'none';
            // Xóa tham chiếu điểm A và B
            selectedPointA = null;
            selectedPointB = null;
            // 3. Xóa log cố định
            updateMeasurementLog('', 'clear');
            showToast("Đã xóa tất cả các đường đo.", "info");
        }
        // (*** HÀM ĐO ĐƯỜNG CHIM BAY - ĐÃ SỬA LỖI midPoint ***)
        function measureStraightLineBetweenAandB(isFallback = false) {
            // [ĐÃ SỬA] Chỉ xóa giao diện cũ (nhưng giữ lại selectedPointA/B)
            clearMapVisuals();
            if (!selectedPointA || !selectedPointB) {
                showToast("Vui lòng chọn cả Điểm Bắt đầu (A) và Điểm Kết thúc (B).", "warning");
                return;
            }
            if (selectedPointA.id === selectedPointB.id) {
                showToast("Hai điểm A và B phải khác nhau.", "warning");
                return;
            }
            if (isBatteryView) {
                toggleBatteryView();
            }
            // 1. Vẽ đường chim bay
            currentStraightLine = L.polyline([selectedPointA.latlng, selectedPointB.latlng], {
                color: '#1a73e8', // Màu xanh dương
                weight: 5,
                opacity: 0.7,
                dashArray: '10, 5' // Đường nét đứt
            }).addTo(measureLayer);
            // 2. Tính khoảng cách
            const distanceMeters = selectedPointA.latlng.distanceTo(selectedPointB.latlng);
            const distanceKm = (distanceMeters / 1000).toFixed(2);
            showToast(`${isFallback ? 'Đường chim bay (Lỗi Routing):' : 'Đo Đường Chim Bay:'} ${distanceKm} km.`, isFallback ? 'warning' : 'success');
            // 3. Focus vào điểm A và B
            // (*** SỬA LỖI midPoint ***)
            const midLat = (selectedPointA.latlng.lat + selectedPointB.latlng.lat) / 2;
            const midLng = (selectedPointA.latlng.lng + selectedPointB.latlng.lng) / 2;
            const centerLatLng = L.latLng(midLat, midLng);
            map.panTo(centerLatLng);
            // (*** KẾT THÚC SỬA LỖI ***)
            // Cập nhật log
            updateMeasurementLog(`Kết quả Đường Chim Bay: ${distanceKm} km`, 'straight');
        }
        // (*** HÀM TÌM KIẾM CHO SEARCH A/B ***)
        function searchMeasurePoint(searchId) {
            const inputId = `search-${searchId.toLowerCase()}-input`;
            const resultsId = `search-${searchId.toLowerCase()}-results`;
            const input = document.getElementById(inputId);
            const resultsContainer = document.getElementById(resultsId);
            const searchTerm = String(input.value).trim().toUpperCase();
            resultsContainer.innerHTML = '';
            if (!searchTerm) {
                resultsContainer.style.display = 'none';
                return;
            }
            const searchResults = allPoints.filter(p =>
                !p.nhnn && (
                    String(p.id).toUpperCase().includes(searchTerm) ||
                    (p.tenHub && String(p.tenHub).toUpperCase().includes(searchTerm))
                )
            );
            if (searchResults.length > 0) {
                resultsContainer.style.display = 'block';
                searchResults.slice(0, 5).forEach(point => {
                    const item = document.createElement('div');
                    item.className = 'search-result-item';
                    let content = `ID: ${point.id}`;
                    if (point.tenHub) {
                        content += `<span class="hub-name"> (${point.tenHub})</span>`;
                    }
                    item.innerHTML = content;
                    item.dataset.pointId = point.id;
                    item.addEventListener('click', () => {
                        selectMeasurePoint(searchId, point);
                        resultsContainer.style.display = 'none';
                    });
                    resultsContainer.appendChild(item);
                });
            } else {
                resultsContainer.style.display = 'none';
            }
        }
        /**
 * (SỬA LỚN) Chọn/Bỏ chọn một điểm làm A hoặc B.
 * Tự động mở Panel Tìm kiếm/Đo lường và điền dữ liệu vào input tương ứng.
 */
        function selectMeasurePoint(type, pointData) {

            // 1. Cập nhật điểm đã chọn (selectedPointA/B)
            if (type === 'A') {
                selectedPointA = (selectedPointA?.id === pointData?.id) ? null : pointData;
            } else if (type === 'B') {
                selectedPointB = (selectedPointB?.id === pointData?.id) ? null : pointData;
            }

            // 2. Quét TẤT CẢ các Marker và áp dụng/xóa hiệu ứng nhấp nháy (Giữ nguyên logic cũ)
            allPoints.forEach(p => {
                const markerElement = p.marker?.getElement();
                if (!markerElement) return;
                markerElement.classList.remove('pulsing-marker-A', 'pulsing-marker-B');
                if (selectedPointA && p.id === selectedPointA.id) {
                    markerElement.classList.add('pulsing-marker-A');
                }
                if (selectedPointB && p.id === selectedPointB.id) {
                    markerElement.classList.add('pulsing-marker-B');
                }
            });
            // 3. Tự động đóng popup
            if (currentPopup) {
                map.closePopup(currentPopup);
                currentPopup = null;
            }

            // ✨ 4. MỞ PANEL TÌM KIẾM/ĐO LƯỜNG VÀ ĐIỀN DỮ LIỆU ✨
            const panel = document.getElementById('search-control-container');
            const inputA = document.getElementById('search-a-input');
            const inputB = document.getElementById('search-b-input');
            // Mở panel nếu nó đang đóng
            if (!panel.classList.contains('search-panel-active')) {
                toggleSearchPanel();
            }
            // Điền giá trị vào input
            if (type === 'A') {
                inputA.value = selectedPointA ? `${selectedPointA.id} (${selectedPointA.tenHub || 'PGD'})` : '';
            } else if (type === 'B') {
                inputB.value = selectedPointB ? `${selectedPointB.id} (${selectedPointB.tenHub || 'PGD'})` : '';
            }

            // 5. Cập nhật nhãn trạng thái A/B trên map (nếu hàm đó tồn tại)
            if (typeof updateStatusLabels === 'function') {
                updateStatusLabels();
            }

            showToast(`Đã chọn Điểm ${type}: ${pointData ? pointData.id : 'Bỏ chọn'}`, 'info');
        }
        // (*** HÀM CHÍNH ĐO KÍCH THƯỚC LÁI XE - CÓ LOG CỐ ĐỊNH ***)
        function measureRouteBetweenAandB() {
            // [ĐÃ SỬA] Chỉ xóa giao diện cũ (nhưng giữ lại selectedPointA/B)
            clearMapVisuals();
            if (!selectedPointA || !selectedPointB) {
                showToast("Vui lòng chọn cả Điểm Bắt đầu (A) và Điểm Kết thúc (B).", "warning");
                return;
            }
            if (selectedPointA.id === selectedPointB.id) {
                showToast("Hai điểm A và B phải khác nhau.", "warning");
                return;
            }
            // 2. Tắt chế độ Pin (nếu đang bật)
            if (isBatteryView) {
                toggleBatteryView();
            }
            showToast("Đang tính toán tuyến đường lái xe...", 'info');
            updateMeasurementLog("Đang tính toán tuyến đường...", 'route'); // Cập nhật log tạm thời
            // 3. Khởi tạo Leaflet Routing Machine
            const router = L.Routing.control({
                waypoints: [
                    selectedPointA.latlng,
                    selectedPointB.latlng
                ],
                router: L.Routing.osrmv1({
                    serviceUrl: 'https://router.project-osrm.org/route/v1',
                    profile: 'driving'
                }),
                show: false, // ✨ THUỘC TÍNH QUAN TRỌNG: Đặt thành false để ẩn bảng chỉ dẫn
                routeWhileDragging: false,
                createMarker: (i, waypoint, n) => {
                    const pointData = (i === 0) ? selectedPointA : selectedPointB;
                    const icon = isBatteryView ? createBatteryIcon(pointData) : createPGDIcon();
                    return L.marker(waypoint.latLng, {
                        icon: icon,
                        title: (i === 0) ? `Start: ${pointData.id}` : `End: ${pointData.id}`
                    });
                },
                lineOptions: {
                    styles: [{ color: '#f59e0b', weight: 7, opacity: 0.8 }]
                }
            });
            // 4. Bắt sự kiện tuyến đường tìm thấy
            router.on('routesfound', function (e) {
                const route = e.routes[0];
                const distanceKm = (route.summary.totalDistance / 1000).toFixed(2);
                showToast(`Đo kích thước thành công! ${distanceKm} km (Lái xe)`, 'success');
                // (*** LƯU KẾT QUẢ VÀO LOG CỐ ĐỊNH ***)
                updateMeasurementLog(`Kết quả Đo Lái Xe: ${distanceKm} km`, 'route');
                // DÒNG router.getContainer().style.display = 'block'; ĐÃ BỊ XÓA BỎ
            });
            router.on('routingerror', function (e) {
                console.error("Lỗi định tuyến:", e.error);
                showToast(`Lỗi tính toán đường lái xe. Đã vẽ đường chim bay thay thế.`, "error");
                // (*** LƯU KẾT QUẢ VÀO LOG CỐ ĐỊNH ***)
                updateMeasurementLog(`Lỗi Đo Lái Xe. Xem kết quả Đường Chim Bay thay thế.`, 'route');
                // Vẽ đường chim bay để thay thế
                L.polyline([selectedPointA.latlng, selectedPointB.latlng], {
                    color: '#f59e0b',
                    opacity: 0.5,
                    weight: 3,
                    dashArray: '5, 5'
                }).addTo(measureLayer);
            });
            currentRoutingControl = router.addTo(map);
            // Đảm bảo container ẩn (chỉ chứa đường đi, không chứa bảng chi tiết)
            const container = router.getContainer();
            if (container) {
                container.style.display = 'none'; // Đặt thành none để ẩn toàn bộ control (chỉ để lại đường đi)
                container.style.position = 'absolute';
                container.style.top = '10px';
                container.style.left = '10px';
                container.style.zIndex = '2000';
            }
        }
        // Hàm giả định để lấy ID duy nhất cho điểm (nếu bạn chưa có)
        function getUniquePointId(lat, lon) {
            // Có thể dùng hash hoặc kết hợp Lat/Lon thành chuỗi
            return `P_${Math.round(lat * 10000)}_${Math.round(lon * 10000)}`;
        }
        // Hàm giả định để cập nhật hiển thị Marker sau khi nhóm thay đổi
        function updateMarkerIcon(marker, groupColor) {
            // TODO: Triển khai logic thay đổi icon Marker (ví dụ: đổi màu icon pin)
            // Hiện tại: Giả định bạn có hàm renderMarkerIcon(level, amount, color)
            // Ví dụ: marker.setIcon(createBatteryIcon(100, 100000, groupColor));
            // Đơn giản nhất: Thay đổi màu viền icon nếu bạn dùng L.DivIcon
            const element = marker.getElement();
            if (element) {
                const container = element.querySelector('.battery-icon-container');
                if (container) {
                    container.style.borderColor = groupColor;
                }
            }
        }
        /**
        
         * Đặt trung tâm bản đồ và zoom đến vị trí của một Marker.
        
         */
        function setMapCenterFromMarker(pointId) {
            const point = allPoints.find(p => String(p.id) === String(pointId));
            if (!point || !point.latlng) {
                showToast(`Lỗi: Không tìm thấy điểm ID ${pointId} hoặc không có tọa độ.`, "error");
                console.error("Lỗi setMapCenterFromMarker: Không tìm thấy đối tượng điểm trong allPoints hoặc không có latlng.");
                return;
            }
            // [ĐÃ SỬA] Thay thế map.flyTo(..., 15) bằng map.panTo() để giữ nguyên zoom
            map.panTo(point.latlng);
            // (Tùy chọn) Kích hoạt click để mở popup nếu bạn muốn
            if (point.marker) {
                if (currentPopup) {
                    map.closePopup(currentPopup);
                    currentPopup = null;
                }
                point.marker.fire('click');
            }
            showToast(`Đã chuyển đến Tâm Điểm: ${pointId}`, 'info');
        }
        /**
         * (FINAL FIX: THÊM TRẠNG THÁI ĐÃ THÊM CHO NÚT ĐỀ XUẤT)
         */
        function createActionPopupContent(pointId, currentGroupId, pointName) {

            // --- Lấy thông tin và Trạng thái ---
            let isCenterPoint = false;
            const currentGroup = allGroups.find(g => String(g.id) === String(currentGroupId));
            if (currentGroup && String(currentGroup.centerPoint.id) === String(pointId)) {
                isCenterPoint = true;
            }

            const isPointA = selectedPointA && selectedPointA.id === pointId;
            const isPointB = selectedPointB && selectedPointB.id === pointId;
            const selectedAData = selectedPointA;
            const selectedBData = selectedPointB;

            // ✨ KIỂM TRA TRẠNG THÁI ĐÃ CÓ TRONG DANH SÁCH ĐỀ XUẤT ✨
            const isProposed = proposedPoints.some(p => p.id === pointId);
            let content = `
        <div class="action-popup-header">${pointName || pointId}</div>
        <div class="action-popup-buttons" style="max-height: 350px;">
            
            <div class="button-group" style="margin-top: 0; gap: 8px;">
                <button class="btn-new" onclick="popup_createGroup('${pointId}')" style="flex-grow: 1; width: 100%; color: white;">
                    <i class="fa-solid fa-plus-circle"></i> Tạo HUB Mới
                </button>
            </div>
            ${isProposed ? `
                <button class="btn-measure" onclick="removeProposalFromPopup('${pointId}')" style="flex-grow: 1; width: 100%; background-color: #10b981; color: white; margin-top: 6px;">
                    <i class="fa-solid fa-check"></i> Đã Thêm (Click để xóa)
                </button>`
                    : `
                <button class="btn-add" onclick="addProposalFromPopup('${pointId}')" style="flex-grow: 1; width: 100%; background-color: #38a169; color: white; margin-top: 6px;">
                    <i class="fa-solid fa-star"></i> Thêm vào Đề xuất
                </button>`}
            
            
            ${isCenterPoint ? `
                <button class="btn-move" style="background-color: #dc2626; margin-top: 8px; color: white; width: 100%;" onclick="popup_deleteGroup('${currentGroupId}')">
                    <i class="fa-solid fa-trash-alt"></i> Hủy Nhóm ${currentGroup.groupNumber}
                </button>
            ` : ''}
            <div class="action-popup-header" style="margin-top: 8px;">Đo Lường A/B</div>
            <div class="button-group measure-group" style="margin-top: 0; gap: 8px; grid-template-columns: 1fr 1fr; display: grid;">
                
                ${isPointA ? `
                    <button class="btn-measure btn-a selected-blinking" onclick="selectMeasurePoint('A', null)" style="background: #007bff; color: white; border: 2px solid white;">
                        <span style="font-size: 10px; line-height: 1.2;">Bỏ chọn A:</span> ${pointId}
                    </button>`
                    : (selectedAData ? `
                    <button class="btn-measure btn-a disabled" disabled style="background: #007bff; color: white; opacity: 0.8;">
                        <span style="font-size: 10px; line-height: 1.2;">A Đã Khóa:</span> ${selectedAData.id}
                    </button>`
                        : `
                    <button class="btn-measure btn-a" onclick="selectMeasurePoint('A', allPoints.find(p => p.id === '${pointId}'))" style="background: #007bff; color: white;">
                        <i class="fa-solid fa-location-dot"></i> Điểm A
                    </button>`)}
                
                ${isPointB ? `
                    <button class="btn-measure btn-b selected-blinking" onclick="selectMeasurePoint('B', null)" style="background: #dc3545; color: white; border: 2px solid white;">
                        <span style="font-size: 10px; line-height: 1.2;">Bỏ chọn B:</span> ${pointId}
                    </button>`
                    : (selectedBData ? `
                    <button class="btn-measure btn-b disabled" disabled style="background: #dc3545; color: white; opacity: 0.8;">
                        <span style="font-size: 10px; line-height: 1.2;">B Đã Khóa:</span> ${selectedBData.id}
                    </button>`
                        : `
                    <button class="btn-measure btn-b" onclick="selectMeasurePoint('B', allPoints.find(p => p.id === '${pointId}'))" style="background: #dc3545; color: white;">
                        <i class="fa-solid fa-location-dot"></i> Điểm B
                    </button>`)}
            </div>
            <div class="button-group measure-action-group" style="margin-top: 8px; gap: 8px; grid-template-columns: 1fr 1fr 1fr; display: grid;">
                <button class="btn-measure-action" onclick="measureRouteBetweenAandB()" title="Đo khoảng cách lái xe">
                    <i class="fa-solid fa-car"></i>
                </button>
                <button class="btn-measure-action" onclick="measureStraightLineBetweenAandB()" title="Đo đường chim bay">
                    <i class="fa-solid fa-feather-alt"></i>
                </button>
                <button class="btn-measure-action" onclick="clearMeasurement()" title="Xóa điểm đo">
                    <i class="fa-solid fa-trash-alt"></i>
                </button>
            </div>
            
            <hr style="margin: 8px 0; border-top: 1px solid #ddd;">
            <div class="action-popup-header">Chuyển Nhóm</div>
            <div class="button-group" style="margin-top: 0; gap: 4px; grid-template-columns: 1fr 1fr; display: grid;">
    `;

            // Logic Chuyển Nhóm (Giữ nguyên)
            const availableGroups = Object.keys(groups).filter(
                groupName => groups[groupName].id !== currentGroupId
            );

            const getTextColor = (bgColor) => {
                const color = (bgColor.charAt(0) === '#') ? bgColor.substring(1, 7) : bgColor;
                const r = parseInt(color.substring(0, 2), 16);
                const g = parseInt(color.substring(2, 4), 16);
                const b = parseInt(color.substring(4, 6), 16);
                const uicolors = [r / 255, g / 255, b / 255];
                const c = uicolors.map((col) => {
                    if (col <= 0.03928) { return col / 12.92; }
                    return Math.pow((col + 0.055) / 1.055, 2.4);
                });
                const luminance = (0.2126 * c[0]) + (0.7152 * c[1]) + (0.0722 * c[2]);
                return (luminance > 0.179) ? '#000000' : '#FFFFFF';
            };
            if (availableGroups.length > 0) {
                availableGroups.forEach(groupName => {
                    const groupId = groups[groupName].id;
                    const groupColor = groups[groupName].color;
                    const groupNumber = groupName.split(' ')[1];

                    const textColor = getTextColor(groupColor);
                    content += `
                <button 
                    class="btn-move" 
                    style="background-color: ${groupColor}; padding: 6px 4px; font-size: 12px; height: 40px; color: ${textColor};"
                    onclick="movePointToGroup('${pointId}', '${groupId}')"
                >
                    <i class="fas fa-layer-group"></i> HUB ${groupNumber}
                </button>
            `;
                });
            } else {
                content += `<div style="grid-column: span 2; text-align: center; color: #555;" class="action-popup-info">Chưa có nhóm nào khác để chuyển đến.</div>`;
            }
            content += `</div>`;
            return content;
        }
        /**
         * Thêm điểm hiện tại (từ Popup) vào danh sách đề xuất để tối ưu hóa.
         * Tự động mở Panel Tìm kiếm/Đo lường VÀ đóng Popup Hành động.
         * @param {string} pointId - ID của điểm cần thêm.
         */
        function addProposalFromPopup(pointId) {
            if (proposedPoints.length >= 5) {
                showToast("Chỉ được đề xuất tối đa 5 điểm.", "error");
                return;
            }

            const point = allPoints.find(p => p.id === pointId);
            if (!point) return;
            if (proposedPoints.some(p => p.id === pointId)) {
                showToast(`Điểm ${pointId} đã có trong danh sách.`, "warning");
                return;
            }
            // Thêm điểm
            proposedPoints.push({ ...point });
            renderProposalList();
            // 1. Mở Panel Tìm kiếm/Đo lường (nếu đang đóng)
            const panel = document.getElementById('search-control-container');
            if (!panel.classList.contains('search-panel-active')) {
                toggleSearchPanel();
            }

            // 2. Đóng Popup Hành động
            if (currentPopup) {
                map.closePopup(currentPopup);
                currentPopup = null;
            }
            showToast(`Đã thêm ${pointId} vào danh sách đề xuất.`, "info");
        }
        /**
         * Xóa điểm khỏi danh sách đề xuất và đảm bảo đồng bộ hóa UI (Sidebar & Popup).
         * Hàm này được gọi khi click nút X trên Sidebar HOẶC nút "Đã Thêm (Click để xóa)" trong Popup.
         * @param {string} pointId - ID của điểm cần xóa.
         */
        function removeProposal(pointId) {
            // 1. Xóa khỏi mảng proposedPoints
            const initialLength = proposedPoints.length;
            proposedPoints = proposedPoints.filter(p => p.id !== pointId);
            if (proposedPoints.length === initialLength) {
                showToast(`Không tìm thấy điểm ${pointId} trong danh sách đề xuất.`, "error");
                return;
            }

            // 2. Cập nhật danh sách bên Sidebar
            if (typeof renderProposalList === 'function') {
                renderProposalList();
            }

            // 3. Đồng bộ hóa trạng thái Popup/Ghim Bản đồ (Đóng Popup nếu nó đang hiển thị điểm bị xóa)
            if (currentPopup && currentPopup.getContent() && currentPopup.getContent().includes(pointId)) {
                map.closePopup(currentPopup);
                currentPopup = null;
            }

            showToast(`Đã xóa ${pointId} khỏi danh sách đề xuất.`, "warning");
        }
        /**
        
         * (SỬA LỖI CHÍNH) Hàm chuyển một điểm từ nhóm cũ sang nhóm mới (gọi từ Popup).
        
         * Đã: 1. Đóng Popup sau khi chuyển (Fix Lỗi 3). 2. Đảm bảo loại trừ lẫn nhau (Fix Lỗi 2).
        
         */
        function movePointToGroup(pointId, targetGroupId) {
            // 1. Tìm thông tin nhóm mới
            const newGroupNameKey = Object.keys(groups).find(key => groups[key].id === targetGroupId);
            const newGroup = allGroups.find(g => String(g.id) === String(targetGroupId));
            // Tìm điểm cần chuyển
            const pointToMove = allPoints.find(p => String(p.id) === String(pointId));
            if (!pointToMove || !newGroup || !newGroupNameKey) {
                showToast("Lỗi: Không tìm thấy điểm hoặc nhóm đích.", "error");
                return;
            }
            const oldGroupId = pointToMove.groupId;
            if (oldGroupId === targetGroupId) {
                showToast(`Điểm ${pointId} đã ở trong ${newGroupNameKey}.`, "warning");
                if (currentPopup) map.closePopup(); // Fix Lỗi 3: Đóng popup
                return;
            }
            // === 2. XÓA ĐIỂM KHỎI NHÓM CŨ (MUTUAL EXCLUSION) ===
            if (oldGroupId) {
                const oldGroup = allGroups.find(g => String(g.id) === String(oldGroupId));
                if (oldGroup) {
                    // Xóa khỏi danh sách points trong allGroups (dữ liệu map)
                    oldGroup.points = oldGroup.points.filter(p => p.id !== pointToMove.id);
                }
                // Đồng bộ biến 'groups' (cho UI Popup) - XÓA KHỎI DANH SÁCH ID
                const oldGroupNameKey = Object.keys(groups).find(key => groups[key].id === oldGroupId);
                if (groups[oldGroupNameKey]) {
                    groups[oldGroupNameKey].pointIds = groups[oldGroupNameKey].pointIds.filter(id => id !== pointToMove.id);
                }
            }
            // =========================================================
            // 3. Cập nhật ID nhóm mới cho điểm và thêm vào nhóm mới
            pointToMove.groupId = targetGroupId;
            newGroup.points.push(pointToMove);
            // 4. Đồng bộ biến 'groups' (cho UI Popup) - THÊM VÀO DANH SÁCH ID
            if (!groups[newGroupNameKey].pointIds.includes(pointToMove.id)) {
                groups[newGroupNameKey].pointIds.push(pointToMove.id);
            }
            // 5. Cập nhật hiển thị và ĐÓNG POPUP (Fix Lỗi 3)
            if (currentPopup) map.closePopup();
            drawAllGroups();
            updateRankTable();
            updateFilterOptions();
            Toastify({
                text: `Đã chuyển điểm ${pointId} sang ${newGroupNameKey}`,
                className: "custom-toast success",
            }).showToast();
        }
        /**
        
         * (MỚI) Tìm và trả về đối tượng Leaflet Marker từ ID điểm
        
         */
        function getMarkerByPointId(pointId) {
            // Trả về Marker từ bản đồ lưu trữ
            return allMarkers[pointId];
        }
        /**
        
         * Hàm Khởi tạo và Thêm Marker vào Map
        
         */
        function createAndAddMarker(lat, lon, data) {
            // 1. Tạo Marker (Marker KHÔNG CÓ Popup TĨNH lúc này)
            const pointId = data.pointId || getUniquePointId(lat, lon);
            const marker = L.marker([lat, lon], {
                // ... các tùy chọn icon ...
            });
            marker.pointId = pointId; // Lưu ID vào đối tượng Marker
            marker.data = data; // Lưu dữ liệu gốc
            // 2. GẮN SỰ KIỆN CLICK để mở Popup HÀNH ĐỘNG
            marker.on('click', function (e) {
                // --- 2.1. Tìm Nhóm Hiện Tại ---
                let currentGroupId = null;
                for (const name in groups) {
                    if (groups[name].pointIds.includes(marker.pointId)) {
                        currentGroupId = groups[name].id;
                        break;
                    }
                }
                // --- 2.2. Tạo Nội Dung Popup ĐỘNG ---
                // SỬ DỤNG HÀM MÀ TÔI VỪA CHỈ BẠN
                const content = createActionPopupContent(marker.pointId, currentGroupId);
                // --- 2.3. Gán Popup MỚI và Mở ---
                marker.unbindPopup(); // RẤT QUAN TRỌNG: Gỡ bỏ popup cũ
                marker.bindPopup(content, {
                    className: 'action-popup', // Áp dụng CSS Hành Động
                    closeButton: true,
                    offset: L.point(0, -10)
                }).openPopup();
            });
            // 3. Thêm Marker vào Map
            marker.addTo(map);
            return marker;
        }
        /** * Ví dụ về cách tạo một mục kết quả tìm kiếm
        
         * và gán Tooltip tùy chỉnh (dùng thuộc tính data-title)
        
         */
        function createSearchResultItem(fullText, hubName) {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            // *** BƯỚC QUAN TRỌNG: Gán nội dung đầy đủ vào data-title ***
            // Thay item.title = fullText;
            item.setAttribute('data-title', fullText);
            // Phần hiển thị trên bảng kết quả (có thể bị cắt)
            const displayLength = 30;
            const truncatedText = fullText.length > displayLength
                ? fullText.substring(0, displayLength) + '...'
                : fullText;
            item.innerHTML = `${truncatedText} <span class="hub-name"> (${hubName})</span>`;
            return item;
        }
        // Ví dụ sử dụng:
        const container = document.getElementById('search-results-container');
        const longDescription = "Tòa nhà này là Trụ sở chính và điểm giao dịch lớn nhất của ngân hàng ABC tại trung tâm thành phố.";
        const hubInfo = "Hub A";
        const resultItem = createSearchResultItem(longDescription, hubInfo);
        container.appendChild(resultItem);
        /**
        
         * (ĐÃ SỬA LỖI UI) Hàm tìm kiếm điểm trên bản đồ theo TERMID hoặc Tên HUB.
        
         * Hiện thị kết quả và thêm nút "Đề xuất" bằng phương pháp gán Node an toàn.
        
         */
        function searchByTermId() {
            const input = document.getElementById('termid-search-input');
            const resultsContainer = document.getElementById('search-results-container');
            const searchTerm = String(input.value).trim().toUpperCase();
            // Xóa kết quả cũ
            resultsContainer.innerHTML = '';
            if (!searchTerm) {
                resultsContainer.style.display = 'none';
                showToast("Vui lòng nhập Mã CN hoặc Tên HUB để tìm kiếm.", "warning");
                return;
            }
            // Lọc các điểm (PGD/ATM) dựa trên TERMID hoặc TENHUB
            const searchResults = allPoints.filter(p =>
                !p.nhnn && (
                    String(p.id).toUpperCase().includes(searchTerm) ||
                    (p.tenHub && String(p.tenHub).toUpperCase().includes(searchTerm))
                )
            );
            if (searchResults.length > 0) {
                resultsContainer.style.display = 'block';
                searchResults.slice(0, 10).forEach(point => { // Giới hạn 10 kết quả
                    const item = document.createElement('div');
                    // Sử dụng class flex để căn chỉnh nội dung và nút
                    item.className = 'search-result-item flex justify-between items-center';
                    item.dataset.pointId = point.id;
                    // 1. Xây dựng Nội dung (ID/Tên HUB)
                    let contentSpan = document.createElement('span');
                    contentSpan.className = 'flex-1 overflow-hidden whitespace-nowrap text-ellipsis mr-2';
                    let content = `ID: ${point.id}`;
                    if (point.tenHub) {
                        content += `<span class="hub-name"> (${point.tenHub})</span>`;
                    }
                    contentSpan.innerHTML = content;
                    // 2. Xây dựng Nút "Đề xuất"
                    const addButton = document.createElement('button');
                    addButton.className = 'flex-shrink-0 px-2 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600';
                    addButton.textContent = 'Đề xuất';
                    // Ngăn chặn sự kiện click lan truyền và gọi hàm addProposal
                    addButton.onclick = (e) => {
                        e.stopPropagation();
                        addProposal(point.id);
                    };
                    // 3. Gắn các phần tử vào Item chính (Dùng appendChild để tránh lỗi ghi đè)
                    item.appendChild(contentSpan); // Thêm nội dung
                    item.appendChild(addButton);   // Thêm nút

                    // Gắn sự kiện click để focus vào điểm (cho toàn bộ dòng)
                    item.addEventListener('click', () => {
                        focusOnPoint(point.id);
                        resultsContainer.style.display = 'none'; // Ẩn danh sách sau khi click
                        input.value = point.id; // Đặt TERMID vào ô tìm kiếm
                    });
                    resultsContainer.appendChild(item);
                });
                showToast(`Tìm thấy ${searchResults.length} kết quả.`, "info");
            } else {
                resultsContainer.style.display = 'none';
                showToast(`Không tìm thấy kết quả nào với từ khóa: ${searchTerm}`, "error");
            }
        }
        // (XÓA v35) Xóa bỏ CHI_NHANH_TO_VUNG_MAP, vì VUNG giờ đã có trong data
        // --- 1. KHAI BÁO BIẾN TOÀN CỤC BẰNG LET (FIX LỖI ReferenceError) ---
        let map = null;
        let clusterLayer = null;
        let standardLayer = null;
        let analysisLayer = null;
        let nhnnMarkersLayer = null;
        let previewLayer = null;
        let measureLayer = null; // Layer mới
        let pointMarkersLayer = null;
        let isSearchPanelOpen = false;
        let showTermIDLabels = false;
        const PREVIEW_FADE_OPACITY = 0.3; // ✨ KHAI BÁO MỚI (FIX ReferenceError)
        let isOptimizationResultVisible = false; // ✨ MỚI: Theo dõi trạng thái vòng tròn tối ưu
        let proposedPoints = []; // Danh sách tối đa 5 điểm đề xuất
        // --- 2. Biến lưu trữ & Cấu hình (Giữ nguyên) ---
        let currentRadiusKm = 30; // Bán kính hiện tại (km)
        let RADIUS_METERS = 30000; // Bán kính hiện tại (mét)
        const GROUP_COLORS = [
            '#E6194B', '#F032E6', '#FFE119', '#4363D8', '#F58231', '#911EB4',
            '#008080', '#F032E6', '#BCF60C', '#FABEBE', '#008080', '#E6BEFF'
        ];
        const PREVIEW_COLOR = '#f59e0b';
        const NHNN_PREVIEW_LINE_COLOR = '#004aad';
        const OVERFLOW_COLOR = '#8b5cf6';
        let allPoints = [];
        let selectedPointA = null; // Lưu trữ dữ liệu điểm từ Search A
        let selectedPointB = null; // Lưu trữ dữ liệu điểm từ Search B
        let currentRoutingControl = null; // Lưu trữ đối tượng định tuyến hiện tại
        let currentStraightLine = null; // <<< ĐÃ THÊM BIẾN NÀY <<<
        let allGroups = [];
        let currentRankings = [];
        let currentPopup = null;
        let routingQueue = [];
        let isProcessingQueue = false;
        let groups = {};
        const ROUTING_DELAY_MS = 500;
        let allMarkers = {};
        let isBirdMode = true;
        let isBatteryView = false;
        let showDistanceLabels = false;
        let isClusteringEnabled = false;
        let showNhnnMarkers = false;
        // 3. HÀM KHỞI TẠO MAP VÀ LAYERS (Đã chỉnh sửa để gán cho các biến LET trên)
        function initializeMapAndLayers() {
            // Khởi tạo Map
            map = L.map('map').setView([21.0285, 105.8542], 13);
            map.createPane('borderPane');
            map.getPane('borderPane').style.zIndex = 399;
            L.tileLayer('http://{s}.google.com/vt/lyrs=r&x={x}&y={y}&z={z}&styles=feature:road|element:labels.text|visibility:off', {
                attribution: '&copy; Google Maps',
                subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                maxZoom: 20
            }).addTo(map);
            // Khởi tạo Layers và thêm vào map nếu cần
            clusterLayer = L.markerClusterGroup({
                chunkedLoading: true, maxClusterRadius: 70, disableClusteringAtZoom: 17, spiderfyOnMaxZoom: true, showCoverageOnHover: true,
                iconCreateFunction: function (cluster) {
                    const childCount = cluster.getChildCount();
                    let cname = 'my-cluster-icon ';
                    if (childCount < 10) { cname += 'small'; } else if (childCount < 100) { cname += 'medium'; } else { cname += 'large'; }
                    return L.divIcon({ html: `<div><span>${childCount}</span></div>`, className: cname, iconSize: L.point(40, 40) });
                }
            });
            standardLayer = L.layerGroup();
            analysisLayer = L.layerGroup().addTo(map);
            nhnnMarkersLayer = L.layerGroup().addTo(map);
            previewLayer = L.layerGroup([], { interactive: false }).addTo(map);
            // Layer đo lường mới
            measureLayer = L.layerGroup().addTo(map);
            pointMarkersLayer = isClusteringEnabled ? clusterLayer : standardLayer;
            map.addLayer(pointMarkersLayer);
        }
        initializeMapAndLayers();
        // Chạy khởi tạo map và layers

        // --- 3. Tạo Icon Tùy chỉnh (Động) ---
        // (SỬA v33) Hàm này giờ CHỦ YẾU dùng cho Tâm Nhóm (★)
        function createPointIcon(color, text = '') {
            return L.divIcon({
                className: 'point-icon',
                iconSize: [22, 22],
                iconAnchor: [11, 11],
                html: `<div style="background-color: ${color};" class="point-icon">${text}</div>`
            });
        }
        function createCenterPointIcon(color) {
            return L.divIcon({
                className: 'center-point-icon',
                iconSize: [24, 24],
                iconAnchor: [12, 12],
                html: `<div style="background-color: ${color};" class="center-point-icon">★</div>`
            });
        }
        /**
    
         * Icon cho điểm NHNN - Dùng ảnh (Code của bạn)
    
         */
        function createNHNNIcon() {
            const imageUrl = 'photo/icons8-bank-60.png';
            return L.icon({
                iconUrl: imageUrl,
                iconSize: [30, 30],
                iconAnchor: [15, 30], // [một nửa rộng, chiều cao]
                popupAnchor: [0, -30], // [0, -chiều cao]
                shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
                shadowSize: [41, 41],
                shadowAnchor: [12, 41] // Giữ nguyên shadow anchor
            });
        }
        /**
    
         * (HÀM MỚI v33) Icon cho PGD/ATM (điểm thường)
    
         */
        function createPGDIcon() {
            // *** ĐÂY LÀ ẢNH ICON PGD CỦA BẠN ***
            const imageUrl = 'photo/icons8-place-marker-94.png';
            return L.icon({
                iconUrl: imageUrl,
                iconSize: [30, 30],
                iconAnchor: [15, 30],
                popupAnchor: [0, -30],
                shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
                shadowSize: [41, 41],
                shadowAnchor: [12, 41]
            });
        }
        /**
    
         * (MỚI v39) Hàm định dạng tiền
    
         */
        function formatCurrency(value) {
            if (value >= 1000000000) {
                return (value / 1000000000).toFixed(1).replace('.0', '') + ' B';
            }
            if (value >= 1000000) {
                return (value / 1000000).toFixed(1).replace('.0', '') + ' M';
            }
            if (value >= 1000) {
                return (value / 1000).toFixed(1).replace('.0', '') + ' K';
            }
            return value;
        }
        /**
    
         * (MỚI v39) Hàm định dạng số đầy đủ
    
         */
        function formatFullNumber(value) {
            return new Intl.NumberFormat('vi-VN').format(value);
        }
        function createBatteryIcon(pointData) {

            // ==============================================================
            // ✨ LOG MỚI: DỮ LIỆU ĐẦU VÀO VÀ KẾT QUẢ TÍNH TOÁN PIN ✨
            console.log("--- BATTERY ICON LOG ---");
            console.log(`[Point ID]: ${pointData.id}`);
            console.log(`[Input] Tồn Quỹ (tonQuy): ${pointData.tonQuy}`);
            console.log(`[Input] Hạn Mức (hanMuc): ${pointData.hanMuc}`);
            console.log(`[Input] Vượt Hạn Mức Flag (vuotHanMuc): ${pointData.vuotHanMuc}`);
            // ==============================================================

            // (*** LOGIC MỚI: Lọc theo thuộc tính isBatteryPoint/TSCN ***)
            // Nếu điểm KHÔNG PHẢI là TSCN, trả về icon PGD tiêu chuẩn.
            if (!pointData.isBatteryPoint) {
                console.log("[ICON] Không phải TSCN. Trả về icon PGD tiêu chuẩn.");
                console.log("------------------------");
                return createPGDIcon();
            }
            // (*** KẾT THÚC LOGIC BỔ SUNG ***)

            let tonQuy = pointData.tonQuy || 0;
            let hanMuc = pointData.hanMuc || 0;

            // Tránh lỗi chia cho 0
            if (hanMuc === 0) {
                if (tonQuy > 0) { hanMuc = tonQuy; } else { hanMuc = 1; }
            }

            let percentage = (tonQuy / hanMuc) * 100;
            let fillPercent = Math.min(100, percentage);
            let overflowPercent = 0;
            let fillColor = '#16a34a'; // Xanh lá cây

            if (percentage >= 80 && percentage < 100) {
                fillColor = '#f59e0b'; // Vàng
            } else if (percentage >= 100) {
                fillColor = '#dc2626'; // Đỏ
            }

            percentage = Math.round(percentage);
            let amountLabelHtml = '';

            if (pointData.vuotHanMuc && tonQuy > hanMuc) {
                const overflowAmount = tonQuy - hanMuc;
                const formattedOverflowAmount = formatCurrency(overflowAmount);
                amountLabelHtml = `<div class="battery-amount-label">+${formattedOverflowAmount}</div>`;

                // Tính toán phần trăm tràn (SỬ DỤNG tonQuy-hanMuc / hanMuc)
                overflowPercent = Math.min(100, (overflowAmount / hanMuc) * 100);

                console.log(`[Tính toán] Tràn: ${overflowAmount} (${overflowPercent.toFixed(2)}%)`);

            }

            console.log(`[Kết quả] Phần trăm Pin: ${percentage}%`);
            console.log(`[Kết quả] Màu sắc: ${fillColor}`);
            console.log("------------------------");

            let html = `
        <div class="battery-icon-div-wrapper"> 
            <div class="battery-icon-container">
                <div class="battery-fill" style="width: ${fillPercent}%; background-color: ${fillColor};"></div>
                ${overflowPercent > 0 ?
                    `<div class="battery-overflow" style="width: ${overflowPercent}%; background-color: ${OVERFLOW_COLOR};"></div>` : ''}
                <span class="battery-text">${percentage}%</span>
            </div>
            ${amountLabelHtml} </div>
    `;

            return L.divIcon({
                className: 'battery-icon',
                html: html,
                iconSize: [0, 0],
                iconAnchor: [0, 0]
            });
        }
        /**
         * (FIXED) Hàm Bật/Tắt hiển thị nhãn Khoảng Cách/KM (Distance Labels).
         * Cập nhật trạng thái và gọi vẽ lại toàn bộ Groups.
         */
        function toggleDistanceLabels() {
            // ✨ BẬT LOADING ✨
            showLoadingScreen('https://lottie.host/e0b12a8f-22a4-4a8f-8898-15b5e39d0901/label_toggle.lottie', 'Đang cập nhật nhãn KM...');

            // 1. Đảo ngược trạng thái
            showDistanceLabels = !showDistanceLabels; // <-- Đảo ngược trạng thái showDistanceLabels
            const button = document.getElementById('labels-toggle-btn');

            if (currentPopup) map.closePopup(currentPopup);

            // 2. Cập nhật nút
            if (showDistanceLabels) {
                button.innerHTML = '<i class="fa-solid fa-tag w-4 h-4"></i> <span class="button-text">Nhãn KM (Bật)</span>';
                button.classList.add('labels-on');
                button.classList.remove('labels-off');
                showToast("Đã BẬT: Hiển thị nhãn KM", 'info');
            } else {
                // (Sửa icon) Dùng fa-tag-slash cho đẹp hơn
                button.innerHTML = '<i class="fa-solid fa-tag-slash w-4 h-4"></i> <span class="button-text">Nhãn KM (Tắt)</span>';
                button.classList.add('labels-off');
                button.classList.remove('labels-on');
                showToast("Đã TẮT: Ẩn nhãn KM", 'warning');
            }

            // 3. ✨ GỌI VẼ LẠI TOÀN BỘ GROUPS để logic ẩn nhãn KM trong drawAllGroups() chạy ✨
            drawAllGroups();

            // (Giữ nguyên logic của bạn về clearPreview)
            clearPreview();
            // ✨ ẨN LOADING SAU KHI VẼ XONG ✨
    setTimeout(() => { 
        hideLoadingScreen(); 
    }, 300);
        }
        // (*** SỬA v50 ***) Sửa logic Bật/Tắt (Không đóng menu ☰)
        function toggleRankPanel() {
            const panel = document.getElementById('rank-table-container');
            const button = document.getElementById('rank-toggle-btn');
            if (!panel || !button) return;
            // Lấy panel/nút của Filter
            const filterPanel = document.getElementById('filter-controls-container');
            const filterButton = document.getElementById('filter-toggle-btn');
            if (panel.style.display === 'block') {
                // Đang Bật -> Tắt nó đi
                panel.style.display = 'none';
                button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt
            } else {
                // Đang Tắt -> Bật nó lên
                panel.style.display = 'block';
                button.style.cssText = 'background-color: #3b82f6 !important; color: white !important;'; // Style Bật
                // (SỬA v50) Tắt panel kia (nếu đang mở)
                if (filterPanel) filterPanel.style.display = 'none';
                if (filterButton) filterButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt
            }
            // (*** LỖI ĐÃ XÓA ***) Không còn dòng code đóng menu ☰ ở đây
        }
        // (SỬA v50) Sửa logic Bật/Tắt (Không đóng menu ☰)
        function toggleFilterControls() {
            const controls = document.getElementById('filter-controls-container');
            const button = document.getElementById('filter-toggle-btn');
            if (!controls || !button) return;
            // Lấy panel/nút của Rank
            const rankPanel = document.getElementById('rank-table-container');
            const rankButton = document.getElementById('rank-toggle-btn');
            if (controls.style.display === 'block') {
                controls.style.display = 'none';
                button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt
            } else {
                controls.style.display = 'block';
                button.style.cssText = 'background-color: #6b7280 !important; color: white !important;'; // Style Bật
                // (SỬA v50) Tắt panel kia (nếu đang mở)
                if (rankPanel) rankPanel.style.display = 'none';
                if (rankButton) rankButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt
            }
            // (*** LỖI ĐÃ XÓA ***) Không còn dòng code đóng menu ☰ ở đây
        }
        // --- 4. Thêm Nút điều khiển ---
        // (SỬA v50) Cập nhật Nút Thu Gọn + Style mặc định
        L.Control.MasterControls = L.Control.extend({
            onAdd: function (map) {
                // 1. Tạo container chính
                const container = L.DomUtil.create('div', 'leaflet-bar custom-controls-container');
                L.DomEvent.disableClickPropagation(container);
                // 2. (MỚI v47) Nút Bật/Tắt Panel (Hamburger)
                const toggleButton = L.DomUtil.create('button', 'leaflet-bar-part', container);
                toggleButton.id = 'panel-toggle-btn';
                toggleButton.innerHTML = '<i class="fa-solid fa-bars"></i>'; // Icon Hamburger
                // (*** SỬA LỖI v48.1 ***)
                toggleButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    // Logic Bật/Tắt class 'expanded' trên container chính
                    if (L.DomUtil.hasClass(container, 'expanded')) {
                        L.DomUtil.removeClass(container, 'expanded');
                    } else {
                        L.DomUtil.addClass(container, 'expanded');
                    }
                };
                // 3. (MỚI v47) Wrapper cho tất cả các nút con
                const buttonsWrapper = L.DomUtil.create('div', 'buttons-wrapper', container);
                // --- 4. Bắt đầu các nút con ---
                // (*** MỚI v50 ***) Nút ĐÓNG (Collapse) Panel
                const collapseButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);
                collapseButton.id = 'panel-collapse-btn';
                collapseButton.innerHTML = '<i class="fa-solid fa-chevron-right w-4 h-4"></i>';
                collapseButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    L.DomUtil.removeClass(container, 'expanded');
                };

                // (*** MỚI v48 ***) Nút Bảng Xếp Hạng (Toggle)
                const rankButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);
                rankButton.id = 'rank-toggle-btn';
                rankButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';
                rankButton.innerHTML = '<i class="fa-solid fa-trophy w-4 h-4"></i> <span class="button-text">Xếp Hạng</span>';
                rankButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    toggleRankPanel(); // Hàm mới
                };
                rankButton.style.display = 'none';
                // Thêm nút này bên trong buttonsWrapper trong MasterControls
                const autoGroupButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg btn-new', buttonsWrapper);
                autoGroupButton.id = 'auto-group-btn';
                // ✨ ĐỔI NỘI DUNG NÚT TẠI ĐÂY ✨
                autoGroupButton.innerHTML = '<i class="fa-solid fa-list-ol w-4 h-4"></i> <span class="button-text">Tạo Top 22 Hub</span>';
                autoGroupButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    // ✨ ĐỔI TÊN HÀM (Nếu bạn dùng tên mới) HOẶC giữ nguyên tên cũ nếu bạn muốn. Tôi dùng tên mới để phản ánh tính năng linh hoạt.
                    createTopHubGroups(22);
                };
                // (*** MỚI v48 ***) Nút Tùy Chỉnh Map (Filter)
                const filterButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);
                filterButton.id = 'filter-toggle-btn';
                filterButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';
                filterButton.innerHTML = '<i class="fa-solid fa-sliders w-4 h-4"></i> <span class="button-text">Tùy Chỉnh Map</span>';
                filterButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    toggleFilterControls();
                };
                // Nút Bật/Tắt Search Panel
                const searchToggleButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);
                searchToggleButton.id = 'search-panel-toggle-btn';
                searchToggleButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';
                searchToggleButton.innerHTML = '<i class="fa-solid fa-crosshairs w-4 h-4"></i> <span class="button-text">Tìm/Đo (Tắt)</span>';
                searchToggleButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    toggleSearchPanel(); // Hàm mới
                };
                // Nút Bật/Tắt TermID Labels
                const termIDToggleBtn = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);
                termIDToggleBtn.id = 'termid-toggle-btn';
                // ✨ THAY THẾ CSS VÀ HTML CỦA NÚT THÀNH TRẠNG THÁI 'Tắt' MẶC ĐỊNH ✨
                termIDToggleBtn.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';
                termIDToggleBtn.innerHTML = '<i class="fa-solid fa-tag-slash w-4 h-4"></i> <span class="button-text">TermID (Tắt)</span>';
                // Lưu ý: Đã đổi 'tag' sang 'tag-slash' và 'TermID (Bật)' sang 'TermID (Tắt)'
                termIDToggleBtn.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    toggleTermIDLabels();
                    applyFilter();
                };
                // Nút Routing
                const routingButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg bird-mode', buttonsWrapper);
                routingButton.id = 'routing-toggle-btn';
                routingButton.innerHTML = '<i class="fa-solid fa-feather w-4 h-4"></i> <span class="button-text">Đường chim Bay</span>';
                routingButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    toggleRoutingMode();
                };
                // Nút Chế độ Pin (FIX LỖI: Gọi hàm trực tiếp)
                const batteryButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg pin-mode', buttonsWrapper);
                batteryButton.id = 'battery-toggle-btn';
                batteryButton.innerHTML = '<i class="fa-solid fa-battery-half w-4 h-4"></i> <span class="button-text">Chế độ Pin</span>';
                batteryButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    // GỌI HÀM AN TOÀN HƠN
                    if (typeof toggleBatteryView === 'function') {
                        toggleBatteryView();
                    } else {
                        console.error("Hàm toggleBatteryView chưa được định nghĩa.");
                    }
                };
                // Nút Bật/Tắt Gom Cụm
                const clusterButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg cluster-off', buttonsWrapper);
                clusterButton.id = 'cluster-toggle-btn';
                clusterButton.innerHTML = '<i class="fa-solid fa-braille w-4 h-4"></i> <span class="button-text">Gom Cụm (Tắt)</span>';
                clusterButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    toggleClustering();
                };
                // Nút Bật/Tắt Nhãn KM
                // Đã sửa: Khởi tạo với class 'labels-off' và nội dung 'Nhãn KM (Tắt)'
                const labelsButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg labels-off', buttonsWrapper);
                labelsButton.id = 'labels-toggle-btn';
                labelsButton.innerHTML = '<i class="fa-solid fa-tag-slash w-4 h-4"></i> <span class="button-text">Nhãn KM (Tắt)</span>';
                labelsButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    toggleDistanceLabels();
                };

                // Nút Bật/Tắt NHNN
                // Đã sửa: Khởi tạo với class 'nhnn-off' và nội dung 'Hiện NHNN'
                const nhnnButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg nhnn-off', buttonsWrapper);
                nhnnButton.id = 'nhnn-toggle-btn';
                nhnnButton.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i> <span class="button-text">Hiện NHNN</span>';
                nhnnButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    toggleNhnn();
                };
                // (*** MỚI ***) Nút LƯU/EXPORT DỮ LIỆU NHÓM
                const saveButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg btn-add', buttonsWrapper);
                saveButton.id = 'save-groups-btn';
                saveButton.innerHTML = '<i class="fa-solid fa-cloud-arrow-up w-4 h-4"></i> <span class="button-text">Lưu Dữ Liệu Nhóm</span>';
                saveButton.onclick = (e) => {
                    L.DomEvent.stopPropagation(e);
                    exportGroupsData(); // Gọi hàm xử lý chính
                    saveData();
                };
                // --- Hết các nút con ---
                // (MỚI v47) Khi click vào bản đồ, đóng panel (nếu đang mở trên di động)
                map.on('click', () => { L.DomUtil.removeClass(container, 'expanded'); });
                map.on('dragstart', () => { L.DomUtil.removeClass(container, 'expanded'); });
                return container;
            },
            onRemove: function (map) { }
        });
        // Thêm control mới vào bản đồ (Chắc chắn chạy sau initializeMapAndLayers())
        new L.Control.MasterControls({ position: 'topright' }).addTo(map);
        // --- 5. Các Hàm Chức năng ---
        // Tên khóa dùng để lưu trữ trong localStorage
        const LOCAL_STORAGE_KEY = 'HMTQ_SAVED_GROUPS_V2'; // Dùng V2 để đảm bảo lưu Polyline Cache
        /**
        
         * (SỬA ĐỔI) Hàm xuất và LƯU dữ liệu nhóm đã tạo vào Local Storage.
        
         */
        /**
         * (ĐÃ THÊM LOG) Hàm xuất và LƯU dữ liệu nhóm đã tạo vào Local Storage.
         * Sẽ ghi lại exportedData vào console trước khi lưu.
         */
        function exportGroupsData() {
            if (allGroups.length === 0) {
                // Xóa dữ liệu cũ nếu không còn nhóm nào
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                showToast("Đã xóa dữ liệu nhóm cũ trong trình duyệt.", "warning");
                return;
            }

            // 1. Chuyển đổi dữ liệu thô sang cấu trúc gọn gàng
            const exportedData = allGroups.map(group => {
                // Lọc ra ID của tất cả các điểm trong nhóm (bao gồm điểm tâm)
                const memberIds = group.points.map(p => p.id);
                return {
                    group_id: group.id,
                    group_number: group.groupNumber,
                    color: group.color,
                    center_point: {
                        id: group.centerPoint.id,
                        lat: group.centerPoint.latlng.lat,
                        lon: group.centerPoint.latlng.lng,
                    },
                    fixedRadiusMeters: group.fixedRadiusMeters,
                    fixedRadiusKm: group.fixedRadiusKm,
                    member_ids: memberIds, // <--- ĐÃ GOM CẢ ĐIỂM TÂM
                    polyline_cache: group.polylineCache,
                    member_count: memberIds.length
                };
            });

            // ✨ LỆNH LOG MỚI: Ghi lại cấu trúc Array đã xuất ✨
            console.log("--- DỮ LIỆU EXPORTEDDATA (LOCAL STORAGE) ---");
            console.log(exportedData);
            console.log("-------------------------------------------");

            const jsonOutput = JSON.stringify(exportedData);

            // 2. LƯU VÀO LOCAL STORAGE
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, jsonOutput);
                showToast("Đã lưu trạng thái nhóm thành công!", "success");
            } catch (e) {
                showToast("Lỗi lưu trữ! Trình duyệt quá đầy hoặc đang ở chế độ ẩn danh.", "error");
            }
        }
        // (MỚI) Hàm hỗ trợ lấy dữ liệu điểm gốc từ ID
        function getPointDataById(pointId) {
            return allPoints.find(p => p.id === pointId);
        }
        /**
        
         * (SỬA LỖI PHỤC HỒI CACHE) Hàm tải và phục hồi dữ liệu nhóm đã lưu.
        
         * @param {Array} savedGroupsData - Dữ liệu JSON đã lưu trữ.
        
         */
        function loadSavedGroups(savedGroupsData) {
            if (!Array.isArray(savedGroupsData) || savedGroupsData.length === 0) {
                return;
            }
            // 1. Xóa trạng thái nhóm hiện tại và các nhóm cũ
            allGroups = [];
            groups = {};
            allPoints.forEach(p => p.groupId = null);
            let loadCount = 0;
            // 2. Tải từng nhóm
            savedGroupsData.forEach(savedGroup => {
                const centerPointId = savedGroup.center_point.id;
                const centerPointData = getPointDataById(centerPointId);
                if (!centerPointData) {
                    console.warn(`Bỏ qua nhóm ${savedGroup.group_id}: Không tìm thấy điểm tâm ID ${centerPointId}.`);
                    return;
                }
                const newGroup = {
                    id: savedGroup.group_id,
                    centerPoint: centerPointData,
                    color: savedGroup.color,
                    groupNumber: savedGroup.group_number,
                    routingControls: [],
                    // PHỤC HỒI POLYLINE CACHE (Giữ nguyên)
                    polylineCache: savedGroup.polyline_cache || {},
                    // ✨ SỬA LỖI: PHỤC HỒI BÁN KÍNH CỐ ĐỊNH VÀ ĐẢM BẢO LÀ SỐ HỢP LỆ ✨
                    fixedRadiusMeters: Number(savedGroup.fixedRadiusMeters) || 30000,
                    fixedRadiusKm: Number(savedGroup.fixedRadiusKm) || 30,
                    points: [] // Khởi tạo mảng điểm
                };
                // **********************************************
                // 3. Cập nhật các điểm thành viên VÀ ĐIỂM TÂM
                const memberIds = savedGroup.member_ids;
                const pointsInGroup = [];
                // Đảm bảo điểm tâm là thành viên của nhóm
                centerPointData.groupId = savedGroup.group_id;
                pointsInGroup.push(centerPointData);
                memberIds.forEach(memberId => {
                    if (memberId === centerPointId) return; // Bỏ qua nếu là điểm tâm (đã thêm)
                    const memberPoint = getPointDataById(memberId);
                    if (memberPoint) {
                        memberPoint.groupId = savedGroup.group_id;
                        pointsInGroup.push(memberPoint);
                    }
                });
                // Gán MẢNG ĐIỂM đã hoàn chỉnh (bao gồm điểm tâm) vào nhóm
                newGroup.points = pointsInGroup; // <--- DÒNG SỬA CHỮA
                allGroups.push(newGroup);
                // 4. Đồng bộ biến 'groups' (cho UI Popup)
                groups[`NHÓM ${savedGroup.group_number}`] = {
                    id: savedGroup.group_id,
                    color: savedGroup.color,
                    pointIds: memberIds
                };
                loadCount++;
            });
            // 6. Vẽ lại bản đồ
            drawAllGroups();
            updateRankTable();
            updateFilterOptions();
            if (loadCount > 0) {
                showToast(`Đã tải lại ${loadCount} nhóm từ bộ nhớ thành công!`, "info");
            }
        }
        /**
        
         * (MỚI) Xóa một nhóm đã chọn.
        
         * @param {string} groupId - ID của nhóm cần xóa (ví dụ: 'G_1').
        
         */
        function popup_deleteGroup(groupId) {
            // Thêm hộp thoại xác nhận để tránh xóa nhầm
            if (!confirm(`Bạn có chắc chắn muốn hủy Nhóm ID: ${groupId} không? Hành động này không thể hoàn tác.`)) {
                return;
            }
            if (currentPopup) {
                map.closePopup(currentPopup);
                currentPopup = null;
            }
            const groupIndex = allGroups.findIndex(g => String(g.id) === String(groupId));
            if (groupIndex === -1) {
                showToast(`Lỗi: Không tìm thấy nhóm ID ${groupId}.`, "error");
                return;
            }
            const groupToDelete = allGroups[groupIndex];
            const groupNumber = groupToDelete.groupNumber;
            // 1. Reset GroupID cho TẤT CẢ các điểm trong nhóm
            // Bao gồm các điểm trong mảng points và điểm centerPoint (cần tìm lại điểm centerPoint từ allPoints)
            // Tìm lại tất cả các điểm trên bản đồ mà có groupId này
            const pointsToReset = allPoints.filter(p => String(p.groupId) === String(groupId));
            pointsToReset.forEach(p => {
                p.groupId = null; // Đưa về trạng thái chưa được nhóm
            });
            // 2. Xóa khỏi danh sách nhóm (allGroups)
            allGroups.splice(groupIndex, 1);
            // 3. Xóa khỏi đối tượng groups (dùng cho UI/Popup)
            const groupKey = Object.keys(groups).find(key => groups[key].id === groupId);
            if (groupKey) {
                delete groups[groupKey];
            }
            // 4. CẬP NHẬT TRẠNG THÁI: Vẽ lại bản đồ và UI
            drawAllGroups();
            updateRankTable();
            updateFilterOptions();
            // 5. LƯU VÀO LOCAL STORAGE
            exportGroupsData();
            showToast(`Đã hủy thành công Nhóm ${groupNumber} và đưa ${pointsToReset.length} điểm về trạng thái chưa nhóm.`, "success");
        }
        /**
         * (FINAL FIX SỰ KIỆN CLICK) Hàm Khởi tạo dữ liệu điểm và thêm Marker vào bản đồ.
         * Gắn sự kiện click cho tất cả PGD/ATM/TSCN ngay từ đầu.
         */
        function addPointToMap(latlng, termId, chinhanh, nhnn, vung, tonQuyStr, vuotHanMucStr, hanMucStr, hubYesStr, tenHubStr, plDgdStr) {
            const isNHNN = (nhnn === true || String(nhnn).toLowerCase() === 'true' || String(nhnn) === '1');
            const cleanChinhanh = chinhanh ? String(chinhanh).trim() : 'Không có';
            const cleanVung = vung ? String(vung).trim() : 'Không xác định';
            const cleanTonQuy = parseFloat(String(tonQuyStr).replace(/[\s,]/g, '')) || 0;
            const cleanHanMuc = parseFloat(String(hanMucStr).replace(/[\s,]/g, '')) || 0;
            const isVuotHanMuc = String(vuotHanMucStr).trim() !== '-' && String(vuotHanMucStr).trim() !== '';
            const isHubPoint = String(hubYesStr).trim().toUpperCase() === 'YES';
            const isBatteryPoint = String(plDgdStr).trim().toUpperCase() === 'TSCN';
            const cleanTenHub = tenHubStr ? String(tenHubStr).trim() : null;

            const newMarker = L.marker(latlng, {
                icon: isNHNN ? createNHNNIcon() : createPGDIcon()
            });

            const pointId = (termId ? String(termId).trim() : null) || L.stamp(newMarker);
            allMarkers[pointId] = newMarker;

            newMarker.bindTooltip(pointId, {
                permanent: true,
                direction: 'top',
                className: 'termid-label-tooltip',
                offset: L.point(0, -15)
            });

            if (isNHNN) { newMarker.addTo(nhnnMarkersLayer); }

            const newPointData = {
                id: pointId,
                latlng: latlng,
                marker: newMarker,
                groupId: isNHNN ? 'REFERENCE' : null,
                chinhanh: cleanChinhanh,
                vung: cleanVung,
                isVisible: true,
                nhnn: isNHNN,
                tonQuy: cleanTonQuy,
                hanMuc: cleanHanMuc,
                vuotHanMuc: isVuotHanMuc,
                isHub: isHubPoint,
                tenHub: cleanTenHub,
                isBatteryPoint: isBatteryPoint,
                termIDTooltip: newMarker.getTooltip()
            };

            // === GẮN TẤT CẢ CÁC SỰ KIỆN CHO PGD/ATM/TSCN ===
            if (!isNHNN) {
                // Sự kiện Hover cho Preview (Giữ nguyên)
                newMarker.on('mouseover', (e) => {
                    // ... (Logic showPreview) ...
                });
                newMarker.on('mouseout', () => {
                    // ... (Logic clearPreview) ...
                });

                // ✨ SỰ KIỆN CLICK CHÍNH: Gọi handleMarkerClick (Quan trọng)
                newMarker.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    handleMarkerClick(newPointData);
                });

            } else {
                // Điểm NHNN: Gắn sự kiện click đơn giản
                newMarker.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    handleMarkerClick(newPointData);
                });
            }

            newMarker.on('popupclose', () => {
                currentPopup = null;
            });

            allPoints.push(newPointData);
            return newPointData;
        }
        /**
         * (FIX ĐỒNG BỘ TERMID) Hàm Bật/Tắt hiển thị lớp NHNN.
         */
        function toggleNhnn() {
            // 1. Đảo ngược trạng thái
            showNhnnMarkers = !showNhnnMarkers;
            const button = document.getElementById('nhnn-toggle-btn');

            if (currentPopup) map.closePopup(currentPopup);
            // 2. Cập nhật nút
            if (showNhnnMarkers) {
                button.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i> <span class="button-text">Ẩn NHNN</span>';
                button.classList.add('nhnn-on');
                button.classList.remove('nhnn-off');
                showToast("Đã BẬT: Hiển thị NHNN", 'info');
            } else {
                button.innerHTML = '<i class="fa-solid fa-eye-slash w-4 h-4"></i> <span class="button-text">Hiện NHNN</span>';
                button.classList.add('nhnn-off');
                button.classList.remove('nhnn-on');
                showToast("Đã TẮT: Ẩn NHNN", 'warning');
            }
            // 3. (QUAN TRỌNG) Gọi lại hàm applyFilter
            applyFilter(); // ✨ Đảm bảo p.isVisible được cập nhật và TermID được đồng bộ ✨
        }
        function loadPreloadedData() {
            const powerAutomateUrl = 'https://default460cecfbf0c64dd7a5ec66ef4d75ae.63.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/c7a3ba54b6604025882ae481816180bb/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=R88_MePGo47lYzv0ndIiVxbRUcMncU26zdMq9HGw9hs';
            showToast("Đang tải dữ liệu từ Power Automate...", 'info');

            // ✨ BƯỚC 1: HIỂN THỊ LOADING SCREEN TẠI ĐÂY ✨
            showLoadingScreen('https://lottie.host/d446a9ec-3c6a-4972-8867-a22b1a98a52b/pywJYiMejV.lottie', 'Đang tải dữ liệu điểm gốc...');

            fetch(powerAutomateUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({})
            })
                .then(response => {
                    if (!response.ok) {
                        // Nếu lỗi ở bước 1, chúng ta phải ẩn loading và báo lỗi
                        hideLoadingScreen();
                        throw new Error(`Lỗi HTTP! Trạng thái: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    let bounds = L.latLngBounds();
                    // ... (Logic xử lý dữ liệu điểm ban đầu giữ nguyên) ...

                    data.forEach(item => {
                        const lat = parseFloat(String(item.LATITUDE).trim());
                        const lng = parseFloat(String(item.LONGITUDE).replace('S', '').trim());
                        if (!isNaN(lat) && !isNaN(lng)) {
                            const latlng = L.latLng(lat, lng);
                            addPointToMap(
                                latlng,
                                item.TERMID,
                                item.CHINHANH,
                                item.NHNN,
                                item.VUNG,
                                item.Ton_quy_cuoi_ngay,
                                item.VUOT_HAN_MUC,
                                item.HMTQ_ngay,
                                item.HUBYES,
                                item.TENHUB,
                                item.PL_DGD
                            );
                            bounds.extend(latlng);
                        } else {
                            console.warn("Bỏ qua điểm có tọa độ không hợp lệ:", item.TERMID);
                        }
                    });

                    buildCascadingFiltersUI();
                    showToast(`Đã tải ${data.length} điểm dữ liệu.`, 'success');
                    updateRankTable();
                    renderProposalList();
                    updateMarkersVisibility();

                    if (bounds.isValid()) {
                        map.fitBounds(bounds.pad(0.1));
                    }

                    // ✨ BƯỚC 2: TIẾN HÀNH TẢI DATA NHÓM (loadData) ✨
                    return loadData(); // Trả về promise của loadData để chờ nó hoàn thành

                })
                .catch(error => {
                    // Nếu có lỗi ở bất kỳ đâu trong chuỗi (trừ khi loadData xử lý lỗi của nó), ẩn loading
                    hideLoadingScreen();
                    console.error('Lỗi khi tải dữ liệu từ Power Automate:', error);
                    showToast(`Lỗi tải dữ liệu ban đầu: ${error.message}`, 'error');
                    updateRankTable();
                    updateMarkersVisibility();
                });
        }
        /**
        
         * (MỚI) Đọc dữ liệu từ Local Storage và gọi phục hồi.
        
         */
        function loadGroupsFromLocalStorage() {
            try {
                const savedJson = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (savedJson) {
                    const savedData = JSON.parse(savedJson);
                    loadSavedGroups(savedData);
                }
            } catch (e) {
                console.error("Lỗi khi đọc Local Storage:", e);
                showToast("Lỗi khi tải lại trạng thái nhóm từ bộ nhớ.", "error");
            }
        }
        // --- (MỚI v35) CỤM LOGIC LỌC GIA ĐÌNH ---
        /**
    
         * (SỬA v40) Thêm HTML cho bộ lọc Nhóm
    
         */
        function buildCascadingFiltersUI() {
            const container = document.getElementById('cascading-filter-container');
            if (!container) return;
            container.innerHTML = `
<hr class="my-3 border-t border-gray-300">
    <div class="filter-control">
        <label for="filter-vung">Lọc theo Vùng:</label>
        <select id="filter-vung" multiple size="4">
        </select>
    </div>
    <div class="filter-control">
        <label for="filter-chinhanh">Lọc theo Chi Nhánh:</label>
        <select id="filter-chinhanh" multiple size="5">
        </select>
    </div>
    <div class="filter-control">
        <label for="filter-termid">Lọc theo Mã CN (TERMID):</label>
        <select id="filter-termid" multiple size="5">
        </select>
    </div>
<div class="filter-control">
    <label for="filter-pldgd">Lọc theo Loại Điểm (TSCN/PGD):</label>
    <select id="filter-pldgd" multiple size="3">
    </select>
</div>
    <div class="filter-control">
        <label for="filter-vuothm">Lọc theo Hạn Mức:</label>
        <select id="filter-vuothm" multiple size="3">
        </select>
    </div>
    <div class="filter-control">
        <label for="filter-nhom">Lọc theo Nhóm:</label>
        <select id="filter-nhom" multiple size="5">
        </select>
    </div>
    <button id="reset-cascading-filter-btn">
        <i class="fa-solid fa-filter-circle-xmark"></i> Xóa Lọc
    </button>
        `;
            // Gắn sự kiện
            document.getElementById('filter-vung').addEventListener('change', () => {
                updateFilterOptions();
                applyFilter();
            });
            document.getElementById('filter-chinhanh').addEventListener('change', () => {
                updateFilterOptions(); // Cập nhật TERMID, Hạn Mức, Nhóm
                applyFilter();
            });
            document.getElementById('filter-termid').addEventListener('change', () => {
                updateFilterOptions(); // Cập nhật Hạn Mức, Nhóm
                applyFilter();
            });
            document.getElementById('filter-vuothm').addEventListener('change', () => {
                updateFilterOptions(); // Cập nhật Nhóm
                applyFilter();
            });
            // (MỚI v40) Gắn sự kiện cho bộ lọc Nhóm
            document.getElementById('filter-nhom').addEventListener('change', applyFilter);

            document.getElementById('reset-cascading-filter-btn').addEventListener('click', () => {
                // ✨ LOGIC ĐÃ SỬA: Lặp qua TẤT CẢ các select và hủy chọn tất cả options ✨
                const filterIds = ['filter-vung', 'filter-chinhanh', 'filter-termid', 'filter-vuothm', 'filter-nhom'];
                filterIds.forEach(id => {
                    const selectElement = document.getElementById(id);
                    if (selectElement) {
                        // Đặt tất cả options về trạng thái không được chọn
                        Array.from(selectElement.options).forEach(option => {
                            option.selected = false;
                        });

                    }
                });
                // Sau khi reset các lựa chọn, gọi updateFilterOptions để xây dựng lại các dropdown 
                // và applyFilter để hiển thị tất cả điểm.
                updateFilterOptions();
                applyFilter();
                showToast("Đã xóa lọc", "info");
            });
            // Tải dữ liệu lần đầu
            updateFilterOptions();
            setupMultiSelectToggle();
        }
        /**
         * (FINAL FIX: LOGIC MẶC ĐỊNH NHÓM VÀ PL_DGD) Cập nhật các dropdown phụ thuộc.
         * ĐÃ KHẮC PHỤC LỖI: Assignment to constant variable (Thay const bằng let cho biến mảng tạm thời).
         * Logic mặc định cho Nhóm: Nếu chưa chọn gì, ưu tiên CHỈ chọn "-- TẤT CẢ NHÓM --".
         */
        function updateFilterOptions() {
            const vungSelect = document.getElementById('filter-vung');
            const chinhanhSelect = document.getElementById('filter-chinhanh');
            const termidSelect = document.getElementById('filter-termid');
            const vuothmSelect = document.getElementById('filter-vuothm');
            const pldgdSelect = document.getElementById('filter-pldgd');
            const nhomSelect = document.getElementById('filter-nhom');

            if (!vungSelect || !chinhanhSelect || !termidSelect || !vuothmSelect || !pldgdSelect || !nhomSelect) return;

            const getSelectedValues = (selectElement) => {
                if (!selectElement) return [];
                return Array.from(selectElement.options)
                    .filter(option => option.selected)
                    .map(option => option.value);
            };

            // Lấy các giá trị đã chọn hiện tại (SỬ DỤNG LET)
            let selectedVung = getSelectedValues(vungSelect);
            let selectedChiNhanh = getSelectedValues(chinhanhSelect);
            let selectedTermid = getSelectedValues(termidSelect);
            let selectedVuotHM = getSelectedValues(vuothmSelect);
            let selectedPLDGD = getSelectedValues(pldgdSelect);
            let selectedNhom = getSelectedValues(nhomSelect);

            let pointsToFilter = allPoints.filter(p => !p.nhnn);

            // 1. Cập nhật Vùng
            vungSelect.innerHTML = '';
            const vungSet = new Set(pointsToFilter.map(p => p.vung));
            vungSet.forEach(vung => { vungSelect.innerHTML += `<option value="${vung}">${vung}</option>`; });
            if (selectedVung.length > 0) { pointsToFilter = pointsToFilter.filter(p => selectedVung.includes(p.vung)); }

            // 2. Cập nhật Chi Nhánh
            chinhanhSelect.innerHTML = '';
            const chinhanhSet = new Set(pointsToFilter.map(p => p.chinhanh));
            chinhanhSet.forEach(cn => { chinhanhSelect.innerHTML += `<option value="${cn}">${cn}</option>`; });
            if (selectedChiNhanh.length > 0) { pointsToFilter = pointsToFilter.filter(p => selectedChiNhanh.includes(p.chinhanh)); }

            // 3. Cập nhật TERMID
            termidSelect.innerHTML = '';
            const termidSet = new Set(pointsToFilter.map(p => String(p.id)));
            const sortedTermids = [...termidSet].sort((a, b) => String(a).localeCompare(String(b)));
            sortedTermids.forEach(id => { termidSelect.innerHTML += `<option value="${id}">${id}</option>`; });
            if (selectedTermid.length > 0) { pointsToFilter = pointsToFilter.filter(p => selectedTermid.includes(String(p.id))); }

            // 4. Cập nhật Hạn Mức
            vuothmSelect.innerHTML = '';
            const vuotHMSet = new Set(pointsToFilter.map(p => p.vuotHanMuc));
            vuothmSelect.innerHTML += '<option value="ALL_HM">-- Tất cả Hạn Mức --</option>';
            if (vuotHMSet.has(true)) { vuothmSelect.innerHTML += '<option value="YES">Vượt Hạn Mức</option>'; }
            if (vuotHMSet.has(false)) { vuothmSelect.innerHTML += '<option value="NO">Không Vượt</option>'; }
            if (selectedVuotHM.length > 0 && !selectedVuotHM.includes('ALL_HM')) {
                pointsToFilter = pointsToFilter.filter(p => selectedVuotHM.some(filterValue => {
                    if (filterValue === 'YES') return p.vuotHanMuc === true;
                    if (filterValue === 'NO') return p.vuotHanMuc === false;
                    return false;
                }));
            } else if (selectedVuotHM.length === 0) {
                selectedVuotHM = ['ALL_HM'];
            }


            // 5. Cập nhật PL_DGD (Loại điểm)
            pldgdSelect.innerHTML = '';
            const pldgdSet = new Set(pointsToFilter.map(p => p.isBatteryPoint));
            pldgdSelect.innerHTML += '<option value="ALL_PLDGD">-- Tất cả Loại Điểm --</option>';

            if (pldgdSet.has(true)) {
                pldgdSelect.innerHTML += `<option value="TSCN">Chỉ TSCN</option>`;
            }
            if (pldgdSet.has(false)) {
                pldgdSelect.innerHTML += `<option value="PGD_ATM">Chỉ PGD/ATM</option>`;
            }

            // Áp dụng lọc PL_DGD cho bước tiếp theo
            if (selectedPLDGD.length > 0 && !selectedPLDGD.includes('ALL_PLDGD')) {
                pointsToFilter = pointsToFilter.filter(p => selectedPLDGD.some(filterValue => {
                    if (filterValue === 'TSCN') return p.isBatteryPoint === true;
                    if (filterValue === 'PGD_ATM') return p.isBatteryPoint === false;
                    return false;
                }));
            } else if (selectedPLDGD.length === 0) {
                selectedPLDGD = ['ALL_PLDGD'];
            }


            // 6. Cập nhật Nhóm
            nhomSelect.innerHTML = '';
            const nhomSet = new Set(pointsToFilter.map(p => p.groupId));
            nhomSelect.innerHTML += '<option value="ALL">-- Tất cả --</option>';

            if (allGroups.length > 0) {
                nhomSelect.innerHTML += '<option value="ALL_GROUPED">-- TẤT CẢ NHÓM --</option>';
            }
            if (nhomSet.has(null)) {
                nhomSelect.innerHTML += '<option value="NULL">[CHƯA CÓ NHÓM]</option>';
            }

            allGroups.forEach(group => {
                if (nhomSet.has(group.id)) {
                    nhomSelect.innerHTML += `<option value="${group.id}">Nhóm ${group.groupNumber}</option>`;
                }
            });
            // ✨ LOGIC BUỘC CHỌN VÀ MẶC ĐỊNH CHO NHÓM (FIX: ƯU TIÊN CHẾ ĐỘ PIN) ✨
            // Giả định 'isBatteryView' là biến toàn cục xác định chế độ Pin
            if (isBatteryView) {
                // 1. Buộc chọn 'ALL' nếu ở chế độ Pin, ghi đè mọi lựa chọn khác
                selectedNhom = ['ALL'];
            }
            // 2. Chỉ chạy logic mặc định nhóm khi KHÔNG ở chế độ Pin
            else if (selectedNhom.length === 0 || (selectedNhom.length === 1 && selectedNhom.includes('ALL'))) {
                let defaultSelection = [];

                // 1. CHỈ chọn TẤT CẢ NHÓM ĐÃ GÁN (ALL_GROUPED) nếu có nhóm
                if (allGroups.length > 0) {
                    defaultSelection.push('ALL_GROUPED');
                }

                // 2. Nếu không có ALL_GROUPED (ví dụ: chưa tạo nhóm nào), hoặc mảng vẫn rỗng,
                // mặc định chọn ALL (để hiển thị tất cả các điểm PGD/ATM)
                if (defaultSelection.length === 0) {
                    defaultSelection.push('ALL');
                }

                selectedNhom = defaultSelection;
            }


            // --- Khôi phục các lựa chọn đã chọn (Quan trọng) ---
            [...vungSelect.options].forEach(opt => opt.selected = selectedVung.includes(opt.value));
            [...chinhanhSelect.options].forEach(opt => opt.selected = selectedChiNhanh.includes(opt.value));
            [...termidSelect.options].forEach(opt => opt.selected = selectedTermid.includes(opt.value));

            // Khôi phục Hạn Mức
            [...vuothmSelect.options].forEach(opt => opt.selected = selectedVuotHM.includes(opt.value));

            // Khôi phục PL_DGD
            [...pldgdSelect.options].forEach(opt => opt.selected = selectedPLDGD.includes(opt.value));

            // Khôi phục Nhóm (sử dụng biến đã được fix: selectedNhom)
            [...nhomSelect.options].forEach(opt => opt.selected = selectedNhom.includes(opt.value));

            // Đảm bảo [-- Tất cả --] không được chọn nếu đã chọn nhóm cụ thể/tất cả nhóm
            if (selectedNhom.includes('ALL_GROUPED') || selectedNhom.includes('NULL')) {
                Array.from(nhomSelect.options).find(opt => opt.value === 'ALL').selected = false;
            }


            // ✨ THÊM KIỂM TRA ĐỂ KHẮC PHỤC HIỂN THỊ (Sau cùng)
            if (isBatteryView) {
                // Buộc thiết lập thuộc tính 'selected' cho tùy chọn '-- Tất cả --'
                const allOption = Array.from(nhomSelect.options).find(opt => opt.value === 'ALL');
                if (allOption) {
                    allOption.selected = true;
                }
                // Gỡ bỏ thuộc tính 'selected' khỏi các mục khác (phòng trường hợp trình duyệt giữ lại)
                Array.from(nhomSelect.options).filter(opt => opt.value !== 'ALL').forEach(opt => opt.selected = false);
            }


            // Gắn sự kiện `change` (giữ nguyên)
            vungSelect.onchange = () => { updateFilterOptions(); applyFilter(); };
            chinhanhSelect.onchange = () => { updateFilterOptions(); applyFilter(); };
            termidSelect.onchange = () => { updateFilterOptions(); applyFilter(); };
            vuothmSelect.onchange = () => { updateFilterOptions(); applyFilter(); };
            pldgdSelect.onchange = () => { updateFilterOptions(); applyFilter(); };
            nhomSelect.onchange = () => { updateFilterOptions(); applyFilter(); };
            // ✨ FIX: GỌI HÀM LỌC Ở CUỐI HÀM CẬP NHẬT OPTIONS ✨
            applyFilter(); // Dòng này đảm bảo bộ lọc được áp dụng ngay lập tức
        }
        /**
         * (FINAL FIX NHNN TOGGLE + PL_DGD) Áp dụng các bộ lọc theo chế độ Multi-Select.
         */
        function applyFilter() {
            const selVung = document.getElementById('filter-vung');
            const selChiNhanh = document.getElementById('filter-chinhanh');
            const selTermid = document.getElementById('filter-termid');
            const selVuotHM = document.getElementById('filter-vuothm');
            const selPLDGD = document.getElementById('filter-pldgd');
            const selNhom = document.getElementById('filter-nhom');

            // Hàm lấy giá trị đã chọn (trả về ['ALL'] hoặc ['ALL_HM']/['ALL_PLDGD'] nếu không có lựa chọn nào)
            const getSelectedValues = (selectElement) => {
                if (!selectElement) return ['ALL'];
                const selected = Array.from(selectElement.options)
                    .filter(option => option.selected)
                    .map(option => option.value);

                // Thiết lập giá trị mặc định cho các bộ lọc
                if (selected.length === 0) {
                    if (selectElement.id === 'filter-vuothm') return ['ALL_HM'];
                    if (selectElement.id === 'filter-pldgd') return ['ALL_PLDGD'];
                    if (selectElement.id === 'filter-nhom') return ['ALL']; // Mặc định Nhóm là 'ALL' nếu không có gì được chọn
                    return ['ALL'];
                }
                return selected;
            };

            const selectedVung = getSelectedValues(selVung);
            const selectedChiNhanh = getSelectedValues(selChiNhanh);
            const selectedTermid = getSelectedValues(selTermid);
            const selectedVuotHM = getSelectedValues(selVuotHM);
            const selectedPLDGD = getSelectedValues(selPLDGD);
            let selectedNhom = getSelectedValues(selNhom);

            // ✨ FIX BẮT BUỘC: ÉP CHỌN 'ALL' NẾU Ở CHẾ ĐỘ PIN (Ghi đè giá trị từ DOM) ✨
            if (isBatteryView) {
                selectedNhom = ['ALL'];
            }
            // BƯỚC 1: Cập nhật trạng thái hiển thị (p.isVisible) cho TẤT CẢ các điểm
            allPoints.forEach(p => {
                // 1. Lọc Vùng/Chi Nhánh/TermID (Kiểm tra nếu không phải ALL)
                const vungMatch = selectedVung.includes('ALL') || selectedVung.includes(p.vung);
                const chiNhanhMatch = selectedChiNhanh.includes('ALL') || selectedChiNhanh.includes(p.chinhanh);
                const termidMatch = selectedTermid.includes('ALL') || selectedTermid.includes(String(p.id));

                // 2. Lọc NHNN (Bật/Tắt nút Nhnn Toggle)
                let nhnnToggleMatch = !p.nhnn || showNhnnMarkers; // NHNN chỉ ẩn nếu showNhnnMarkers=false

                // 3. Lọc Hạn Mức, PL_DGD, Nhóm (Chỉ áp dụng cho PGD/ATM/TSCN)
                let specificMatch = true;
                if (!p.nhnn) {

                    // Lọc Hạn Mức
                    let vuotHMMatch = selectedVuotHM.includes('ALL_HM');
                    if (!vuotHMMatch) {
                        vuotHMMatch = selectedVuotHM.some(filterValue => {
                            if (filterValue === 'YES') return p.vuotHanMuc === true;
                            if (filterValue === 'NO') return p.vuotHanMuc === false;
                            return false;
                        });
                    }

                    // Lọc PL_DGD (Loại điểm)
                    let pldgdMatch = selectedPLDGD.includes('ALL_PLDGD');
                    if (!pldgdMatch) {
                        pldgdMatch = selectedPLDGD.some(filterValue => {
                            if (filterValue === 'TSCN') return p.isBatteryPoint === true;
                            if (filterValue === 'PGD_ATM') return p.isBatteryPoint === false;
                            return false;
                        });
                    }

                    // Lọc Nhóm
                    let nhomMatch = selectedNhom.includes('ALL');
                    if (!nhomMatch) {
                        nhomMatch = selectedNhom.some(filterValue => {
                            if (filterValue === 'ALL_GROUPED') return (p.groupId !== null && p.groupId !== 'REFERENCE');
                            if (filterValue === 'NULL') return (p.groupId === null);
                            return selectedNhom.includes(String(p.groupId));
                        });
                    }
                    specificMatch = vuotHMMatch && pldgdMatch && nhomMatch;
                }

                // Final check: Tất cả điều kiện phải đúng
                p.isVisible = vungMatch && chiNhanhMatch && termidMatch && nhnnToggleMatch && specificMatch;
            });

            // BƯỚC 2: Cập nhật giao diện
            if (currentPopup) {
                map.closePopup(currentPopup);
                currentPopup = null;
            }

            updateMarkersVisibility();
            /*updateFilterOptions(); // Gọi lại để đồng bộ các dropdown*/
            drawAllGroups();
            updateRankTable();

            console.log(`[FILTER] Đã áp dụng bộ lọc. Số điểm PGD/ATM hiển thị: ${allPoints.filter(p => p.isVisible && !p.nhnn).length}`);
        }
        /**
         * Xử lý sự kiện MOUSE DOWN để BẬT/TẮT trạng thái chọn (Toggle Select)
         * mà không cần giữ phím Ctrl/Cmd.
         */
        function toggleSelection(event) {
            const option = event.target;
            // Đảm bảo chỉ xử lý khi click vào thẻ <option>
            if (option.tagName !== 'OPTION') return;

            // Ngăn chặn hành vi mặc định của trình duyệt 
            event.preventDefault();

            // Đảo ngược trạng thái chọn của mục được click
            option.selected = !option.selected;

            // QUAN TRỌNG: Gọi updateFilterOptions để xây dựng lại các dropdown phụ thuộc (nếu cần),
            // sau đó gọi applyFilter để CẬP NHẬT BẢN ĐỒ.
            const selectElement = option.parentElement;

            // Nếu thay đổi các bộ lọc phụ thuộc (Vùng, Chi nhánh, TermID), phải gọi updateFilterOptions
            if (selectElement.id === 'filter-vung' || selectElement.id === 'filter-chinhanh' || selectElement.id === 'filter-termid') {
                updateFilterOptions();
            }

            // ✨ FIX LỖI: KÍCH HOẠT LỌC SAU KHI THAY ĐỔI LỰA CHỌN ✨
            applyFilter();

            // Sau khi thay đổi lựa chọn nhóm, cần gọi lại updateFilterOptions để khôi phục trạng thái chọn.
            // (Lưu ý: applyFilter() sẽ gọi updateRankTable() và drawAllGroups()).
        }
        /**
         * [FIX LỖI MULTI-SELECT] Hàm thiết lập sự kiện Toggle Selection cho các dropdown có thuộc tính 'multiple'.
         */
        function setupMultiSelectToggle() {
            const filterIds = ['filter-vung', 'filter-chinhanh', 'filter-termid', 'filter-vuothm', 'filter-pldgd', 'filter-nhom'];

            filterIds.forEach(id => {
                const selectElement = document.getElementById(id);

                // Kiểm tra phải là thẻ <select> và có thuộc tính 'multiple'
                if (selectElement && selectElement.hasAttribute('multiple')) {
                    // Loại bỏ các sự kiện cũ trước khi gán sự kiện mới
                    selectElement.removeEventListener('mousedown', toggleSelection);

                    // Gán sự kiện 'mousedown' để giả lập hành vi Ctrl+Click
                    selectElement.addEventListener('mousedown', toggleSelection);
                }
            });
        }
        /**
         * (FINAL FIX VISIBILITY AND TERMID) Cập nhật hiển thị marker dựa trên bộ lọc VÀ chế độ Pin.
         * Áp dụng logic TermID Tooltip trực tiếp.
         */
        function updateMarkersVisibility() {
            // 1. Xóa các Marker khỏi cả hai Layer Group
            pointMarkersLayer.clearLayers();
            nhnnMarkersLayer.clearLayers();
            // 2. Lặp qua TẤT CẢ các điểm để kiểm tra và thêm/xóa chúng
            allPoints.forEach(p => {
                const marker = p.marker;
                const tooltip = p.termIDTooltip;

                const targetLayer = p.nhnn ? nhnnMarkersLayer : pointMarkersLayer;

                let shouldShowMarker = p.isVisible;

                // Logic bổ sung cho Chế độ Pin (chỉ hiển thị TSCN)
                if (!p.nhnn && isBatteryView && !p.isBatteryPoint) {
                    shouldShowMarker = false;
                }
                // 3. ÁP DỤNG HIỂN THỊ MARKER
                if (shouldShowMarker) {
                    if (!targetLayer.hasLayer(marker)) {
                        targetLayer.addLayer(marker);
                    }

                    // 4. QUẢN LÝ TERMID TOOLTIP TRỰC TIẾP
                    if (tooltip) {
                        if (showTermIDLabels) { // Kiểm tra trạng thái nút TermID
                            tooltip.openOn(map);
                        } else {
                            map.closeTooltip(tooltip);
                        }
                    }
                } else {
                    // ẨN MARKER
                    if (targetLayer.hasLayer(marker)) {
                        targetLayer.removeLayer(marker);
                    }

                    // ✨ FIX TRỌNG YẾU: BUỘC ĐÓNG TOOLTIP KHI BỊ LỌC ẨN ✨
                    if (tooltip) {
                        map.closeTooltip(tooltip);
                    }
                }
            });
            // 5. Đảm bảo Marker Cluster refresh sau khi thay đổi (nếu đang bật)
            if (isClusteringEnabled && clusterLayer.options.chunkedLoading) {
                clusterLayer.refreshClusters();
            }
        }
        // --- HẾT CỤM LOGIC LỌC v35 ---

        /**
        
         * (SỬA ĐỔI v48: Ẩn/Hiện nút 🏆 thay vì ẩn/hiện panel)
        
         * (*** SỬA v51: Chỉ hiển thị điểm isHub=true trong xếp hạng NEW ***)
        
         */
        function updateRankTable() {
            const rankTableContainer = document.getElementById('rank-table-container');
            const rankToggleButton = document.getElementById('rank-toggle-btn'); // ID mới
            if (!rankToggleButton) return;
            // (MỚI v39) Không hiển thị bảng xếp hạng khi ở chế độ Pin
            if (isBatteryView) {
                rankTableContainer.style.display = 'none';
                rankToggleButton.style.display = 'none';
                currentRankings = [];
                return;
            }
            // (*** SỬA LỚN NHẤT ***)
            // 1. Lọc ra các điểm HUB CHƯA NHÓM VÀ HIỂN THỊ (Ứng viên TÂM NHÓM MỚI)
            const ungroupedHubPoints = allPoints.filter(p => p.groupId === null && p.isVisible && p.isHub);
            // 2. Lọc ra TẤT CẢ các điểm chưa nhóm VÀ HIỂN THỊ (Ứng viên THÀNH VIÊN)
            const allUngroupedAndVisible = allPoints.filter(p => p.groupId === null && p.isVisible);
            // (SỬA v48) Logic mới: Ẩn/Hiện NÚT BẤM
            if (ungroupedHubPoints.length === 0 && allGroups.length === 0) {
                rankToggleButton.style.display = 'none'; // Ẩn nút
                rankTableContainer.style.display = 'none'; // Tắt panel (phòng hờ)
                currentRankings = [];
                return;
            }
            // (SỬA v48) Hiển thị nút bấm (dạng flex)
            rankToggleButton.style.display = 'flex';
            currentRankings = [];
            // ---- BƯỚC 2: Xếp hạng "TẠO NHÓM MỚI" (CHỈ DÙNG ĐIỂM HUB) ----
            for (const centerCandidate of ungroupedHubPoints) { // <--- SỬ DỤNG HUB POINTS
                let coveredPoints = [];
                let totalDistanceScore = 0;
                // Lặp qua TẤT CẢ các điểm chưa nhóm & hiển thị
                for (const pointToTest of allUngroupedAndVisible) {
                    const distance = centerCandidate.latlng.distanceTo(pointToTest.latlng);
                    if (distance <= RADIUS_METERS) {
                        coveredPoints.push(pointToTest);
                        totalDistanceScore += (distance * distance);
                    }
                }
                if (coveredPoints.length > 0) {
                    currentRankings.push({
                        type: 'NEW',
                        centerId: centerCandidate.id,
                        centerPoint: centerCandidate,
                        coveredPoints: coveredPoints,
                        score: coveredPoints.length,
                        distanceScore: totalDistanceScore,
                        color: PREVIEW_COLOR
                    });
                }
            }
            // ---- BƯỚC 3: Xếp hạng "DI CHUYỂN NHÓM" (Giữ nguyên) ----
            const centerPointIds = new Set(allGroups.map(g => g.centerPoint.id));
            const movablePoints = allPoints.filter(p => p.groupId !== null && p.groupId !== 'REFERENCE' && !centerPointIds.has(p.id) && p.isVisible);
            for (const pointToMove of movablePoints) {
                for (const targetGroup of allGroups) {
                    if (!targetGroup.centerPoint.isVisible) continue;
                    if (pointToMove.groupId !== targetGroup.id) {
                        const distance = pointToMove.latlng.distanceTo(targetGroup.centerPoint.latlng);
                        if (distance <= RADIUS_METERS) {
                            currentRankings.push({
                                type: 'MOVE',
                                pointToMove: pointToMove,
                                targetGroup: targetGroup,
                                score: 0,
                                distanceScore: distance,
                                color: targetGroup.color
                            });
                        }
                    }
                }
            }
            currentRankings.sort((a, b) => {
                if (a.score !== b.score) {
                    return b.score - a.score;
                }
                return a.distanceScore - b.distanceScore;
            });
            renderRankTable();
        }
        /**
        
         * (SỬA ĐỔI v51 & v52) Vẽ Bảng Xếp Hạng - Thêm logic click focus vào điểm tương ứng
        
         */
        function renderRankTable() {
            const rankTableBody = document.getElementById('rank-table-body');
            rankTableBody.innerHTML = '';
            const newActions = currentRankings.filter(r => r.type === 'NEW');
            const moveActions = currentRankings.filter(r => r.type === 'MOVE');
            // 1. Render NEW (Tạo Mới)
            newActions.forEach((item, index) => {
                const row = document.createElement('div');
                row.className = 'rank-item rank-item-new';
                row.dataset.pointId = item.centerId;
                const hubNameHtml = item.centerPoint.tenHub ?
                    `<div><b>HUB:</b> ${item.centerPoint.tenHub}</div>` :
                    '';
                // Gắn sự kiện Click của Row để Focus/Zoom trên bản đồ
                row.addEventListener('click', (e) => {
                    // Chỉ focus nếu không click vào nút button
                    if (e.target.tagName !== 'BUTTON' && e.target.closest('button') === null) {
                        focusOnPoint(item.centerId);
                    }
                });
                row.innerHTML = `
            <b>(Tạo mới) Hạng ${index + 1}</b>
            ${hubNameHtml}
            <div>Tâm ID: ${item.centerId}</div>
            <div>Cover: <b>${item.score}</b> điểm mới</div>
            <button data-center-id="${item.centerId}">
                <i class="fa-solid fa-plus"></i> Tạo Nhóm Mới
            </button>
        `;
                row.addEventListener('mouseenter', (e) => showPreview(item, e.currentTarget));
                row.addEventListener('mouseleave', () => clearPreview());
                row.querySelector('button').addEventListener('click', (e) => {
                    e.stopPropagation();
                    popup_createGroup(item.centerId);
                });
                rankTableBody.appendChild(row);
            });
            // 2. Render MOVE (Di chuyển)
            const groupedMoveActions = new Map();
            moveActions.forEach(item => {
                if (!groupedMoveActions.has(item.pointToMove.id)) {
                    groupedMoveActions.set(item.pointToMove.id, []);
                }
                groupedMoveActions.get(item.pointToMove.id).push(item);
            });
            groupedMoveActions.forEach((actions, pointId) => {
                const pointToMove = actions[0].pointToMove;
                const currentGroup = allGroups.find(g => g.id === pointToMove.groupId);
                const row = document.createElement('div');
                row.className = 'rank-item rank-item-move';
                row.dataset.pointId = pointId;
                // Gắn sự kiện Click của Row để Focus/Zoom trên bản đồ
                row.addEventListener('click', (e) => {
                    // Chỉ focus nếu không click vào nút button
                    if (e.target.tagName !== 'BUTTON' && e.target.closest('button') === null) {
                        focusOnPoint(pointId);
                    }
                });
                let buttonsHTML = '';
                actions.forEach(item => {
                    buttonsHTML += `
                <button data-point-id="${item.pointToMove.id}" data-group-id="${item.targetGroup.id}">
                    <i class="fa-solid fa-arrow-right-arrow-left"></i> Chuyển G${item.targetGroup.groupNumber}
                </button>
            `;
                });
                row.innerHTML = `
            <b>(Di chuyển) Điểm ID: ${pointId}</b>
            <div>Từ: Nhóm ${currentGroup.groupNumber} (Tâm ID: ${currentGroup.centerPoint.id})</div>
            <div class="button-group">
                ${buttonsHTML}
            </div>
        `;
                row.addEventListener('mouseenter', (e) => {
                    showPreview(actions[0], e.currentTarget);
                });
                row.addEventListener('mouseleave', () => {
                    clearPreview();
                });
                row.querySelectorAll('button').forEach((button, index) => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const pointId = e.currentTarget.dataset.pointId;
                        const groupId = parseInt(e.currentTarget.dataset.groupId);
                        movePoint(pointId, groupId);
                    });
                });
                rankTableBody.appendChild(row);
            });
        }
        /**
        
         * (SỬA LỖI ZOOM) Hàm tập trung (Focus) vào một điểm trên bản đồ.
        
         */
        function focusOnPoint(pointId) {
            const point = allPoints.find(p => String(p.id) === String(pointId));
            if (!point || !point.marker) {
                showToast(`Lỗi: Không tìm thấy điểm ID ${pointId} trên bản đồ.`, "error");
                return;
            }
            if (!point.isVisible) {
                showToast(`Điểm ID ${pointId} đang bị ẩn bởi bộ lọc hiện tại.`, "warning");
            }
            // [ĐÃ SỬA] Thay map.flyTo bằng map.panTo để chỉ di chuyển, giữ nguyên zoom
            map.panTo(point.latlng);
            // 2. Mở popup (nếu có)
            if (currentPopup) {
                map.closePopup(currentPopup);
                currentPopup = null;
            }
            // Kích hoạt sự kiện click của marker (như click bằng tay)
            if (point.marker) {
                point.marker.fire('click');
            }
            // [ĐÃ XÓA] Loại bỏ logic zoomToShowLayer để tránh thay đổi zoom
            /*
        
            if (isClusteringEnabled && pointMarkersLayer.hasLayer(clusterLayer)) {
        
                pointMarkersLayer.zoomToShowLayer(point.marker, () => {
        
                    if (point.marker) {
        
                        point.marker.fire('click');
        
                    }
        
                });
        
            }
        
            */
            showToast(`Đã tập trung vào Điểm ID: ${pointId}`, 'info');
        }
        /**
         * (FIX POPUP PIN) Hàm xử lý sự kiện click trên Marker.
         * Đảm bảo Popup Pin hiển thị cho TẤT CẢ Marker Pin khi ở chế độ Battery View.
         */
        function handleMarkerClick(pointData) {

            // ==============================================================
            // ✨ LOG MỚI: DỮ LIỆU ĐIỂM VÀ TRẠNG THÁI HIỆN TẠI KHI CLICK ✨
            console.log("--- MARKER CLICK DEBUG ---");
            console.log(`Điểm Click: ID=${pointData.id}, NHNN=${pointData.nhnn}, TSCN=${pointData.isBatteryPoint}`);
            console.log(`Trạng thái: isBatteryView=${isBatteryView}, groupId=${pointData.groupId}`);
            console.log(`Dữ liệu Hạn mức: Tồn Quỹ=${pointData.tonQuy}, Hạn Mức=${pointData.hanMuc}`);
            console.log("--------------------------");
            // ==============================================================

            if (currentPopup) {
                map.closePopup(currentPopup);
                currentPopup = null;
            }

            let shouldZoom = false;

            if (pointData.nhnn) {
                // === XỬ LÝ ĐIỂM NHNN (Tham Chiếu) ===
                console.log("[CLICK LOG] Kích hoạt chế độ NHNN.");

                let html = `<div class="action-popup-header">Điểm Tham Chiếu</div>
                                     <div class="action-popup-buttons">
                                         <div class="action-popup-info" style="text-align: center; padding: 10px 0;">
                                             <img src="${pointData.marker.options.icon.options.iconUrl}" style="width: 30px; height: 30px; margin: 0 auto 5px auto;"><br>
                                             <b>${pointData.id}</b><br>(Ngân hàng Nhà nước)
                                         </div>
                                     </div>`;

                currentPopup = L.popup({ closeButton: true, minWidth: 220, className: 'action-popup' })
                    .setLatLng(pointData.latlng)
                    .setContent(html)
                    .openOn(map);

                shouldZoom = true;

            } else if (isBatteryView) {
                // === XỬ LÝ CHẾ ĐỘ PIN (Chế độ Hạn Mức/Tồn Quỹ) ===
                console.log("[CLICK LOG] Kích hoạt chế độ Pin/Hạn Mức.");

                const tonQuy = pointData.tonQuy || 0;
                const hanMuc = pointData.hanMuc || 0;

                let html = `<div class="action-popup-header">${pointData.id}</div>
                                     <div class="action-popup-info battery-info-popup">
                                         <b>Tên Hub:</b> ${pointData.tenHub || 'PGD/ATM'}<br>
                                         <b>Phân loại:</b> ${pointData.isBatteryPoint ? 'TSCN' : 'PGD/ATM'}<br>
                                         <hr style="margin: 5px 0;">
                                         <b>Tồn quỹ:</b> ${formatFullNumber(tonQuy)}<br>
                                         <b>Hạn mức:</b> ${formatFullNumber(hanMuc)}<br>
                                         <b>Trạng thái:</b> ${pointData.vuotHanMuc && tonQuy > hanMuc ?
                        '<span style="color: red; font-weight: bold;">Vượt Hạn Mức</span>' :
                        'Trong Hạn Mức'}
                                     </div>`;

                currentPopup = L.popup({ closeButton: true, minWidth: 220, className: 'action-popup' })
                    .setLatLng(pointData.latlng)
                    .setContent(html)
                    .openOn(map);

                shouldZoom = pointData.isBatteryPoint;

            } else {
                // === XỬ LÝ POPUP HÀNH ĐỘNG (CHẾ ĐỘ NHÓM/BÌNH THƯỜNG) ===
                console.log("[CLICK LOG] Kích hoạt chế độ Nhóm/Hành động.");

                let currentGroupId = null;
                const pointName = pointData.id;

                for (const name in groups) {
                    if (groups[name].pointIds.includes(pointData.id)) {
                        currentGroupId = groups[name].id;
                        break;
                    }
                }

                const content = createActionPopupContent(pointData.id, currentGroupId, pointName);

                currentPopup = L.popup({ closeButton: true, minWidth: 220, className: 'action-popup' })
                    .setLatLng(pointData.latlng)
                    .setContent(content)
                    .openOn(map);

                shouldZoom = (currentGroupId !== null);
            }

            // Chỉ zoom khi cờ shouldZoom = true
            if (shouldZoom) {
                const currentZoom = map.getZoom();
                map.flyTo(pointData.latlng, Math.max(currentZoom, 16));
            }
        }
        /**
        
         * (SỬA VỊ TRÍ) Hàm hiển thị vòng tròn 30km và Tooltip Thống Kê Chi Tiết.
        
         * Tooltip được đặt gần rìa vòng tròn bằng cách sử dụng L.tooltip() tại một vị trí cố định.
        
         */
        function showPreview(item, rowElement = null) {
            clearPreview();
            const centerPoint = (item.type === 'MOVE') ? item.targetGroup.centerPoint : item.centerPoint;
            if (!centerPoint) return;
            const color = item.color;
            // 1. Vẽ vòng tròn 30km
            L.circle(centerPoint.latlng, {
                radius: RADIUS_METERS,
                color: color,
                weight: 3.5,
                opacity: 0.95,
                fillColor: color,
                fillOpacity: 0.5,
                dashArray: '10, 10'
            }).addTo(previewLayer);
            // 2. TẠO TOOLTIP THỐNG KÊ CHI TIẾT (Chỉ cho loại 'NEW' - Tạo nhóm mới)
            if (item.type === 'NEW' && item.tooltipContent) {
                // ✨ LOGIC ĐẨY TOOLTIP SANG PHẢI (VỊ TRÍ CỐ ĐỊNH THEO PIXEL) ✨
                // Tăng Offset lên 250px để Tooltip nằm hẳn ngoài vòng tròn (tránh bị che)
                const PIXEL_OFFSET = L.point(250, 0);
                L.tooltip({
                    permanent: true,
                    direction: 'right', // Không quan trọng vì dùng offset lớn
                    className: 'distance-tooltip',
                    offset: PIXEL_OFFSET, // <-- ÁP DỤNG OFFSET LỚN
                    opacity: 0.95,
                    pane: 'popupPane'
                })
                    .setLatLng(centerPoint.latlng) // Vẫn gắn vào tọa độ tâm
                    .setContent(item.tooltipContent)
                    .addTo(previewLayer);
            }
            // 3. Logic cho chế độ MOVE / Tô màu điểm (Giữ nguyên)
            if (item.type === 'MOVE') {
                const pointToMove = item.pointToMove;
                const targetGroup = item.targetGroup;
                // 3a. Làm mờ tất cả điểm PGD/ATM đang hiển thị
                allPoints.filter(p => p.isVisible && !p.nhnn).forEach(p => {
                    if (p.marker && p.marker._map) { p.marker.setOpacity(0.3); }
                });
                // 3b. Làm nổi bật tâm và điểm sắp chuyển
                if (!targetGroup.centerPoint.nhnn && targetGroup.centerPoint.marker && targetGroup.centerPoint.marker._map) {
                    targetGroup.centerPoint.marker.setOpacity(1.0);
                }
                if (!pointToMove.nhnn && pointToMove.marker && pointToMove.marker._map) {
                    pointToMove.marker.setOpacity(1.0);
                }
            } else { // Xử lý làm mờ/sáng cho chế độ NEW
                const coveredIds = new Set(item.coveredPoints.map(p => p.id));
                // Làm mờ các điểm đã nhóm
                allPoints.filter(p => p.groupId !== null && p.isVisible && !p.nhnn).forEach(p => {
                    if (p.marker && p.marker._map) { p.marker.setOpacity(0.3); }
                });
                // Sáng điểm tâm (centerPoint) và các điểm được bao phủ
                allPoints.filter(p => p.groupId === null && p.isVisible && !p.nhnn).forEach(p => {
                    if (p.marker && p.marker._map) {
                        if (p.id === centerPoint.id || coveredIds.has(p.id)) {
                            p.marker.setOpacity(1.0);
                        } else {
                            p.marker.setOpacity(0.3); // Mờ các điểm không được bao phủ
                        }
                    }
                });
            }
        }
        /**
    
         * (SỬA ĐỔI v41: Thêm kiểm tra an toàn cho gom cụm)
    
         */
        function clearPreview() {
            previewLayer.clearLayers();
            allPoints.filter(p => p.isVisible && p.marker).forEach(p => { // (SỬA v41) Thêm check p.marker
                // Chỉ reset opacity nếu marker đang hiển thị
                if (p.marker._map) {
                    p.marker.setOpacity(1.0);
                }
                if (p.marker._icon) {
                    p.marker._icon.classList.remove('point-move-preview');
                }
                // Logic reset icon này đã an toàn, 
                // vì L.markerClusterGroup sẽ gọi lại icon function khi cần
                if (p.nhnn) { // Điểm NHNN
                    p.marker.setIcon(createNHNNIcon());
                } else if (p.groupId === null) { // Điểm PGD chưa nhóm
                    // (SỬA v37)
                    p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());
                } else if (p.groupId !== 'REFERENCE') { // Điểm PGD đã vào nhóm
                    const group = allGroups.find(g => g.id === p.groupId);
                    if (group) {
                        if (p.id === group.centerPoint.id) {
                            p.marker.setIcon(createCenterPointIcon(group.color));
                        } else {
                            // (SỬA v37)
                            p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());
                        }
                    }
                }
            });
        }
        /**
         * (FIX LỖI KINH DOANH: CHẶN HUB LÀM VỆ TINH)
         * Tạo nhóm mới thủ công, sử dụng bán kính linh hoạt hiện tại (RADIUS_METERS).
         */
        function popup_createGroup(pointId) {
            if (currentPopup) {
                map.closePopup(currentPopup);
                currentPopup = null;
            }
            const centerPoint = allPoints.find(p => String(p.id) === String(pointId));
            if (!centerPoint) {
                showToast(`Lỗi: Không tìm thấy điểm ID ${pointId}.`, "error");
                return;
            }

            // Tìm các điểm CHƯA NHÓM nằm trong bán kính
            const coveredPoints = allPoints.filter(p => {
                if (p.id === centerPoint.id || p.nhnn) return false;
                if (p.groupId !== null && p.groupId !== 'REFERENCE') return false;

                // ✨ ĐIỀU KIỆN SỬA LỖI: CHẶN ĐIỂM ĐƯỢC ĐÁNH DẤU LÀ HUB KHÔNG THỂ LÀ VỆ TINH ✨
                if (p.isHub) return false;
                const distance = centerPoint.latlng.distanceTo(p.latlng);
                return distance <= RADIUS_METERS;
            });

            const newGroupNumber = allGroups.length + 1;
            const newGroupColor = GROUP_COLORS[allGroups.length % GROUP_COLORS.length];
            const newGroupId = `G_${newGroupNumber}`;

            const pointsInGroup = [centerPoint, ...coveredPoints];

            const newGroup = {
                id: newGroupId,
                centerPoint: centerPoint,
                fixedRadiusMeters: RADIUS_METERS,
                fixedRadiusKm: currentRadiusKm,
                points: pointsInGroup,
                color: newGroupColor,
                groupNumber: newGroupNumber,
                routingControls: [],
                polylineCache: {}
            };
            allGroups.push(newGroup);

            centerPoint.groupId = newGroupId;
            const coveredIds = new Set(coveredPoints.map(p => p.id));
            allPoints.forEach(p => {
                if (coveredIds.has(p.id)) {
                    p.groupId = newGroupId;
                }
            });

            const pointIdsInGroup = pointsInGroup.map(p => p.id);
            groups[`NHÓM ${newGroupNumber}`] = {
                id: newGroupId,
                color: newGroupColor,
                pointIds: pointIdsInGroup
            };

            drawAllGroups();
            updateRankTable();
            updateFilterOptions();

            const message = (coveredPoints.length > 0)
                ? `Đã tạo thành công Nhóm ${newGroupNumber} với ${coveredPoints.length} điểm.`
                : `Đã tạo Nhóm mới. Bán kính ${currentRadiusKm} km không bao phủ thêm điểm vệ tinh nào.`;
            Toastify({
                text: message,
                className: coveredPoints.length > 0 ? "custom-toast success" : "custom-toast warning",
            }).showToast();
        }

        function popup_addPointToGroup(pointId, targetGroupId) {
            const pointToAdd = allPoints.find(p => String(p.id) === String(pointId));
            const targetGroup = allGroups.find(g => g.id === targetGroupId);
            if (!pointToAdd || !targetGroup) {
                showToast("Lỗi: Không tìm thấy điểm hoặc nhóm", "error");
                return;
            }
            targetGroup.points.push(pointToAdd);
            pointToAdd.groupId = targetGroupId;
            if (currentPopup) map.closePopup();
            updateRankTable();
            drawAllGroups();
            updateFilterOptions(); // (MỚI v40)
            showToast(`Đã thêm Điểm ${pointId} vào Nhóm ${targetGroup.groupNumber}`, 'success');
        }
        /**
        
         * (SỬA LỖI HOÀN CHỈNH) Hàm chuyển điểm từ Bảng Xếp Hạng.
        
         * Chỉ gọi hàm chính movePointToGroup để đảm bảo đồng bộ hóa dữ liệu.
        
         */
        function movePoint(pointId, newGroupId) {
            // Gọi hàm chính (đã có logic xử lý đồng bộ dữ liệu và loại trừ lẫn nhau)
            movePointToGroup(pointId, newGroupId);
            // Lưu ý: Các hàm updateRankTable, drawAllGroups, updateFilterOptions 
            // đã được gọi bên trong movePointToGroup.
        }
        /**
         * (SỬA LỖI FINAL BÁN KÍNH VÀ PIN MODE) Vẽ các nhóm đã lưu. 
         * KHÔNG VẼ VÒNG TRÒN, LINE, HAY TOOLTIP KHOẢNG CÁCH khi ở chế độ Pin.
         * CHUYỂN TÂM HUB SANG ICON PIN khi ở chế độ Pin.
         */
        function drawAllGroups() {
            // 1. Dùng clearAnalysisVisuals để reset Icon và gỡ các tooltip cũ (kể cả tooltip nhóm)
            clearAnalysisVisuals();
            let bounds = L.latLngBounds();
            const allNHNNPoints = allPoints.filter(p => p.nhnn && p.isVisible);

            allGroups.forEach(group => {
                const { centerPoint, points, color, groupNumber } = group;

                if (!centerPoint.isVisible) { return; }

                const groupRadius = (isFinite(group.fixedRadiusMeters) && group.fixedRadiusMeters > 0)
                    ? Number(group.fixedRadiusMeters)
                    : RADIUS_METERS;

                // 2. VẼ PHÂN TÍCH (CHỈ KHI KHÔNG Ở CHẾ ĐỘ PIN)
                if (!isBatteryView) {
                    // Vẽ vòng tròn phân tích
                    L.circle(centerPoint.latlng, {
                        radius: groupRadius,
                        color: color,
                        weight: 3,
                        opacity: 0.9,
                        fillColor: color,
                        fillOpacity: 0.25
                    }).addTo(analysisLayer);

                    // Vẽ line từ TÂM NHÓM đến các NHNN lân cận
                    allNHNNPoints.forEach(nhnnPoint => {
                        const distance = centerPoint.latlng.distanceTo(nhnnPoint.latlng);
                        if (distance <= groupRadius) {
                            const distanceInKm = (distance / 1000).toFixed(2);
                            const labelContent = `~ ${distanceInKm} km`;
                            const line = L.polyline([centerPoint.latlng, nhnnPoint.latlng], { color: NHNN_PREVIEW_LINE_COLOR, weight: 2, opacity: 0.9, dashArray: '8, 4', className: 'animated-route-line' }).addTo(analysisLayer);
                            if (showDistanceLabels) { line.bindTooltip(labelContent, { permanent: true, direction: 'center', className: 'distance-tooltip', offset: [0, -8] }); }
                        }
                    });
                }

                bounds.extend(centerPoint.latlng);
                const visiblePointsInGroup = points.filter(p => p.isVisible);

                points.forEach(pointData => {
                    if (!pointData.isVisible) { return; }
                    bounds.extend(pointData.latlng);

                    if (pointData.id === centerPoint.id && !isBatteryView) {
                        // CHẾ ĐỘ NHÓM BÌNH THƯỜNG: Vẽ Tâm Nhóm (Ngôi sao) và tooltip nhóm
                        pointData.marker.setIcon(createCenterPointIcon(color));
                        const tooltipMessage = `${pointData.id} (${visiblePointsInGroup.length} điểm)`;

                        // Gắn/Mở Tooltip Nhóm MỚI
                        const centerTooltip = pointData.marker.bindTooltip(tooltipMessage, {
                            permanent: true,
                            direction: 'bottom',
                            offset: L.point(0, 10),
                            className: 'distance-tooltip distance-tooltip-compact'
                        }).openTooltip();

                        centerTooltip.on('add', function () {
                            const container = this.getElement();
                            if (container) {
                                container.style.borderColor = color;
                                // Gắn lại sự kiện click cho tooltip
                                L.DomEvent.on(container, 'click', (e) => { L.DomEvent.stopPropagation(e); handleMarkerClick(pointData); });
                            }
                        });

                    } else {
                        // LÀ VỆ TINH HOẶC LÀ TÂM TRONG CHẾ ĐỘ PIN (Icon đã được reset trong clearAnalysisVisuals)
                        // ✨ FIX: THIẾT LẬP ICON PIN CHO TÂM HUB KHI Ở CHẾ ĐỘ PIN ✨
                        if (isBatteryView && pointData.id === centerPoint.id) {
                            // ✅ SỬA: Bắt buộc truyền đối tượng pointData
                            pointData.marker.setIcon(createBatteryIcon(pointData));
                        }
                        // END FIX
                        // Nếu không ở chế độ Pin, vẽ line kết nối và tooltip khoảng cách
                        if (!isBatteryView && pointData.id !== centerPoint.id) { // Chỉ vẽ line cho vệ tinh
                            calculateAndDrawLine(centerPoint.latlng, pointData.latlng, pointData, group);
                        }
                    }
                });
            });
        }
        /**
         * (FIX TRỌNG YẾU: TÂM HUB NGÔI SAO) Xóa toàn bộ đường phân tích (vòng tròn, polyline).
         * Đảm bảo reset icon TÂM về icon PGD/Pin gốc và unbind tooltip nhóm.
         */
        function clearAnalysisVisuals() {
            analysisLayer.clearLayers();

            if (measureLayer) {
                measureLayer.clearLayers();
            }

            allPoints.filter(p => p.marker).forEach(p => {
                // --- 1. RESET ICON TÂM/VỆ TINH ---
                if (p.nhnn) {
                    p.marker.setIcon(createNHNNIcon());
                } else {
                    // ✅ SỬA: Bắt buộc truyền đối tượng p (pointData)
                    p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());
                }

                // --- 2. GỠ TOOLTIP ĐƯỢC GẮN BỞI drawAllGroups() (Tooltips nhóm/khoảng cách) ---
                // unbindPopup và unbindTooltip sẽ gỡ bỏ tất cả Popup và Tooltip được gán động, 
                // nhưng TermID tooltip (được lưu trong p.termIDTooltip) sẽ được giữ lại.
                p.marker.unbindPopup();
                p.marker.unbindTooltip();

                // --- 3. KIỂM SOÁT TERMID TOOLTIP (Ngôi sao không bị gỡ) ---
                if (p.termIDTooltip) {
                    if (showTermIDLabels && p.isVisible) {
                        p.termIDTooltip.openOn(map);
                    } else {
                        map.closeTooltip(p.termIDTooltip);
                    }
                }
            });
        }

        /**
    
         * (SỬA v48) Xóa logic của hàm ClearAll (vì nút đã bị xóa)
    
         * Giữ lại hàm rỗng để tránh lỗi nếu có code cũ gọi
    
         */
        function clearAll() {
            showToast("Chức năng Xóa Tất Cả đã bị tắt.", "warning");
            // (Toàn bộ logic xóa đã được gỡ bỏ)
        }
        /**
         * (FIXED: NHÃN KM ẨN KHI NÚT TẮT) Hàm Hybrid: Vẽ chim bay/Lái xe (Ưu tiên dùng Cache) và gán Tooltip.
         * Đảm bảo nhãn khoảng cách chỉ được gắn/mở khi showDistanceLabels = true.
         */
        function calculateAndDrawLine(startLatLng, endLatLng, pointData, group) {
            const { color, groupNumber } = group;
            const endMarker = pointData.marker;

            // Tính khoảng cách Chim Bay (dùng cho Tooltip chung)
            const distanceInKm = (startLatLng.distanceTo(endLatLng) / 1000).toFixed(2);

            let tooltipContent;
            let isCached = false;

            if (isBirdMode) {
                // === CHẾ ĐỘ CHIM BAY (Bird Mode) ===
                L.polyline([startLatLng, endLatLng], {
                    color: color,
                    opacity: 1.0,
                    weight: 5,
                    dashArray: '10, 10',
                    className: 'animated-route-line'
                }).addTo(analysisLayer);

                tooltipContent = `~ ${distanceInKm} km`;
            } else {
                // === CHẾ ĐỘ LÁI XE (Car Mode) - ƯU TIÊN DÙNG CACHE ===
                const cachedJson = group.polylineCache[pointData.id];

                if (cachedJson) {
                    // ... (vẽ Polyline từ cache giữ nguyên) ...
                    tooltipContent = `<span class="group-name">${pointData.id}</span>🚗 ${distanceInKm} km (cached)`;
                    isCached = true;
                } else {
                    tooltipContent = `<span class="group-name">${pointData.id}</span>... <i class="fa-solid fa-spinner loading-spinner"></i>`;

                    routingQueue.push({
                        startLatLng, endLatLng, endMarker, pointData, color, groupNumber, group
                    });
                }
            }

            // (*** LOGIC GÁN TOOLTIP CHO MARKER - CẦN KIỂM TRA showDistanceLabels ***)
            if (!isBatteryView) { // Nếu không ở chế độ Pin

                // Cần đảm bảo Tooltip khoảng cách CŨ (nếu có) bị hủy
                // Nếu Tooltip đang mở/gắn, nó sẽ được unbind trước
                endMarker.unbindTooltip();

                // ✨ FIX TRỌNG YẾU: CHỈ GẮN/MỞ NHÃN KHI NÚT NHÃN KM ĐANG BẬT ✨
                if (showDistanceLabels) { // <-- KIỂM TRA TRẠNG THÁI CỦA NÚT NHÃN KM
                    const tooltip = endMarker.bindTooltip(tooltipContent, {
                        permanent: true,
                        direction: 'bottom',
                        className: 'distance-tooltip',
                        offset: L.point(0, 10)
                    }).openTooltip();

                    tooltip.on('add', function () {
                        const container = this.getElement();
                        if (container) {
                            container.style.borderColor = '#ccc';
                            L.DomEvent.on(container, 'click', (e) => {
                                L.DomEvent.stopPropagation(e);
                                handleMarkerClick(pointData);
                            });
                        }
                    });
                }
            }

            // Chỉ chạy hàng đợi nếu đang ở chế độ Lái xe VÀ không sử dụng cache
            if (!isBirdMode && !isCached) {
                processRoutingQueue();
            }
        }
        /**
        
         * (ĐÃ SỬA LỖI REMOVELAYER) Xử lý hàng đợi định tuyến, từng bước một.
        
         * @param {boolean} [shouldExport=true] - Có nên gọi exportGroupsData() sau khi hoàn thành không.
        
         */
        async function processRoutingQueue(shouldExport = true) {
            // 1. Kiểm tra trạng thái an toàn
            if (isBirdMode) {
                // Đảm bảo không còn tác vụ nào chạy khi ở chế độ chim bay
                isProcessingQueue = false;
                return;
            }
            if (isProcessingQueue || routingQueue.length === 0) {
                return;
            }
            isProcessingQueue = true;
            const task = routingQueue.shift();
            // === LẤY THAM SỐ ===
            const { startLatLng, endLatLng, endMarker, pointData, color, groupNumber, group } = task;
            if (!group || !pointData || !endMarker) {
                console.error("Lỗi: Tác vụ định tuyến bị thiếu dữ liệu quan trọng.");
                isProcessingQueue = false;
                processRoutingQueue(shouldExport);
                return;
            }
            const cacheKey = pointData.id;
            // 2. Khởi tạo Routing Control
            const router = L.Routing.control({
                waypoints: [startLatLng, endLatLng],
                show: false,
                addWaypoints: false,
                createMarker: () => null,
                lineOptions: {
                    addWaypoints: false,
                    styles: [{
                        color: color,
                        opacity: 1.0,
                        weight: 5,
                        dashArray: '10, 10',
                        className: 'animated-route-line'
                    }]
                }
            }).addTo(map);
            // Lưu router vào mảng controls của nhóm
            group.routingControls.push(router);
            // === HÀM KẾT THÚC AN TOÀN ===
            const finishTask = async () => {
                // Gỡ Router khỏi Map một cách an toàn
                try {
                    map.removeControl(router);
                    // Xóa router khỏi mảng quản lý của nhóm để tránh xóa lần nữa
                    const index = group.routingControls.indexOf(router);
                    if (index > -1) {
                        group.routingControls.splice(index, 1);
                    }
                } catch (e) {
                    // console.warn("Lỗi an toàn khi removeControl:", e); // Gỡ lỗi
                }
                await new Promise(resolve => setTimeout(resolve, ROUTING_DELAY_MS));
                isProcessingQueue = false;
                processRoutingQueue(shouldExport);
            };
            // =============================

            router.on('routesfound', function (e) {
                // --- LƯU CACHE POLYLINE ---
                const route = e.routes[0];
                const coordinates = route.coordinates.map(c => ({ lat: c.lat, lon: c.lng }));
                group.polylineCache[cacheKey] = JSON.stringify(coordinates);
                if (shouldExport) {
                    exportGroupsData();
                }
                // -------------------------
                // Cập nhật tooltip
                const isMarkerStillOnMap = pointMarkersLayer.hasLayer(endMarker) || nhnnMarkersLayer.hasLayer(endMarker);
                if (pointData.isVisible && endMarker && isMarkerStillOnMap && !isBatteryView && showDistanceLabels) {
                    const distanceInKm = (route.summary.totalDistance / 1000).toFixed(2);
                    // [ĐÃ SỬA] Nội dung Tooltip: TermID + km (Đã tính)
                    const tooltipContent = `<span class="group-name" style="color: ${color};">${pointData.id}</span>🚗 ${distanceInKm} km`;
                    endMarker.unbindTooltip();
                    const newTooltip = endMarker.bindTooltip(tooltipContent, {
                        permanent: true, direction: 'top', className: 'distance-tooltip'
                    }).openTooltip();
                    newTooltip.on('add', function () {
                        const container = this.getElement();
                        if (container) {
                            container.style.borderColor = color;
                            L.DomEvent.on(container, 'click', (e) => {
                                L.DomEvent.stopPropagation(e);
                                handleMarkerClick(pointData);
                            });
                        }
                    });
                }
                finishTask();
            });
            router.on('routingerror', function (e) {
                console.error(`Lỗi định tuyến cho điểm ${pointData.id}:`, e.message);
                showToast(`Lỗi định tuyến cho ${pointData.id}.`, "error");
                // Vẽ đường chim bay để thay thế
                L.polyline([startLatLng, endLatLng], {
                    color: color,
                    opacity: 0.5,
                    weight: 3,
                    dashArray: '5, 5'
                }).addTo(analysisLayer);
                finishTask();
            });
        }

        /**
    
         * Hàm hiển thị thông báo (Toastify)
    
         */
        function showToast(message, type = 'info') {
            const typeClasses = { info: 'info', success: 'success', warning: 'warning', error: 'error' };
            const iconMap = { info: 'ℹ️', success: '✅', warning: '⚠️', 'error': '❌' };
            Toastify({
                text: `${iconMap[type]} ${message}`,
                duration: 2500,
                gravity: "bottom",
                position: "right",
                className: `custom-toast ${typeClasses[type]} text-white`
            }).showToast();
        }
        function highlightRankItem(pointId) {
            const newRow = document.querySelector(`.rank-item-new[data-point-id="${pointId}"]`);
            if (newRow) {
                newRow.classList.add('rank-item-highlight');
                newRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
            const moveRow = document.querySelector(`.rank-item-move[data-point-id="${pointId}"]`);
            if (moveRow) {
                moveRow.classList.add('rank-item-highlight');
                moveRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        function clearRankItemHighlight() {
            document.querySelectorAll('.rank-item-highlight').forEach(row => {
                row.classList.remove('rank-item-highlight');
            });
        }
        /**
    
         * (SỬA v38) Cập nhật style cho nút
    
         */
        function toggleRoutingMode() {
            isBirdMode = !isBirdMode;
            const button = document.getElementById('routing-toggle-btn');
            if (currentPopup) map.closePopup(currentPopup);
            if (isBirdMode) {
                button.innerHTML = '<i class="fa-solid fa-feather w-4 h-4"></i> <span class="button-text">Đường chim Bay</span>'; // Sửa chữ v48
                button.classList.add('bird-mode');
                button.classList.remove('car-mode');
                routingQueue = [];
                isProcessingQueue = false;
                showToast("Đã BẬT: Chế độ Chim Bay (Nhanh)", 'warning');
            } else {
                button.innerHTML = '<i class="fa-solid fa-car w-4 h-4"></i> <span class="button-text">Lái xe (Chậm)</span>'; // Sửa chữ v48
                button.classList.add('car-mode');
                button.classList.remove('bird-mode');
                showToast("Đã BẬT: Chế độ Lái xe (Chậm)", 'info');
            }
            drawAllGroups();
        }
        /**
    
         * (MỚI v42) Hàm Bật/Tắt tính năng Gom Cụm (Clustering)
    
         */
        function toggleClustering() {
            // 1. Đảo ngược trạng thái
            isClusteringEnabled = !isClusteringEnabled;
            const button = document.getElementById('cluster-toggle-btn');
            if (currentPopup) map.closePopup(currentPopup);
            // 2. Xóa layer CŨ khỏi bản đồ
            map.removeLayer(pointMarkersLayer);
            // 3. (Quan trọng) Cập nhật con trỏ pointMarkersLayer
            if (isClusteringEnabled) {
                pointMarkersLayer = clusterLayer; // Trỏ sang LỚP GOM CỤM
                // Cập nhật nút
                button.innerHTML = '<i class="fa-solid fa-boxes-stacked w-4 h-4"></i> <span class="button-text">Gom Cụm (Bật)</span>';
                button.classList.add('cluster-on');
                button.classList.remove('cluster-off');
                showToast("Đã BẬT: Gom Cụm", 'info');
            } else {
                pointMarkersLayer = standardLayer; // Trỏ sang LỚP TIÊU CHUẨN
                // Cập nhật nút
                button.innerHTML = '<i class="fa-solid fa-braille w-4 h-4"></i> <span class="button-text">Gom Cụm (Tắt)</span>';
                button.classList.add('cluster-off');
                button.classList.remove('cluster-on');
                showToast("Đã TẮT: Gom Cụm (Hiển thị tất cả)", 'warning');
            }
            // 4. Thêm layer MỚI vào bản đồ
            map.addLayer(pointMarkersLayer);
            // 5. Yêu cầu vẽ lại các marker
            updateMarkersVisibility();
            // 6. Vẽ lại các đường line/vòng tròn
            drawAllGroups();
        }

        /**
    
         * (MỚI v40) Hàm tải và vẽ viền GeoJSON của Việt Nam
    
         */
        function loadVietnamBorder() {
            // Đường dẫn đến file GeoJSON (bao gồm Hoàng Sa, Trường Sa)
            // Nguồn: https://github.com/thangdng/vietnam-boundary
            const geoJsonUrl = 'https://raw.githubusercontent.com/thangdng/vietnam-boundary/master/vietnam-with-islands.geojson';
            // Tùy chỉnh style cho viền
            const borderStyle = {
                "color": "#00008B",  // (Bạn có thể đổi màu viền ở đây, vd: "#FF0000" cho màu đỏ)
                "weight": 2,        // Độ dày của viền
                "opacity": 0.8,
                "fillOpacity": 0.0, // Quan trọng: Không tô màu nền
                "pane": "borderPane" // (MỚI v40) Vẽ lên pane đã tạo
            };
            fetch(geoJsonUrl)
                .then(response => response.json())
                .then(data => {
                    L.geoJSON(data, {
                        style: borderStyle
                    }).addTo(map); // Thêm vào bản đồ
                })
                .catch(error => {
                    console.error('Lỗi khi tải viền bản đồ Việt Nam:', error);
                    showToast("Không tải được viền bản đồ VN", "error");
                });
        }
        function toggleBatteryView() {
            // ✨ HIỂN THỊ LOADING SCREEN TRƯỚC KHI XỬ LÝ ✨
            showLoadingScreen('https://lottie.host/583a54b3-d5f0-47a3-83f9-7156f4d2f00a/toggle_mode.lottie', 'Đang chuyển chế độ Pin/Ghim...');

            const button = document.getElementById('battery-toggle-btn');
            const rankButton = document.getElementById('rank-toggle-btn');
            const autoGroupButton = document.getElementById('auto-group-btn');
            const routingButton = document.getElementById('routing-toggle-btn');
            const labelsButton = document.getElementById('labels-toggle-btn');
            const saveButton = document.getElementById('save-groups-btn');

            // Tăng tốc độ chuyển đổi bằng cách chạy các tác vụ nặng (filter/draw) ngay lập tức

            isBatteryView = !isBatteryView;

            // Đóng Popup hiện tại
            if (currentPopup) {
                map.closePopup(currentPopup);
                currentPopup = null;
            }

            if (isBatteryView) {
                button.innerHTML = '<i class="fa-solid fa-map-pin w-4 h-4"></i> <span class="button-text">Chế độ Ghim</span>';
                button.classList.add('battery-mode');
                button.classList.remove('pin-mode');

                clearAnalysisVisuals();
                if (measureLayer) measureLayer.clearLayers();

                // ẨN CÁC NÚT KHI Ở CHẾ ĐỘ PIN
                const rankPanel = document.getElementById('rank-table-container');
                if (rankPanel) rankPanel.style.display = 'none';

                if (rankButton) rankButton.style.display = 'none';
                if (autoGroupButton) autoGroupButton.style.display = 'none';
                if (routingButton) routingButton.style.display = 'none';
                if (labelsButton) labelsButton.style.display = 'none';
                if (saveButton) saveButton.style.display = 'none';

                showToast("Đã BẬT: Chế độ Pin", 'info');

            } else {
                button.innerHTML = '<i class="fa-solid fa-battery-half w-4 h-4"></i> <span class="button-text">Chế độ Pin</span>';
                button.classList.add('pin-mode');
                button.classList.remove('battery-mode');

                // HIỆN LẠI CÁC NÚT KHI THOÁT CHẾ ĐỘ PIN
                if (rankButton) rankButton.style.display = 'flex';
                if (autoGroupButton) autoGroupButton.style.display = 'flex';
                if (routingButton) routingButton.style.display = 'flex';
                if (labelsButton) labelsButton.style.display = 'flex';
                if (saveButton) saveButton.style.display = 'flex';

                showToast("Đã TẮT: Chế độ Pin", 'warning');
            }

            // GỌI APPLY FILTER / DRAW ALL GROUPS để cập nhật bản đồ ngay lập tức
            updateFilterOptions();
            applyFilter();

            // ✨ ẨN LOADING SAU KHI XỬ LÝ HOÀN TẤT (Dùng setTimeout để đảm bảo UI/DOM cập nhật xong) ✨
            setTimeout(() => {
                hideLoadingScreen();
            }, 300);
        }
        // *** Tự động gọi hàm tải dữ liệu sau khi map khởi tạo ***
        loadPreloadedData();

        // --- LOGIC ĐIỀU KHIỂN BỘ LỌC BẢN ĐỒ ---
        const tilePane = document.querySelector('.leaflet-tile-pane');
        const grayscaleSlider = document.getElementById('grayscale-slider');
        const brightnessSlider = document.getElementById('brightness-slider');
        const contrastSlider = document.getElementById('contrast-slider');
        const blurSlider = document.getElementById('blur-slider');
        const grayscaleLabel = document.querySelector('label[for="grayscale-slider"]');
        const brightnessLabel = document.querySelector('label[for="brightness-slider"]');
        const contrastLabel = document.querySelector('label[for="contrast-slider"]');
        const blurLabel = document.querySelector('label[for="blur-slider"]');
        function updateMapFilter() {
            if (!tilePane) return;
            const grayscale = grayscaleSlider.value;
            const brightness = brightnessSlider.value;
            const contrast = contrastSlider.value;
            const blur = blurSlider.value;
            grayscaleLabel.innerText = `Độ xám: ${Number(grayscale).toFixed(1)}`;
            brightnessLabel.innerText = `Độ sáng: ${Number(brightness).toFixed(2)}`;
            contrastLabel.innerText = `Tương phản: ${Number(contrast).toFixed(1)}`;
            if (blurLabel) {
                blurLabel.innerText = `Độ nhòe (Blur): ${Number(blur).toFixed(1)} px`;
            }
            const filterString = `grayscale(${grayscale}) brightness(${brightness}) contrast(${contrast}) blur(${blur}px)`;
            tilePane.style.filter = filterString;
        }
        grayscaleSlider.addEventListener('input', updateMapFilter);
        brightnessSlider.addEventListener('input', updateMapFilter);
        contrastSlider.addEventListener('input', updateMapFilter);
        blurSlider.addEventListener('input', updateMapFilter);
        // Gọi hàm lần đầu để áp dụng giá trị mặc định (từ HTML)
        updateMapFilter();
        // (MỚI v54) Bắt sự kiện Enter trong ô tìm kiếm
        document.getElementById('termid-search-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Ngăn chặn form submit
                searchByTermId();
            }
        });
        // (*** MỚI v50 ***) Hàm đóng Bảng Xếp Hạng (gọi từ nút X)
        function closeRankPanel() {
            const panel = document.getElementById('rank-table-container');
            const button = document.getElementById('rank-toggle-btn');
            if (panel) panel.style.display = 'none';
            // Cũng cập nhật style của nút 🏆 trong menu ☰
            if (button) {
                button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt
            }
        }
    </script>
</body>

</html>