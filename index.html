<!DOCTYPE html>

<html lang="vi">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>BAN DO HUB - HMTQ</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://unpkg.com/leaflet-geometryutil@0.9.3/src/leaflet.geometryutil.js"></script>

 <style>
/* KHỐI STYLE CỦA BẠN (SỬA ĐỔI RẤT ÍT) */
html, body, #map {
    height: 100vh;
    width: 100vw;
    margin: 0;
    padding: 0;
    font-family: 'Times New Roman', Times, serif;
    overflow: hidden;
}

.leaflet-tile-pane {
    filter: grayscale(1) contrast(1.1) brightness(0.95); 
}
/* (MỚI v40) CSS cho Lớp Viền (Pane) */
.leaflet-border-pane {
    pointer-events: none; /* Không bắt click chuột */
}
/* Bảng xếp hạng */
#rank-table-container {
    position: absolute;
    top: 60px;
    left: 10px;
    width: 280px; 
    max-height: calc(100vh - 80px); 
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #ccc;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 2001;
    font-size: 14px;
    display: none; 
}
#rank-table-header {
    padding: 8px 12px;
    font-weight: bold;
    font-size: 16px;
    border-bottom: 1px solid #ddd;
    background-color: #f9f9f9;
    border-radius: 8px 8px 0 0;
}
#rank-table-body {
    overflow-y: auto;
    max-height: calc(100vh - 130px);
}
.rank-item {
    padding: 8px 12px;
    border-bottom: 1px solid #eee;
    cursor: pointer;
    transition: background-color 0.2s;
}
.rank-item:hover {
    background-color: #f0f8ff;
}
.rank-item-move {
    background-color: #fffbeb; /* Vàng nhạt */
}
.rank-item button {
    width: 100%;
    padding: 4px 8px;
    font-size: 12px;
    font-weight: 600;
    color: white;
    border: none;
    border-radius: 4px;
    margin-top: 6px;
    cursor: pointer;
}
 
/* CSS cho các nút trong 1 hàng (cho chức năng Move) */
.button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-top: 6px;
}
.button-group button {
    width: auto;
    flex-grow: 1;
    background: #d97706; /* Cam */
}
.button-group button:hover {
    background: #b45309;
}

.rank-item-new button { background: #2563eb; } /* Xanh dương */
.rank-item-new button:hover { background: #1d4ed8; }


/* Icon cho điểm TÂM (dùng ngôi sao) */
.center-point-icon {
    width: 24px !important;
    height: 24px !important;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: white;
    animation: pulse 1.5s infinite;
}
@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(255,255,255, 0.7); }
    70% { box-shadow: 0 0 0 10px rgba(255,255,255, 0); }
    100% { box-shadow: 0 0 0 0 rgba(255,255,255, 0); }
}


 
/* (MỚI v39) CSS cho Icon Pin (Battery) và Nhãn Tiền */
.battery-icon-div-wrapper { /* Div ngoài cùng của L.divIcon */
    display: flex;
    align-items: center;
    /* Căn giữa div này so với tọa độ lat/lng */
    position: absolute;
    left: 50%;
    top: 50%;
     /* Dịch chuyển [-(width_pin/2 + đầu pin/2), -(height_pin/2)] */
    transform: translate(-23px, -11px);
}
.battery-icon-container {
    width: 40px; /* (SỬA v39) To hơn */
    height: 20px; /* (SỬA v39) To hơn */
    border: 2px solid #555;
    border-radius: 4px; 
    background-color: #f0f0f0;
    position: relative; 
    display: flex;
    align-items: center;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    flex-shrink: 0;
}
.battery-icon-container::after {
    content: '';
    position: absolute;
    right: -6px; 
    top: 4px; 
    width: 4px; 
    height: 10px; 
    background-color: #555;
    border-radius: 0 2px 2px 0;
}
.battery-fill {
    height: 100%;
    border-radius: 1px 0 0 1px;
    transition: width 0.3s ease;
    position: absolute;
    left: 0;
    top: 0;
}
.battery-overflow {
    height: 100%;
    border-radius: 1px 0 0 1px;
    transition: width 0.3s ease;
    position: absolute;
    left: 0;
    top: 0;
    z-index: 10; 
}
.battery-text {
    width: 100%;
    text-align: center;
    font-size: 11px; 
    font-weight: bold;
    color: black;
    z-index: 20; 
    text-shadow: 0 0 2px white, 0 0 2px white; 
    position: relative; 
}
/* (SỬA v39) Nhãn tiền có viền */
.battery-amount-label { 
    margin-left: 8px; /* Khoảng cách từ đầu pin */
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid #333;
    border-radius: 3px;
    padding: 1px 4px;
    font-size: 11px;
    font-weight: bold;
    color: black;
    white-space: nowrap;
    box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

 
/* CSS cho điểm "phình to, nhấp nháy" khi hover MOVE */
.point-move-preview {
    transform: scale(1.5); 
    animation: blink-animation 0.7s infinite alternate;
    z-index: 1001 !important; 
}
@keyframes blink-animation {
    from { opacity: 1.0; transform: scale(1.5); }
    to { opacity: 0.6; transform: scale(1.4); }
}
 
/* CSS cho Bảng Rank nhấp nháy */
.rank-item-highlight {
    animation: highlight-green 1.2s ease-in-out infinite alternate;
}
@keyframes highlight-green {
    from { 
        background-color: #f0f8ff; 
    }
    to { 
        background-color: #d1fae5; 
        border-left: 4px solid #10b981; 
        margin-left: -4px; 
    }
}

/* CSS cho Popup Hành Động */
.action-popup .leaflet-popup-content-wrapper {
    border-radius: 8px;
    padding: 0;
    background: rgba(255, 255, 255, 0.95);
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}
.action-popup .leaflet-popup-content {
    margin: 0;
    padding: 10px;
    width: 250px !important; /* ✨ Tăng chiều rộng lên 250px (từ 220px) ✨ */
    font-size: 14px;
}
.action-popup-header {
    font-weight: bold;
    font-size: 16px;
    border-bottom: 1px solid #ddd;
    padding-bottom: 8px;
    margin-bottom: 8px;
}
.action-popup-buttons {
    display: flex;
    flex-direction: column;
    gap: 6px;
    max-height: 150px;
    overflow-y: auto;
}
.action-popup-buttons button {
    padding: 5px 10px;
    font-size: 13px;
    font-weight: 600;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}
.btn-new { background: #2563eb; } 
.btn-new:hover { background: #1d4ed8; }
.btn-add { background: #059669; } 
.btn-add:hover { background: #047857; }
.btn-move { background: #d97706; } 
.btn-move:hover { background: #b45309; }
.action-popup-info {
    font-style: italic;
    color: #555;
}
/* (MỚI v39) Style cho popup info pin */
.battery-info-popup {
    font-style: normal !important;
    color: #333 !important;
    font-size: 13px; /* To hơn một chút */
}
.battery-info-popup b {
    display: inline-block;
    width: 70px; /* Căn lề cho đẹp */
    color: #555;
}


/* Tooltip khoảng cách */
.distance-tooltip {
    background-color: rgba(255, 255, 255, 0.95) !important;
    border: 1.5px solid;
    color: #333 !important;
    font-weight: bold;
    font-size: 12px;
     
    font-family: 'Times New Roman', Times, serif;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2) !important;
    padding: 3px 6px !important;
    border-radius: 4px;
    cursor: pointer; 
    white-space: nowrap; /* Bắt buộc Tooltip không xuống dòng */
font-size: 11px; /* Chữ bé đi */
}
.distance-tooltip .group-name {
    font-size: 11px; /* Đảm bảo kích thước đồng nhất với text còn lại */
    opacity: 1.0;
    display: inline; 
    border-bottom: none;
    margin-bottom: 0;
    color: #000; /* Đảm bảo TermID luôn có màu đen rõ ràng */
    font-weight: bold; /* Đảm bảo TermID nổi bật */
}
.distance-tooltip .loading-spinner {
    font-size: 10px;
    color: #999;
    animation: spin 1s linear infinite;
    display: inline-block;
    margin-left: 4px;
}
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

/* (ĐÃ SỬA) Ẩn chỉ dẫn của Leaflet Routing Machine MẶC ĐỊNH */
.leaflet-routing-container { display: none; }

/* (SỬA v38) Bỏ width: 110px, đổi sang 100% */
.leaflet-bar button, .leaflet-bar button:hover {
    width: 100% !important; /*(SỬA)*/
    height: 32px !important; 
    font-size: 13px !important;
    font-weight: 600 !important; 
    display: flex; 
    align-items: center; 
    justify-content: center;
    gap: 6px; 
    background-color: white !important; 
    color: #1f2937 !important;
    margin-bottom: 6px; /*(MỚI v38)*/
}
.leaflet-bar button:hover { background-color: #f3f4f6 !important; }
 
/* (MỚI v38) CSS cho Bảng Điều Khiển Mới */
.custom-controls-container {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border: 1px solid #ccc;
    padding: 8px;
    width: 150px; /* Chiều rộng cố định cho panel */
}
.custom-controls-container .leaflet-bar-part {
    border: none !important;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
.custom-controls-container .leaflet-bar-part:last-child {
    margin-bottom: 0;
}
 
 
/* Nút Routing */
#routing-toggle-btn.bird-mode { background-color: #fffbeb !important; color: #d97706 !important; }
#routing-toggle-btn.car-mode { background-color: #3b82f6 !important; color: white !important; }
 
/* Nút Pin */
#battery-toggle-btn.pin-mode { background-color: #ecfdf5 !important; color: #059669 !important; }
#battery-toggle-btn.battery-mode { background-color: #16a34a !important; color: white !important; }

/* Nút Filter */
#filter-toggle-btn { background-color: #6b7280 !important; color: white !important; }
#filter-toggle-btn:hover { background-color: #4b5563 !important; }

/* (MỚI v42) CSS cho Nút Bật/Tắt Gom Cụm */
#cluster-toggle-btn.cluster-on { background-color: #8b5cf6 !important; color: white !important; }
#cluster-toggle-btn.cluster-off { background-color: #f3f4f6 !important; color: #4b5563 !important; }
#cluster-toggle-btn.cluster-off:hover { background-color: #e5e7eb !important; }
/* (MỚI v43) CSS cho Nút Bật/Tắt Nhãn KM */
#labels-toggle-btn.labels-on { background-color: #f59e0b !important; color: white !important; }
#labels-toggle-btn.labels-off { background-color: #f3f4f6 !important; color: #4b5563 !important; }
#labels-toggle-btn.labels-off:hover { background-color: #e5e7eb !important; }
/* (*** MỚI v45 ***) CSS cho Nút Bật/Tắt NHNN */
#nhnn-toggle-btn.nhnn-on { background-color: #059669 !important; color: white !important; } /* Màu xanh lá cây */
#nhnn-toggle-btn.nhnn-off { background-color: #f3f4f6 !important; color: #4b5563 !important; }
#nhnn-toggle-btn.nhnn-off:hover { background-color: #e5e7eb !important; }
/* Toastify */
.custom-toast { font-family: 'Times New Roman', Times, serif !important; font-size: 14px !important; font-weight: 600 !important; border-radius: 8px !important; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important; }
.custom-toast.success { background: linear-gradient(135deg, #10b981, #059669) !important; }
.custom-toast.info { background: linear-gradient(135deg, #3b82f6, #2563eb) !important; }
.custom-toast.warning { background: linear-gradient(135deg, #f59e0b, #d97706) !important; }
.custom-toast.error { background: linear-gradient(135deg, #ef4444, #dc2626) !important; }

 
/* CSS CHO ROUTING ĐỘNG */
@keyframes route-flow {
    to {
        stroke-dashoffset: -20;
    }
}
.animated-route-line {
    animation: route-flow 1s linear infinite;
}

/* === CSS CHO BẢNG ĐIỀU KHIỂN BỘ LỌC (SỬA VỊ TRÍ) === */
#filter-controls-container {
    position: absolute;
    top: 10px; /* Đẩy lên trên cùng */
    /* (SỬA v55) Vị trí mặc định lùi khỏi Search Bar */
    right: 320px; 
    width: 250px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #ccc;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1003; /* Nổi lên trên Search (1001) */
    font-size: 13px;
    padding: 10px 15px;
    font-family: 'Times New Roman', Times, serif;
    display: none; 
     
    max-height: calc(100vh - 20px); 
    overflow-y: auto;
    transition: right 0.3s ease; /* Thêm transition */
}
#filter-controls-header {
    font-size: 16px;
    font-weight: bold;
    border-bottom: 1px solid #ddd;
    padding-bottom: 8px;
    margin-bottom: 10px;
    /* (MỚI) Căn chỉnh tiêu đề và nút đóng */
    display: flex;
    justify-content: space-between;
    align-items: center;
}
/* (MỚI) CSS cho nút đóng 'X' */
#close-filter-btn {
    font-size: 24px;
    font-weight: bold;
    color: #777;
    cursor: pointer;
    line-height: 1;
    padding: 0 5px;
}
#close-filter-btn:hover {
    color: #000;
}
.filter-control {
    margin-bottom: 8px;
}
.filter-control label {
    display: block;
    margin-bottom: 4px;
    font-weight: 600;
    color: #333;
}
.filter-control input[type="range"] {
    width: 100%;
    cursor: pointer;
}
 
/* (MỚI v35) CSS cho dropdown filter */
.filter-control select {
    width: 100%;
    padding: 5px 8px;
    font-size: 13px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-family: 'Times New Roman', Times, serif;
    background-color: white;
}
 
/* (MỚI v35) CSS cho nút Reset Filter */
#reset-cascading-filter-btn {
    width: 100%;
    padding: 5px 8px;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background-color: #dc2626; /* Màu đỏ */
    border: none;
    border-radius: 4px;
    margin-top: 10px;
    cursor: pointer;
    transition: background-color 0.2s;
}
#reset-cascading-filter-btn:hover {
    background-color: #b91c1c;
}
/* === (MỚI v41.1) CSS CHO ICON GOM CỤM TÙY CHỈNH === */
.my-cluster-icon {
    /* (Bạn có thể thay màu nền tại đây) */
    background-color: rgba(245, 130, 49, 0.8); /* Màu cam */
    border: 2px solid rgba(245, 130, 49, 1);
    border-radius: 50%; /* Bo tròn */
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
     
    /* Dùng flex để căn giữa số đếm */
    display: flex;
    align-items: center;
    justify-content: center;
     
    text-align: center;
    color: white;
    font-weight: bold;
    font-size: 14px;
    font-family: Arial, sans-serif;
     
    /* Dịch chuyển icon một chút để nó căn đúng vào tâm */
    margin-left: -20px;
    margin-top: -20px;
}
 
/* CSS cho số đếm bên trong */
.my-cluster-icon span {
    /* Không cần thiết lắm vì đã dùng flex, nhưng để cho chắc */
    line-height: 1; 
}

/* Định nghĩa kích thước dựa trên "cấp độ" */
.my-cluster-icon.small {
    width: 30px;
    height: 30px;
    margin-left: -15px;
    margin-top: -15px;
    font-size: 13px;
}
.my-cluster-icon.medium {
    width: 40px;
    height: 40px;
    margin-left: -20px;
    margin-top: -20px;
    font-size: 14px;
}
.my-cluster-icon.large {
    width: 50px;
    height: 50px;
    margin-left: -25px;
    margin-top: -25px;
    font-size: 16px;
}
/* (*** MỚI v49 ***) CSS cho Nút Toggle Panel Chính (Nút Hamburger) */
#panel-toggle-btn {
    width: 100%;
    height: 100%;
    font-size: 18px !important;
    background-color: #059669 !important; /* (SỬA v49) MÀU XANH LÁ */
    color: white !important; 
    border-radius: 8px; /* Khớp với container */
    border: none !important;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
#panel-toggle-btn:hover {
    background-color: #047857 !important; /* (SỬA v49) Xanh đậm hơn */
}

/* (*** MỚI v49 ***) CSS cho Nút Thu Gọn (Collapse) */
#panel-collapse-btn { 
    background-color: #6b7280 !important; 
    color: white !important; 
    /* (SỬA v49) Căn giữa icon (vì không còn chữ) */
    justify-content: center !important; 
    padding-left: 0 !important;
}
#panel-collapse-btn:hover { background-color: #4b5563 !important; }


/* (*** MỚI v47 ***) CSS Ẩn/Hiện Wrapper chứa các nút */
.buttons-wrapper {
    display: block; /* Hiển thị mặc định (cho desktop) */
}
 
/* === (SỬA v55) CSS MỚI CHO BỐ CỤC CHUNG === */
 
/* 1. Panel Bảng Xếp Hạng: LUÔN Ở BÊN TRÁI */
/* (Vị trí gốc được giữ nguyên) */


/* 2. Panel Filter: (SỬA v55) LUÔN Ở BÊN PHẢI */
#filter-controls-container {
    /* Vị trí mặc định lùi khỏi Search Bar */
    right: 10px; 
    left: auto; 
    z-index: 2000; 
}
 
/* 3. Panel Nút Bấm: LUÔN ở góc TRÊN bên phải */
.leaflet-top.leaflet-right {
    top: 10px;
    bottom: auto; 
    right: 0px;
    /* (*** SỬA LỖI v55 ***) Đảm bảo Menu ☰ nổi lên trên Search và Filter */
    z-index: 1005; 
}
 
/* 4. Panel chính (custom-controls-container) LUÔN là nút ☰ */
.custom-controls-container {
    width: 40px; /* Kích thước nút toggle */
    height: 40px;
    padding: 0; /* Xóa padding */
    overflow: hidden; /* Ẩn các nút con */
    background: transparent; /* Tắt nền trắng của panel */
    border: none; /* Tắt viền của panel */
    box-shadow: none; /* Tắt bóng của panel */
    transition: width 0.3s ease; /* Thêm transition */
}

/* 5. Panel chính khi được BẬT (expanded) */
.custom-controls-container.expanded {
    width: 180px; /* DÀI RA CHÚT (từ 150px) */
    height: auto;
    padding: 8px; /* Thêm lại padding */
    background: rgba(255, 255, 255, 0.9); /* Thêm lại nền */
    border: 1px solid #ccc; /* Thêm lại viền */
    box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* Thêm lại bóng */
}
 
/* 6. Ẩn wrapper nút con MẶC ĐỊNH */
.buttons-wrapper {
    display: none; 
}
 
/* 7. Hiển thị wrapper khi panel được BẬT */
.custom-controls-container.expanded .buttons-wrapper {
    display: block;
}

/* 8. Ẩn nút toggle (hamburger) khi panel được BẬT */
.custom-controls-container.expanded #panel-toggle-btn {
    display: none;
}

/* 9. Hiển thị nút toggle (hamburger) MẶC ĐỊNH */
#panel-toggle-btn {
    display: flex; /* Hiển thị nút hamburger */
}
 
/* 10. Ẩn chữ (span) mặc định (khi co lại) */
.custom-controls-container .button-text {
    display: none; 
}

/* 11. Hiển thị chữ khi panel bung ra */
.custom-controls-container.expanded .button-text {
    display: inline; /* Hiện lại chữ */
}
 
/* 12. Các nút con bên trong khi bung ra */
.custom-controls-container.expanded .leaflet-bar-part {
    width: 100% !important; /* Các nút con 100% width */
    height: 40px !important;
    font-size: 16px !important;
    /* (MỚI v49) Căn lề chữ cho đẹp (hết díu) */
    justify-content: flex-start !important; 
    padding-left: 10px !important;
}
 
/* 13. Nút hamburger (khi chưa bung) */
#panel-toggle-btn.leaflet-bar-part {
    width: 40px !important;
    height: 40px !important;
    font-size: 16px !important;
    /* (MỚI v49) Ghi đè: Giữ nút ☰ ở giữa */
    justify-content: center !important;
    padding-left: 0 !important;
}

/* 14. (Ghi đè Desktop) Áp dụng luật mobile cho desktop */
@media (min-width: 769px) {
    #panel-toggle-btn {
        display: flex; /* Vẫn hiển thị nút ☰ */
    }
    .buttons-wrapper {
        display: none; /* Vẫn ẩn wrapper */
    }
    /* Sửa lại panel Filter trên desktop */
    #filter-controls-container {
        width: 250px; /* Trả về độ rộng cũ */
        right: 320px; /* Giữ nguyên vị trí lùi khỏi Search */
        left: auto;
    }
}
#close-filter-btn:hover {
    color: #000;
}

/* (*** MỚI v50 ***) CSS cho nút đóng Bảng Xếp Hạng */
#close-rank-btn {
    font-size: 24px;
    font-weight: bold;
    color: #777;
    cursor: pointer;
    line-height: 1;
    padding: 0 5px;
    float: right; /* Căn sang phải */
}
#close-rank-btn:hover {
    color: #000;
}
 
/* (SỬA v50) Sửa Header của Bảng Xếp Hạng để chứa nút X */
#rank-table-header {
    display: block; /* Đảm bảo nút X (dùng float) hoạt động */
}


/* === SỬA ĐỔI VỊ TRÍ VÀ HIỂN THỊ CỦA THANH TÌM KIẾM (SỬA LỖI v55 & MỚI) === */
/* Thêm transition cho độ trong suốt */
#search-control-container {
    position: absolute;
    top: 30px;
    right: 200px; /* Vị trí mặc định: Cách Menu ☰ 10px (Menu: 40px + 10px gap) */
    width: 250px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid #ccc;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1999; 
    padding: 8px;
    height: auto;
     
    /* (*** MỚI: ẨN MẶC ĐỊNH & THÊM HIỆU ỨNG ***) */
    display: none; 
    opacity: 0;
    transition: right 0.3s ease, opacity 0.3s ease, transform 0.3s ease; 
    transform: translateX(100%); /* Chuẩn bị trượt ra từ bên phải */
}

/* HIỂN THỊ KHI ĐƯỢC BẬT BẰNG JS (Class search-panel-active) */
#search-control-container.search-panel-active {
    display: flex; /* Dùng flex vì bạn có nhiều phần tử bên trong */
    flex-direction: column;
    opacity: 1;
    transform: translateX(0);
}


/* KHẮC PHỤC TRÙNG LẤN VỚI MENU MỞ RỘNG (EXPANDED) */
/* (Bây giờ chúng ta dùng JS để điều khiển vị trí khi mở) */
.custom-controls-container.expanded + #search-control-container.search-panel-active { 
    /* Khi Menu mở rộng (180px), đẩy Search panel ra xa hơn */
    right: 190px; /* 180px (Menu) + 10px (gap) */
}

/* Đảm bảo Panel Filter lùi khỏi Search bar khi Search panel hiện */
#search-control-container.search-panel-active + #filter-controls-container {
    right: 320px; /* 60px (Search container right) + 250px (Search width) + 10px (gap) */
}
/* Đảm bảo Panel Filter lùi khỏi Search bar khi cả hai đều mở */
.custom-controls-container.expanded + #search-control-container.search-panel-active + #filter-controls-container {
    right: 450px; /* 190px (Search container right) + 250px (Search width) + 10px (gap) */
}

/* Giữ Filter ở vị trí cũ khi Search/Menu ẩn */
#filter-controls-container {
    right: 10px !important; /* Vị trí mặc định của Filter (Gần rìa phải) */
    transition: right 0.3s ease; /* Thêm transition */
}

/* (MỚI v54) Vùng chứa Input & Button */
.search-input-group {
    display: flex;
    gap: 5px;
}
#search-control-container input {
    flex-grow: 1;
    padding: 6px 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    font-family: 'Times New Roman', Times, serif;
    outline: none;
}
#search-control-container button {
    padding: 6px 10px;
    background-color: #3b82f6;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
}
#search-control-container button:hover {
    background-color: #2563eb;
}


/* === KHẮC PHỤC TRÙNG LẤN VỚI MENU MỞ RỘNG (EXPANDED) === */

/* (Sửa lỗi này đã được áp dụng trong CSS trên) */

/* === STYLE CHO PHẦN KẾT QUẢ/GỢI Ý TÌM KIẾM (MỚI v54) === */
#search-results-container {
    max-height: 200px;
    overflow-y: auto;
    border-top: 1px solid #eee;
    margin-top: 8px;
    padding-top: 5px;
    display: none; /* Mặc định ẩn */
}
/* === (MỚI v57) CSS cho Tooltip Tùy Chỉnh === */

.search-result-item {
    position: relative; /* Quan trọng: Để tooltip căn theo vị trí này */
    /* ... các thuộc tính cũ ... */
}

/* Ẩn tooltip mặc định của trình duyệt */
.search-result-item[title]:hover {
    pointer-events: none; /* Ngăn chặn Tooltip mặc định */
}

.search-result-item::before,
.search-result-item::after {
    --arrow-size: 6px; /* Kích thước mũi tên */
    position: absolute;
    display: none; /* Mặc định ẩn */
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
    z-index: 2001; /* Đảm bảo nổi lên trên mọi thứ */
}

/* Tooltip: Dùng ::after */
.search-result-item::after {
    content: attr(data-title); /* Lấy nội dung từ thuộc tính data-title */
    top: calc(100% + var(--arrow-size) + 5px); /* Vị trí bên dưới item + khoảng cách mũi tên */
    left: 50%;
    transform: translateX(-50%);
     
    padding: 6px 10px;
    min-width: 150px;
    max-width: 250px;
     
    background-color: #333; /* Màu nền đen */
    color: white;
    border-radius: 4px;
    text-align: center;
    font-size: 13px;
    line-height: 1.4;
    white-space: normal; /* Cho phép chữ xuống dòng */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

/* Mũi tên: Dùng ::before */
.search-result-item::before {
    content: '';
    top: calc(100% + 5px); /* Vị trí của mũi tên */
    left: 50%;
    transform: translateX(-50%) rotate(45deg);
     
    width: var(--arrow-size);
    height: var(--arrow-size);
    background-color: #333; /* Màu nền đen */
    border-radius: 2px;
}

/* HIỂN THỊ khi HOVER */
.search-result-item:hover::before,
.search-result-item:hover::after {
    display: block;
    opacity: 1;
}

/* --- STYLE BỔ SUNG CHO MEASURE SEARCH --- */
.search-results-container {
    max-height: 150px;
    overflow-y: auto;
    border-top: 1px solid #eee;
    background-color: white;
    z-index: 1000;
    position: relative; 
    border: 1px solid #ddd;
    border-top: none;
    border-radius: 0 0 4px 4px;
}
.search-input-group input {
    border-radius: 4px; /* Reset Tailwind's default */
}
.search-input-group button {
    padding: 6px 10px;
    background-color: #6b7280; /* Màu xám đậm */
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.15s ease-in-out;
}
.search-input-group button:hover {
    background-color: #4b5563; /* Màu xám tối hơn khi hover */
}
.search-result-item {
    padding: 8px 10px;
    cursor: pointer;
    border-bottom: 1px solid #eee;
    font-size: 0.9rem;
}
.search-result-item:hover {
    background-color: #f0f0f0;
}
/* === CSS cho Tooltip Tâm Nhóm (Compact) === */
.distance-tooltip-compact {
    font-size: 11px !important; /* Chữ bé hơn */
    white-space: nowrap; /* Đảm bảo không xuống dòng */
    padding: 3px 6px !important; 
}
/* === CSS cho Tooltip Term ID (Tên điểm) === */
.termid-label-tooltip {
    background-color: rgba(255, 255, 255, 0.9);
    border: 1px solid #999;
    border-radius: 4px;
    padding: 2px 4px;
    font-size: 10px; /* Chữ nhỏ */
    font-weight: bold;
    color: #444;
    white-space: nowrap;
    opacity: 1;
    pointer-events: none; /* Không chặn sự kiện click vào Marker phía dưới */
}

/* Loại bỏ mũi tên nhọn của Tooltip */
.termid-label-tooltip .leaflet-tooltip-tip {
    background: transparent;
    border: none;
    box-shadow: none;
}
/* Tùy chỉnh CSS cho thanh trượt (nếu cần) */
.control-section {
    padding: 10px;
    border-bottom: 1px solid #e0e0e0;
}
.control-label {
    display: block;
    font-weight: 600;
    margin-bottom: 5px;
    font-size: 14px;
}
#radius-slider {
    width: 100%;
    margin-top: 5px;
}
/* === BỔ SUNG: CSS CHO CHẾ ĐỘ MOBILE (max-width: 768px) === */
@media (max-width: 768px) {
    /* --- VỊ TRÍ CHUNG CHO TẤT CẢ PANEL --- */
    #rank-table-container,
    #filter-controls-container,
    #search-control-container {
        /* Đảm bảo panel nằm trên cùng, full chiều rộng */
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw !important; /* Chiếm toàn bộ chiều rộng */
        max-width: 100vw;
        height: 100vh !important; /* Chiếm toàn bộ chiều cao */
        max-height: 100vh;
        border-radius: 0; /* Loại bỏ góc bo tròn */
        padding: 10px;
        box-shadow: none;
        z-index: 5000; /* Đảm bảo nổi lên trên mọi thứ */
        transform: translateX(0) !important; /* Vô hiệu hóa animation trượt ngang */
        transition: none !important; /* Vô hiệu hóa transition vị trí */
    }

    /* --- PANEL TÌM KIẾM CẦN DÙNG FLEX ĐỂ CUỘN --- */
    #search-control-container {
        flex-direction: column;
        display: none; /* Ẩn mặc định trên mobile, dùng JS để hiển thị */
    }
    #search-control-container.search-panel-active {
        display: flex; /* Hiện khi active */
    }
     
    /* --- PANEL FILTER --- */
    #filter-controls-container {
        right: 0 !important; /* Ghi đè vị trí right do các logic trước đó */
        left: 0 !important;
    }
     
    /* --- BẢNG XẾP HẠNG (RANK) --- */
    #rank-table-body {
        max-height: calc(100vh - 60px) !important; /* Chiều cao còn lại sau header */
    }
}
/* --- Popup Actions Buttons --- */
.action-popup-header {
    font-size: 14px;
    font-weight: bold;
    margin-bottom: 8px;
    color: #333;
}

.action-popup-buttons button {
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s, transform 0.1s;
    font-size: 13px;
    position: relative; /* Cho chấm trạng thái */
}

.action-popup-buttons button i {
    margin-right: 6px;
}

.action-popup-buttons button:hover {
    filter: brightness(1.1);
    transform: translateY(-1px);
}

.action-popup-buttons button.btn-new {
    background-color: #f7941d; /* Màu cam */
}

.action-popup-buttons button.btn-measure {
    position: relative;
    border: 2px solid transparent; /* Viền mặc định */
}

.action-popup-buttons button.btn-measure.disabled {
    opacity: 0.6;
    cursor: not-allowed;
    filter: grayscale(10%);
    pointer-events: none; /* Ngăn chặn click */
}

/* Chấm trạng thái (nằm trong nút) */
.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: transparent; /* Mặc định không hiển thị */
    position: absolute;
    top: 5px; /* Điều chỉnh vị trí */
    right: 5px; /* Điều chỉnh vị trí */
    display: block; /* Luôn hiển thị để giữ không gian */
}

.status-dot.green-dot {
    background-color: #28a745; /* Màu xanh lá cây */
}


/* Hiệu ứng viền nhấp nháy cho nút đã chọn */
@keyframes blink-border {
    0% { border-color: transparent; }
    50% { border-color: #fff; box-shadow: 0 0 8px rgba(255, 255, 255, 0.7); }
    100% { border-color: transparent; }
}

.btn-measure.selected-blinking {
    animation: blink-border 1s infinite;
}

/* Nút hành động đo lường (car, walking, trash) */
.button-group.measure-action-group button {
    background-color: #6c757d; /* Màu xám trung tính */
    color: white;
    font-size: 16px; /* Icon lớn hơn */
    padding: 8px;
    height: 40px; /* Chiều cao cố định */
}
.button-group.measure-action-group button:hover {
    background-color: #5a6268;
}

.button-group.measure-action-group button:nth-child(1) { /* Car */
    background-color: #17a2b8; /* Màu xanh dương nhạt */
}
.button-group.measure-action-group button:nth-child(1):hover {
    background-color: #138496;
}
.button-group.measure-action-group button:nth-child(2) { /* Walking */
    background-color: #28a745; /* Màu xanh lá cây */
}
.button-group.measure-action-group button:nth-child(2):hover {
    background-color: #218838;
}
.button-group.measure-action-group button:nth-child(3) { /* Trash */
    background-color: #dc3545; /* Màu đỏ */
}
.button-group.measure-action-group button:nth-child(3):hover {
    background-color: #c82333;
}


/* Popup tổng thể */
.leaflet-popup-content-wrapper .action-popup-buttons {
    padding-bottom: 5px; /* Thêm padding dưới để tránh sát mép */
}
/* === SỬA LỖI VÀ TĂNG CƯỜNG HIỆU ỨNG GLOW & JUMPING (THEO YÊU CẦU MỚI) === */

/* Đảm bảo icon chính không bị ẩn */
.leaflet-marker-icon.pulsing-marker-A,
.leaflet-marker-icon.pulsing-marker-B {
    /* Áp dụng animation nhảy */
    animation: marker-jump 0.8s infinite alternate ease-in-out; 
    transform-origin: 50% 100%; 
    z-index: 100; 
    filter: none; /* Rất quan trọng: Vô hiệu hóa filter có thể làm đen icon */
}

/* Keyframes cho hiệu ứng nhảy (Jump) */
@keyframes marker-jump {
    0% { transform: translateY(0); }
    100% { transform: translateY(-10px); } /* Nhảy lên 10px */
}

/* CSS QUẦNG SÁNG (GLOW EFFECT) */
.leaflet-marker-icon.pulsing-marker-A::after,
.leaflet-marker-icon.pulsing-marker-B::after {
    content: '';
    position: absolute;
    top: 100%; 
    left: 50%;
    /* Dịch chuyển để căn giữa tại chân Icon */
    transform: translate(-50%, 0); 
    width: 35px; 
    height: 35px;
    border-radius: 50%;
    z-index: -1; /* Đặt dưới icon chính */
    pointer-events: none;
}

/* Thiết lập màu sắc và animation cho Điểm A */
.leaflet-marker-icon.pulsing-marker-A::after {
    background-color: rgba(0, 123, 255, 1.0); /* Xanh dương đậm */
    box-shadow: 0 0 15px rgba(0, 123, 255, 0.9);
    animation: marker-pulse-glow-A 1s infinite; 
}

/* Thiết lập màu sắc và animation cho Điểm B */
.leaflet-marker-icon.pulsing-marker-B::after {
    background-color: rgba(220, 53, 69, 1.0); /* Đỏ đậm */
    box-shadow: 0 0 15px rgba(220, 53, 69, 0.9);
    animation: marker-pulse-glow-B 1s infinite; 
}


/* KEYFRAMES MẠNH MẼ HƠN (GLOW) */
@keyframes marker-pulse-glow-A {
    0% {
        transform: translate(-50%, 0) scale(0.5); 
        opacity: 1.0; 
    }
    100% {
        transform: translate(-50%, 0) scale(2.2); 
        opacity: 0.0;
    }
}
@keyframes marker-pulse-glow-B {
    0% {
        transform: translate(-50%, 0) scale(0.5); 
        opacity: 1.0; 
    }
    100% {
        transform: translate(-50%, 0) scale(2.2); 
        opacity: 0.0;
    }
}
</style>

</head>

<body>
    <div id="map"></div>
    <div id="rank-table-container">

        <div id="rank-table-header">

            Bảng Xếp Hạng Lựa Chọn

            <span id="close-rank-btn" onclick="event.stopPropagation(); closeRankPanel();">&times;</span>

        </div>

        <div id="rank-table-body">

        </div>

    </div>

    <div id="search-control-container">

        <div id="search-control-header"
            style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 10px;">

            <span style="font-size: 16px; font-weight: bold;">Tìm kiếm & Đo lường</span>

            <span id="close-search-btn" onclick="event.stopPropagation(); toggleSearchPanel();"
                style="font-size: 24px; font-weight: bold; color: #777; cursor: pointer; line-height: 1; padding: 0 5px;">&times;</span>

        </div>

        <div class="search-input-group">

            <input type="text" id="termid-search-input" placeholder="Tìm theo Mã CN hoặc Tên HUB...">

            <button id="search-button" onclick="searchByTermId()">

                <i class="fa-solid fa-magnifying-glass"></i>

            </button>

        </div>

        <div id="search-results-container">

        </div>

        <hr class="my-3 border-t border-gray-300">

        <div id="proposal-container">

            <label style="font-weight: bold; margin-bottom: 5px; display: block;">Danh sách Đề xuất (Tối đa 5):</label>

            <div id="proposal-list"
                class="flex flex-col gap-2 p-2 border border-gray-300 rounded-md bg-white min-h-[40px]">

            </div>

            <button id="optimize-button" onclick="startOptimization()"
                class="w-full mt-3 px-3 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out disabled:bg-gray-400"
                disabled>

                <i class="fa-solid fa-cogs mr-1"></i> Tối Ưu Hóa (Bán kính: <span id="optimize-radius-display">30</span>
                km)

            </button>

            <button id="clear-optimization-btn" onclick="clearOptimizationVisuals()"
                class="w-full mt-2 px-3 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out"
                style="display: none;">

                <i class="fa-solid fa-trash-alt mr-1"></i> Xóa Vòng Tròn Đề Xuất

            </button>

        </div>

        <hr class="my-3 border-t border-gray-300">
        <div id="measurement-log"
            style="font-size: 14px; font-weight: bold; padding: 5px 0; min-height: 20px; color: #333; border-bottom: 1px solid #ddd; margin-bottom: 10px; display: none;">

        </div>

        <div id="search-a-container">

            <label for="search-a-input" style="font-weight: bold; margin-bottom: 5px; display: block;">Điểm Bắt đầu
                (A):</label>

            <div class="search-input-group">

                <input type="text" id="search-a-input" placeholder="Mã CN/Tên HUB (Start)">

                <button onclick="searchMeasurePoint('A')">

                    <i class="fa-solid fa-magnifying-glass"></i>

                </button>

            </div>

            <div id="search-a-results" class="search-results-container"></div>

        </div>
        <div id="search-b-container" style="margin-top: 10px;">

            <label for="search-b-input" style="font-weight: bold; margin-bottom: 5px; display: block;">Điểm Kết thúc
                (B):</label>

            <div class="search-input-group">

                <input type="text" id="search-b-input" placeholder="Mã CN/Tên HUB (End)">

                <button onclick="searchMeasurePoint('B')">

                    <i class="fa-solid fa-magnifying-glass"></i>

                </button>

            </div>

            <div id="search-b-results" class="search-results-container"></div>

        </div>
        <div class="flex space-x-2 mt-4">

            <button id="measure-route-btn" onclick="measureRouteBetweenAandB()"
                class="flex-1 px-3 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out">

                <i class="fa-solid fa-route mr-1"></i> Đo Lái Xe

            </button>

            <button id="measure-straight-btn" onclick="measureStraightLineBetweenAandB()"
                class="flex-1 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out">

                <i class="fa-solid fa-ruler mr-1"></i> Đường Chim Bay

            </button>

            <button id="clear-measure-btn" onclick="clearMeasurement()"
                class="flex-1 px-3 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out">

                <i class="fa-solid fa-trash mr-1"></i> Xóa Đo

            </button>

        </div>
    </div>
    <div id="filter-controls-container">

        <div id="filter-controls-header">

            Tùy Chỉnh Bản Đồ

            <span id="close-filter-btn" onclick="event.stopPropagation(); toggleFilterControls();">&times;</span>

        </div>

        <div class="control-section">

            <label for="radius-slider" class="control-label">Bán kính Phân tích (<span id="radius-value">30</span>
                km)</label>

            <input type="range" id="radius-slider" min="30" max="100" step="10" value="30">

        </div>

        <div class="filter-control">

            <label for="grayscale-slider">Độ xám: 0.0</label>

            <input type="range" id="grayscale-slider" min="0" max="1" step="0.1" value="0">

        </div>

        <div class="filter-control">

            <label for="brightness-slider">Độ sáng: 0.95</label>

            <input type="range" id="brightness-slider" min="0.5" max="1.5" step="0.05" value="0.95">

        </div>

        <div class="filter-control">

            <label for="contrast-slider">Tương phản: 0.5</label>

            <input type="range" id="contrast-slider" min="0.5" max="2" step="0.1" value="0.5">

        </div>
        <div class="filter-control">

            <label for="blur-slider">Độ nhòe (Blur): 0 px</label>

            <input type="range" id="blur-slider" min="0" max="10" step="0.5" value="0">

        </div>
        <div id="cascading-filter-container">

        </div>
    </div>


    <script>
/**
 * Tự động tạo 20 nhóm (vòng tròn bán kính) dựa trên Top 20 điểm đề xuất trong Bảng xếp hạng.
 * Sử dụng đệ quy để xử lý bất đồng bộ, tránh làm treo trình duyệt.
 */
function createTop20Groups() {
    if (currentRankings.length === 0) {
        showToast("Không có điểm nào trong Bảng xếp hạng để tạo nhóm.", "error");
        return;
    }

    const top20Candidates = currentRankings.slice(0, 20)
        .filter(r => r.type === 'NEW'); // Chỉ lấy các điểm đề xuất tạo nhóm MỚI

    if (top20Candidates.length === 0) {
        showToast("Không tìm thấy điểm Hub mới nào để tạo nhóm.", "warning");
        return;
    }

    showToast(`Bắt đầu tạo ${top20Candidates.length} nhóm tự động...`, 'info');
    
    // Khóa nút trong khi xử lý
    document.getElementById('auto-group-btn').disabled = true;

    // Sử dụng đệ quy để tạo nhóm lần lượt
    const processNextGroup = (index) => {
        if (index >= top20Candidates.length) {
            showToast("Đã tạo nhóm thành công cho tất cả các Hub.", 'success');
            document.getElementById('auto-group-btn').disabled = false; // Mở lại nút
            return;
        }

        const item = top20Candidates[index];
        
        // 1. Tìm điểm tâm trong allPoints
        const centerPoint = allPoints.find(p => String(p.id) === String(item.centerId));

        if (centerPoint && centerPoint.groupId === null) {
            // 2. Gọi hàm tạo nhóm (Tương tự popup_createGroup)
            // Lấy bán kính hiện tại từ thanh trượt
            const currentRadius = RADIUS_METERS;
            
            // Xử lý tạo nhóm (Logic này nên được chuyển thành một hàm tiện ích không Popup)
            
            // NOTE: Thay vì gọi popup_createGroup (sẽ gọi Toast và đóng Popup),
            // chúng ta gọi logic tạo nhóm THÔ để tránh lỗi UI liên tục.
            
            // Gọi hàm tạo nhóm đã được sửa đổi để chấp nhận bán kính
            if (rawCreateGroup(centerPoint, currentRadius, currentRadius / 1000)) {
                 showToast(`Đang tạo nhóm: ${centerPoint.id} (${index + 1}/${top20Candidates.length})`, 'info');
            }
        }
        
        // Chờ một chút trước khi gọi điểm tiếp theo
        setTimeout(() => {
            processNextGroup(index + 1);
        }, 50); // Chờ 50ms cho mỗi nhóm
    };

    processNextGroup(0);
}
/**
 * (MỚI) Hàm tiện ích tạo nhóm mà không tương tác với Popup/Toast.
 * @returns {boolean} True nếu nhóm được tạo.
 */
function rawCreateGroup(centerPoint, radiusMeters, radiusKm) {
    if (centerPoint.groupId !== null) return false;
    
    // Tìm các điểm CHƯA NHÓM nằm trong bán kính
    const coveredPoints = allPoints.filter(p => {
        if (p.id === centerPoint.id || p.nhnn) return false;
        if (p.groupId !== null && p.groupId !== 'REFERENCE') return false; 
        const distance = centerPoint.latlng.distanceTo(p.latlng);
        return distance <= radiusMeters;
    });

    const newGroupNumber = allGroups.length + 1;
    const newGroupColor = GROUP_COLORS[allGroups.length % GROUP_COLORS.length];
    const newGroupId = `G_${newGroupNumber}`; 
    
    const pointsInGroup = [centerPoint, ...coveredPoints];

    const newGroup = {
        id: newGroupId, 
        centerPoint: centerPoint,
        points: pointsInGroup, 
        color: newGroupColor,
        groupNumber: newGroupNumber,
        routingControls: [],
        polylineCache: {},
        fixedRadiusMeters: radiusMeters, // ✨ LƯU BÁN KÍNH CỐ ĐỊNH ✨
        fixedRadiusKm: radiusKm
    };
    allGroups.push(newGroup);

    // CẬP NHẬT DỮ LIỆU ĐIỂM
    centerPoint.groupId = newGroupId; 
    const coveredIds = new Set(coveredPoints.map(p => p.id));
    allPoints.forEach(p => {
        if (coveredIds.has(p.id)) {
            p.groupId = newGroupId; 
        }
    });

    // ĐỒNG BỘ biến groups (cho UI Popup)
    const pointIdsInGroup = pointsInGroup.map(p => p.id);
    groups[`NHÓM ${newGroupNumber}`] = { 
        id: newGroupId, 
        color: newGroupColor, 
        pointIds: pointIdsInGroup 
    };

    // Cập nhật giao diện sau khi tạo xong (gọi một lần sau khi loop kết thúc)
    drawAllGroups();
    updateRankTable();
    updateFilterOptions();
    
    return true;
}
        function clearOptimizationVisuals() {

            // Gọi hàm clearPreview để xóa vòng tròn preview/tooltip

            clearPreview();
            // Ẩn nút xóa

            document.getElementById('optimize-button').style.display = 'block';

            document.getElementById('clear-optimization-btn').style.display = 'none';
            // ✨ TẮT CHẶN HOVER ✨

            isOptimizationResultVisible = false;
            showToast("Đã xóa vòng tròn đề xuất.", "info");

        }

        async function startOptimization() {

            if (proposedPoints.length === 0) {

                showToast("Vui lòng thêm điểm đề xuất.", "error");

                return;

            }
            showToast("Đang chạy thuật toán tối ưu hóa...", 'info');
            // ✨ 1. RESET TRẠNG THÁI UI VÀ VÒNG TRÒN CŨ ✨

            clearMapVisuals(); // Xóa đường đo A/B

            clearOptimizationVisuals(); // Xóa vòng tròn cũ và ẩn nút xóa
            // Ẩn nút Optimize trong khi tính toán

            document.getElementById('optimize-button').style.display = 'none';
            const results = [];
            // Lọc ra các điểm chưa nhóm hiện tại (sẽ là vệ tinh)

            const ungroupedPoints = allPoints.filter(p => p.groupId === null && p.isVisible && !p.nhnn);

            const nhnnPoints = allPoints.filter(p => p.nhnn && p.isVisible);
            // 2. Lặp qua từng điểm đề xuất làm TÂM

            for (const centerCandidate of proposedPoints) {

                let totalCoverage = 0;

                let totalDistanceToCoverage = 0;

                let totalDistanceToNHNN_Covered = 0;

                let coveredNHNNCount = 0;

                let coveredItems = [];
                // 2a. Tính toán phủ sóng và khoảng cách đến các điểm chưa nhóm (PGD/ATM)

                for (const satellite of ungroupedPoints) {

                    const distance = centerCandidate.latlng.distanceTo(satellite.latlng);

                    if (distance <= RADIUS_METERS) {

                        totalCoverage++;

                        totalDistanceToCoverage += distance;

                        coveredItems.push({ id: satellite.id, type: 'Satellite', distance: distance });

                    }

                }
                // 2b. Tính toán khoảng cách đến NHNN (CHỈ KHI NẰM TRONG BÁN KÍNH)

                for (const nhnn of nhnnPoints) {

                    const distance = centerCandidate.latlng.distanceTo(nhnn.latlng);
                    if (distance <= RADIUS_METERS) {

                        totalCoverage++;

                        totalDistanceToNHNN_Covered += distance;

                        coveredNHNNCount++;

                        coveredItems.push({ id: nhnn.id, type: 'NHNN', distance: distance });

                    }

                }
                // Tính khoảng cách trung bình

                const totalCoveredSatellites = coveredItems.filter(i => i.type === 'Satellite').length;
                const avgDistanceToCoverage = totalCoveredSatellites > 0

                    ? (totalDistanceToCoverage / totalCoveredSatellites)

                    : Infinity; // Chỉ tính TB dựa trên vệ tinh (PGD/ATM)
                const avgDistanceToNHNN = coveredNHNNCount > 0

                    ? (totalDistanceToNHNN_Covered / coveredNHNNCount)

                    : Infinity; // TB dựa trên NHNN được cover
                results.push({

                    centerId: centerCandidate.id,

                    totalCoverage: totalCoverage,

                    avgDistanceToCoverage: avgDistanceToCoverage,

                    avgDistanceToNHNN: avgDistanceToNHNN,

                    coveredItems: coveredItems,

                    centerPoint: centerCandidate // Lưu tham chiếu điểm tâm

                });

            }
            // 3. Xếp hạng (Ưu tiên Phủ sóng > Khoảng cách TB Phủ sóng > Khoảng cách TB NHNN)

            results.sort((a, b) => {

                if (b.totalCoverage !== a.totalCoverage) return b.totalCoverage - a.totalCoverage;

                if (a.avgDistanceToCoverage !== b.avgDistanceToCoverage) return a.avgDistanceToCoverage - b.avgDistanceToCoverage;

                return a.avgDistanceToNHNN - b.avgDistanceToNHNN;

            });
            renderOptimizationResult(results);
            // Sau khi tính toán, hiện lại nút Optimize

            document.getElementById('optimize-button').style.display = 'block';

        }
        function renderOptimizationResult(results) {

            if (results.length === 0) {

                showToast("Không tìm thấy kết quả tối ưu nào.", "warning");

                return;

            }
            const bestResult = results[0];

            const centerPoint = allPoints.find(p => p.id === bestResult.centerId);
            // 5. Hiển thị kết quả tối ưu nhất (Vẽ vòng tròn và Highlight)

            showToast(`Đã tìm thấy điểm tối ưu nhất: ${bestResult.centerId}`, 'success');
            // Ẩn nút Optimize và hiện nút Clear

            document.getElementById('optimize-button').style.display = 'none';

            document.getElementById('clear-optimization-btn').style.display = 'block';
            // Tạo đối tượng Preview tạm thời để gọi showPreview

            const previewItem = {

                type: 'NEW',

                centerPoint: centerPoint,

                // Dùng map/filter để đảm bảo chỉ các điểm hợp lệ được đưa vào coveredPoints

                coveredPoints: bestResult.coveredItems.map(item => allPoints.find(p => p.id === item.id)).filter(p => p),

                color: '#911EB4', // Tím đậm cho kết quả tối ưu

                tooltipContent: `

            <div style="font-size: 13px; padding: 5px; min-width: 200px; line-height: 1.5;">

                <strong style="display: block;">Tâm Tối Ưu: ${centerPoint.id}</strong>

                <hr style="margin: 4px 0;">

                <div>Phủ sóng: <b>${bestResult.totalCoverage}</b> điểm</div>

                <div>TB khoảng cách (vệ tinh): <b>${(bestResult.avgDistanceToCoverage / 1000).toFixed(2)} km</b></div>

                <div>TB khoảng cách (NHNN): <b>${(bestResult.avgDistanceToNHNN / 1000).toFixed(2)} km</b></div>

                <hr style="margin: 4px 0;">

                <div>Xếp hạng: <b>#1 / ${results.length}</b></div>

            </div>

        `

            };
            showPreview(previewItem, null);
            // Zoom đến kết quả tối ưu

            if (centerPoint && centerPoint.latlng) {

                // Chỉ panTo để không thay đổi mức zoom đột ngột

                map.panTo(centerPoint.latlng);

            }
            // ✨ BẬT CHẶN HOVER ✨

            isOptimizationResultVisible = true;

        }

        /**
 * (CẬP NHẬT: THÊM NÚT XÓA VÀO ITEM LIST) Cập nhật danh sách điểm đề xuất trong Sidebar.
 */
function renderProposalList() {
    // ⚠️ Giả sử container DIV chứa danh sách đề xuất có ID là 'proposal-list' (theo HTML của bạn)
    const listDiv = document.getElementById('proposal-list'); 
    const optimizeBtn = document.getElementById('optimize-button');
    const radiusDisplay = document.getElementById('optimize-radius-display');
    
    if (!listDiv || !optimizeBtn) return;

    listDiv.innerHTML = '';
    
    // Cập nhật hiển thị bán kính tối ưu
    if (radiusDisplay) radiusDisplay.textContent = currentRadiusKm;

    if (proposedPoints.length === 0) {
        listDiv.innerHTML = '<span class="text-gray-500 italic text-sm">Chưa có điểm đề xuất.</span>';
        optimizeBtn.disabled = true;
        return;
    }
    
    proposedPoints.forEach(point => {
        const item = document.createElement('div');
        item.className = 'flex justify-between items-center bg-gray-100 p-2 rounded';
        item.innerHTML = `
            <span class="text-sm font-medium">${point.id} (${point.tenHub || 'PGD'})</span>
            <button class="text-red-500 hover:text-red-700 text-xs font-bold" onclick="removeProposal('${point.id}')">
                <i class="fa-solid fa-times"></i>
            </button>
        `;
        listDiv.appendChild(item);
    });

    // Kích hoạt nút Tối Ưu Hóa nếu có ít nhất 1 điểm
    optimizeBtn.disabled = (proposedPoints.length < 1); 
}
        function addProposal(pointId) {

            if (proposedPoints.length >= 5) {

                showToast("Chỉ được đề xuất tối đa 5 điểm.", "error");

                return;

            }

            const point = allPoints.find(p => p.id === pointId);

            if (!point) return;
            if (proposedPoints.some(p => p.id === pointId)) {

                showToast(`Điểm ${pointId} đã có trong danh sách.`, "warning");

                return;

            }
            // Clone dữ liệu để tránh lỗi tham chiếu

            proposedPoints.push({ ...point });

            renderProposalList();

            showToast(`Đã thêm ${pointId} vào danh sách đề xuất.`, "info");

        }
        function removeProposal(pointId) {

            proposedPoints = proposedPoints.filter(p => p.id !== pointId);

            renderProposalList();

            showToast(`Đã xóa ${pointId} khỏi danh sách đề xuất.`, "warning");

        }

        // Biến toàn cục (Cần đảm bảo đã được khai báo ngoài các hàm):

        // let currentRadiusKm = 30; 

        // let RADIUS_METERS = 30000; 
        function setupRadiusControl() {

            const slider = document.getElementById('radius-slider');

            const valueDisplay = document.getElementById('radius-value');
            // Khởi tạo giá trị mặc định của thanh trượt

            slider.value = currentRadiusKm;

            valueDisplay.textContent = currentRadiusKm;
            slider.addEventListener('input', function () {

                const newRadiusKm = parseInt(this.value);
                // 1. Cập nhật biến toàn cục (chỉ ảnh hưởng đến Preview)

                currentRadiusKm = newRadiusKm;

                RADIUS_METERS = newRadiusKm * 1000; // Cập nhật RADIUS_METERS
                // 2. Cập nhật hiển thị km

                valueDisplay.textContent = newRadiusKm;
                // 3. (QUAN TRỌNG) Kích hoạt lại việc vẽ

                // Điều này sẽ vẽ lại các nhóm ĐÃ LƯU với bán kính CỐ ĐỊNH, 

                // nhưng sẽ vẽ lại các vòng tròn Preview/Analysis với bán kính MỚI.

                drawAllGroups();
                // Xóa preview cũ (nếu có)

                clearPreview();

            });

        }
        // Gọi hàm setup khi DOM đã tải xong

        document.addEventListener('DOMContentLoaded', function () {

            // ... các lệnh khởi tạo khác

            setupRadiusControl(); // ✨ THÊM LỆNH NÀY ✨

        });

        /**
        
         * [ĐÃ SỬA LỖI TUÂN THỦ FILTER] Hàm bật/tắt hiển thị Term ID Label.
        
         * Nhãn chỉ hiển thị khi showTermIDLabels = true VÀ p.isVisible = true.
        
         */

        function toggleTermIDLabels() {

            const button = document.getElementById('termid-toggle-btn');

            if (!button) return;
            // Đảo trạng thái (chỉ thay đổi trạng thái nút, không nhất thiết phải ẩn/hiện ngay)

            showTermIDLabels = !showTermIDLabels;
            // 1. Cập nhật giao diện nút

            if (showTermIDLabels) {

                button.style.cssText = 'background-color: #3b82f6 !important; color: white !important;';

                button.innerHTML = '<i class="fa-solid fa-tag w-4 h-4"></i> <span class="button-text">TermID (Bật)</span>';

                showToast("Đã BẬT: Hiển thị Term ID", 'info');

            } else {

                button.innerHTML = '<i class="fa-solid fa-tag-slash w-4 h-4"></i> <span class="button-text">TermID (Tắt)</span>';

                button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';

                showToast("Đã TẮT: Ẩn Term ID", 'warning');

            }
            // 2. Lặp qua TẤT CẢ các điểm để đồng bộ trạng thái hiển thị nhãn

            allPoints.forEach(p => {

                if (p.nhnn) return; // Bỏ qua NHNN hoặc xử lý riêng nếu cần
                const tooltip = p.termIDTooltip;

                if (tooltip) {

                    // ✨ LOGIC TUÂN THỦ FILTER: Chỉ hiện khi TermID đang BẬT VÀ điểm đang HIỂN THỊ (isVisible) ✨

                    if (showTermIDLabels && p.isVisible) {

                        tooltip.openOn(map);

                    } else {

                        map.closeTooltip(tooltip);

                    }

                }

            });

        }

        /**
        
         * Hàm bật/tắt khối Tìm kiếm/Đo lường.
        
         */

        function toggleSearchPanel() {

            const panel = document.getElementById('search-control-container');

            const button = document.getElementById('search-panel-toggle-btn');

            if (!panel || !button) return;
            // Lấy panel/nút của Rank và Filter (để tắt chúng nếu cần)

            const rankPanel = document.getElementById('rank-table-container');

            const rankButton = document.getElementById('rank-toggle-btn');

            const filterPanel = document.getElementById('filter-controls-container');

            const filterButton = document.getElementById('filter-toggle-btn');
            isSearchPanelOpen = !isSearchPanelOpen;
            if (isSearchPanelOpen) {

                // BẬT PANEL

                panel.classList.add('search-panel-active');

                button.style.cssText = 'background-color: #3b82f6 !important; color: white !important;';

                button.innerHTML = '<i class="fa-solid fa-crosshairs w-4 h-4"></i> <span class="button-text">Tìm/Đo (Bật)</span>';
                showToast("Đã BẬT: Panel Tìm kiếm/Đo lường", 'info');
                // Tắt panel Rank và Filter nếu chúng đang mở

                if (rankPanel && rankPanel.style.display === 'block') {

                    rankPanel.style.display = 'none';

                    if (rankButton) rankButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';

                }

                if (filterPanel && filterPanel.style.display === 'block') {

                    filterPanel.style.display = 'none';

                    if (filterButton) filterButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';

                }
            } else {

                // TẮT PANEL

                panel.classList.remove('search-panel-active');

                button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';

                button.innerHTML = '<i class="fa-solid fa-crosshairs w-4 h-4"></i> <span class="button-text">Tìm/Đo (Tắt)</span>';
                showToast("Đã TẮT: Panel Tìm kiếm/Đo lường", 'warning');

            }

        }

        // (*** MỚI: HÀM CẬP NHẬT LOG KẾT QUẢ ĐO LƯỜNG CỐ ĐỊNH ***)

        function updateMeasurementLog(message, type) {

            const logDiv = document.getElementById('measurement-log');

            if (!logDiv) return;
            // Định dạng màu sắc và icon

            let color = '#333';

            let icon = '';
            if (type === 'route') {

                color = '#d97706'; // Cam (Lái xe)

                icon = '<i class="fa-solid fa-car mr-1"></i>';

            } else if (type === 'straight') {

                color = '#1d4ed8'; // Xanh dương (Chim bay)

                icon = '<i class="fa-solid fa-feather-alt mr-1"></i>';

            } else {

                logDiv.style.display = 'none'; // Ẩn nếu không có dữ liệu

                return;

            }
            logDiv.style.display = 'block';

            logDiv.style.color = color;

            logDiv.innerHTML = `${icon} ${message}`;

        }

        // (*** HÀM CHỈ XÓA GIAO DIỆN CŨ ***)

        // Cần định nghĩa lại hàm này nếu bạn chưa có, hoặc đảm bảo nó nằm ngoài clearMeasurement()

        /**
        
         * Hàm chỉ xóa các đường vẽ và marker trên map (GIỮ LẠI DỮ LIỆU selectedPointA/B).
        
         */

        function clearMapVisuals() {

            // 1. Xóa routing machine nếu có

            if (currentRoutingControl) {

                try {

                    map.removeControl(currentRoutingControl);

                } catch (e) { }

                currentRoutingControl = null;

            }

            // 2. Xóa đường chim bay nếu có

            if (currentStraightLine) {

                measureLayer.removeLayer(currentStraightLine);

                currentStraightLine = null;

            }

            // 3. Xóa các marker tự tạo bởi routing machine (nếu có)

            measureLayer.clearLayers();

        }

        // (Trong function clearMeasurement)

        function clearMeasurement() {
            // ✨ LOGIC MỚI: XÓA HIỆU ỨNG NHẤP NHÁY TRÊN MARKER HIỆN TẠI ✨

            allPoints.forEach(p => {

                const markerElement = p.marker?.getElement();

                if (markerElement) {

                    markerElement.classList.remove('pulsing-marker-A', 'pulsing-marker-B');

                }

            });
            // 1. Xóa giao diện khỏi Map

            clearMapVisuals();
            // 2. Xóa dữ liệu điểm và input

            document.getElementById('search-a-input').value = '';

            document.getElementById('search-b-input').value = '';

            document.getElementById('search-a-results').style.display = 'none';

            document.getElementById('search-b-results').style.display = 'none';
            // Xóa tham chiếu điểm A và B

            selectedPointA = null;

            selectedPointB = null;
            // 3. Xóa log cố định

            updateMeasurementLog('', 'clear');
            showToast("Đã xóa tất cả các đường đo.", "info");

        }
        // (*** HÀM ĐO ĐƯỜNG CHIM BAY - ĐÃ SỬA LỖI midPoint ***)

        function measureStraightLineBetweenAandB(isFallback = false) {

            // [ĐÃ SỬA] Chỉ xóa giao diện cũ (nhưng giữ lại selectedPointA/B)

            clearMapVisuals();
            if (!selectedPointA || !selectedPointB) {

                showToast("Vui lòng chọn cả Điểm Bắt đầu (A) và Điểm Kết thúc (B).", "warning");

                return;

            }
            if (selectedPointA.id === selectedPointB.id) {

                showToast("Hai điểm A và B phải khác nhau.", "warning");

                return;

            }
            if (isBatteryView) {

                toggleBatteryView();

            }
            // 1. Vẽ đường chim bay

            currentStraightLine = L.polyline([selectedPointA.latlng, selectedPointB.latlng], {

                color: '#1a73e8', // Màu xanh dương

                weight: 5,

                opacity: 0.7,

                dashArray: '10, 5' // Đường nét đứt

            }).addTo(measureLayer);
            // 2. Tính khoảng cách

            const distanceMeters = selectedPointA.latlng.distanceTo(selectedPointB.latlng);

            const distanceKm = (distanceMeters / 1000).toFixed(2);
            showToast(`${isFallback ? 'Đường chim bay (Lỗi Routing):' : 'Đo Đường Chim Bay:'} ${distanceKm} km.`, isFallback ? 'warning' : 'success');
            // 3. Focus vào điểm A và B

            // (*** SỬA LỖI midPoint ***)

            const midLat = (selectedPointA.latlng.lat + selectedPointB.latlng.lat) / 2;

            const midLng = (selectedPointA.latlng.lng + selectedPointB.latlng.lng) / 2;

            const centerLatLng = L.latLng(midLat, midLng);
            map.panTo(centerLatLng);

            // (*** KẾT THÚC SỬA LỖI ***)
            // Cập nhật log

            updateMeasurementLog(`Kết quả Đường Chim Bay: ${distanceKm} km`, 'straight');

        }

        // (*** HÀM TÌM KIẾM CHO SEARCH A/B ***)

        function searchMeasurePoint(searchId) {

            const inputId = `search-${searchId.toLowerCase()}-input`;

            const resultsId = `search-${searchId.toLowerCase()}-results`;

            const input = document.getElementById(inputId);

            const resultsContainer = document.getElementById(resultsId);

            const searchTerm = String(input.value).trim().toUpperCase();
            resultsContainer.innerHTML = '';
            if (!searchTerm) {

                resultsContainer.style.display = 'none';

                return;

            }
            const searchResults = allPoints.filter(p =>

                !p.nhnn && (

                    String(p.id).toUpperCase().includes(searchTerm) ||

                    (p.tenHub && String(p.tenHub).toUpperCase().includes(searchTerm))

                )

            );
            if (searchResults.length > 0) {

                resultsContainer.style.display = 'block';
                searchResults.slice(0, 5).forEach(point => {

                    const item = document.createElement('div');

                    item.className = 'search-result-item';
                    let content = `ID: ${point.id}`;

                    if (point.tenHub) {

                        content += `<span class="hub-name"> (${point.tenHub})</span>`;

                    }
                    item.innerHTML = content;

                    item.dataset.pointId = point.id;
                    item.addEventListener('click', () => {

                        selectMeasurePoint(searchId, point);

                        resultsContainer.style.display = 'none';

                    });
                    resultsContainer.appendChild(item);

                });

            } else {

                resultsContainer.style.display = 'none';

            }

        }
        /**
 * (SỬA LỚN) Chọn/Bỏ chọn một điểm làm A hoặc B.
 * Tự động mở Panel Tìm kiếm/Đo lường và điền dữ liệu vào input tương ứng.
 */
function selectMeasurePoint(type, pointData) {
    
    // 1. Cập nhật điểm đã chọn (selectedPointA/B)
    if (type === 'A') {
        selectedPointA = (selectedPointA?.id === pointData?.id) ? null : pointData; 
    } else if (type === 'B') {
        selectedPointB = (selectedPointB?.id === pointData?.id) ? null : pointData;
    }
    
    // 2. Quét TẤT CẢ các Marker và áp dụng/xóa hiệu ứng nhấp nháy (Giữ nguyên logic cũ)
    allPoints.forEach(p => {
        const markerElement = p.marker?.getElement();
        if (!markerElement) return;

        markerElement.classList.remove('pulsing-marker-A', 'pulsing-marker-B');

        if (selectedPointA && p.id === selectedPointA.id) {
            markerElement.classList.add('pulsing-marker-A');
        }
        if (selectedPointB && p.id === selectedPointB.id) {
            markerElement.classList.add('pulsing-marker-B');
        }
    });

    // 3. Tự động đóng popup
    if (currentPopup) {
        map.closePopup(currentPopup);
        currentPopup = null;
    }
    
    // ✨ 4. MỞ PANEL TÌM KIẾM/ĐO LƯỜNG VÀ ĐIỀN DỮ LIỆU ✨
    const panel = document.getElementById('search-control-container');
    const inputA = document.getElementById('search-a-input');
    const inputB = document.getElementById('search-b-input');

    // Mở panel nếu nó đang đóng
    if (!panel.classList.contains('search-panel-active')) {
        toggleSearchPanel();
    }

    // Điền giá trị vào input
    if (type === 'A') {
        inputA.value = selectedPointA ? `${selectedPointA.id} (${selectedPointA.tenHub || 'PGD'})` : '';
    } else if (type === 'B') {
        inputB.value = selectedPointB ? `${selectedPointB.id} (${selectedPointB.tenHub || 'PGD'})` : '';
    }
    
    // 5. Cập nhật nhãn trạng thái A/B trên map (nếu hàm đó tồn tại)
    if (typeof updateStatusLabels === 'function') {
        updateStatusLabels();
    }
    
    showToast(`Đã chọn Điểm ${type}: ${pointData ? pointData.id : 'Bỏ chọn'}`, 'info');
}
        // (*** HÀM CHÍNH ĐO KÍCH THƯỚC LÁI XE - CÓ LOG CỐ ĐỊNH ***)

        function measureRouteBetweenAandB() {

            // [ĐÃ SỬA] Chỉ xóa giao diện cũ (nhưng giữ lại selectedPointA/B)

            clearMapVisuals();
            if (!selectedPointA || !selectedPointB) {

                showToast("Vui lòng chọn cả Điểm Bắt đầu (A) và Điểm Kết thúc (B).", "warning");

                return;

            }
            if (selectedPointA.id === selectedPointB.id) {

                showToast("Hai điểm A và B phải khác nhau.", "warning");

                return;

            }
            // 2. Tắt chế độ Pin (nếu đang bật)

            if (isBatteryView) {

                toggleBatteryView();

            }
            showToast("Đang tính toán tuyến đường lái xe...", 'info');

            updateMeasurementLog("Đang tính toán tuyến đường...", 'route'); // Cập nhật log tạm thời
            // 3. Khởi tạo Leaflet Routing Machine

            const router = L.Routing.control({

                waypoints: [

                    selectedPointA.latlng,

                    selectedPointB.latlng

                ],

                router: L.Routing.osrmv1({

                    serviceUrl: 'https://router.project-osrm.org/route/v1',

                    profile: 'driving'

                }),

                show: false, // ✨ THUỘC TÍNH QUAN TRỌNG: Đặt thành false để ẩn bảng chỉ dẫn

                routeWhileDragging: false,

                createMarker: (i, waypoint, n) => {

                    const pointData = (i === 0) ? selectedPointA : selectedPointB;

                    const icon = isBatteryView ? createBatteryIcon(pointData) : createPGDIcon();

                    return L.marker(waypoint.latLng, {

                        icon: icon,

                        title: (i === 0) ? `Start: ${pointData.id}` : `End: ${pointData.id}`

                    });

                },

                lineOptions: {

                    styles: [{ color: '#f59e0b', weight: 7, opacity: 0.8 }]

                }

            });
            // 4. Bắt sự kiện tuyến đường tìm thấy

            router.on('routesfound', function (e) {

                const route = e.routes[0];

                const distanceKm = (route.summary.totalDistance / 1000).toFixed(2);
                showToast(`Đo kích thước thành công! ${distanceKm} km (Lái xe)`, 'success');

                // (*** LƯU KẾT QUẢ VÀO LOG CỐ ĐỊNH ***)

                updateMeasurementLog(`Kết quả Đo Lái Xe: ${distanceKm} km`, 'route');
                // DÒNG router.getContainer().style.display = 'block'; ĐÃ BỊ XÓA BỎ

            });
            router.on('routingerror', function (e) {

                console.error("Lỗi định tuyến:", e.error);

                showToast(`Lỗi tính toán đường lái xe. Đã vẽ đường chim bay thay thế.`, "error");

                // (*** LƯU KẾT QUẢ VÀO LOG CỐ ĐỊNH ***)

                updateMeasurementLog(`Lỗi Đo Lái Xe. Xem kết quả Đường Chim Bay thay thế.`, 'route');
                // Vẽ đường chim bay để thay thế

                L.polyline([selectedPointA.latlng, selectedPointB.latlng], {

                    color: '#f59e0b',

                    opacity: 0.5,

                    weight: 3,

                    dashArray: '5, 5'

                }).addTo(measureLayer);

            });
            currentRoutingControl = router.addTo(map);
            // Đảm bảo container ẩn (chỉ chứa đường đi, không chứa bảng chi tiết)

            const container = router.getContainer();

            if (container) {

                container.style.display = 'none'; // Đặt thành none để ẩn toàn bộ control (chỉ để lại đường đi)

                container.style.position = 'absolute';

                container.style.top = '10px';

                container.style.left = '10px';

                container.style.zIndex = '2000';

            }

        }

        // Hàm giả định để lấy ID duy nhất cho điểm (nếu bạn chưa có)

        function getUniquePointId(lat, lon) {

            // Có thể dùng hash hoặc kết hợp Lat/Lon thành chuỗi

            return `P_${Math.round(lat * 10000)}_${Math.round(lon * 10000)}`;

        }
        // Hàm giả định để cập nhật hiển thị Marker sau khi nhóm thay đổi

        function updateMarkerIcon(marker, groupColor) {

            // TODO: Triển khai logic thay đổi icon Marker (ví dụ: đổi màu icon pin)

            // Hiện tại: Giả định bạn có hàm renderMarkerIcon(level, amount, color)

            // Ví dụ: marker.setIcon(createBatteryIcon(100, 100000, groupColor));
            // Đơn giản nhất: Thay đổi màu viền icon nếu bạn dùng L.DivIcon

            const element = marker.getElement();

            if (element) {

                const container = element.querySelector('.battery-icon-container');

                if (container) {

                    container.style.borderColor = groupColor;

                }

            }

        }

        /**
        
         * Đặt trung tâm bản đồ và zoom đến vị trí của một Marker.
        
         */

        function setMapCenterFromMarker(pointId) {

            const point = allPoints.find(p => String(p.id) === String(pointId));
            if (!point || !point.latlng) {

                showToast(`Lỗi: Không tìm thấy điểm ID ${pointId} hoặc không có tọa độ.`, "error");

                console.error("Lỗi setMapCenterFromMarker: Không tìm thấy đối tượng điểm trong allPoints hoặc không có latlng.");

                return;

            }
            // [ĐÃ SỬA] Thay thế map.flyTo(..., 15) bằng map.panTo() để giữ nguyên zoom

            map.panTo(point.latlng);
            // (Tùy chọn) Kích hoạt click để mở popup nếu bạn muốn

            if (point.marker) {

                if (currentPopup) {

                    map.closePopup(currentPopup);

                    currentPopup = null;

                }

                point.marker.fire('click');

            }
            showToast(`Đã chuyển đến Tâm Điểm: ${pointId}`, 'info');

        }

/**
 * (FINAL FIX: THÊM TRẠNG THÁI ĐÃ THÊM CHO NÚT ĐỀ XUẤT)
 */
function createActionPopupContent(pointId, currentGroupId, pointName) {
    
    // --- Lấy thông tin và Trạng thái ---
    let isCenterPoint = false;
    const currentGroup = allGroups.find(g => String(g.id) === String(currentGroupId));
    if (currentGroup && String(currentGroup.centerPoint.id) === String(pointId)) {
        isCenterPoint = true;
    }
    
    const isPointA = selectedPointA && selectedPointA.id === pointId;
    const isPointB = selectedPointB && selectedPointB.id === pointId;
    const selectedAData = selectedPointA;
    const selectedBData = selectedPointB;
    
    // ✨ KIỂM TRA TRẠNG THÁI ĐÃ CÓ TRONG DANH SÁCH ĐỀ XUẤT ✨
    const isProposed = proposedPoints.some(p => p.id === pointId);

    let content = `
        <div class="action-popup-header">${pointName || pointId}</div>
        <div class="action-popup-buttons" style="max-height: 350px;">
            
            <div class="button-group" style="margin-top: 0; gap: 8px;">
                <button class="btn-new" onclick="popup_createGroup('${pointId}')" style="flex-grow: 1; width: 100%; color: white;">
                    <i class="fa-solid fa-plus-circle"></i> Tạo HUB Mới
                </button>
            </div>

            ${isProposed ? `
                <button class="btn-measure" onclick="removeProposalFromPopup('${pointId}')" style="flex-grow: 1; width: 100%; background-color: #10b981; color: white; margin-top: 6px;">
                    <i class="fa-solid fa-check"></i> Đã Thêm (Click để xóa)
                </button>` 
            : `
                <button class="btn-add" onclick="addProposalFromPopup('${pointId}')" style="flex-grow: 1; width: 100%; background-color: #38a169; color: white; margin-top: 6px;">
                    <i class="fa-solid fa-star"></i> Thêm vào Đề xuất
                </button>`}
            
            
            ${isCenterPoint ? `
                <button class="btn-move" style="background-color: #dc2626; margin-top: 8px; color: white; width: 100%;" onclick="popup_deleteGroup('${currentGroupId}')">
                    <i class="fa-solid fa-trash-alt"></i> Hủy Nhóm ${currentGroup.groupNumber}
                </button>
            ` : ''}

            <div class="action-popup-header" style="margin-top: 8px;">Đo Lường A/B</div>
            <div class="button-group measure-group" style="margin-top: 0; gap: 8px; grid-template-columns: 1fr 1fr; display: grid;">
                
                ${isPointA ? `
                    <button class="btn-measure btn-a selected-blinking" onclick="selectMeasurePoint('A', null)" style="background: #007bff; color: white; border: 2px solid white;">
                        <span style="font-size: 10px; line-height: 1.2;">Bỏ chọn A:</span> ${pointId}
                    </button>` 
                : (selectedAData ? `
                    <button class="btn-measure btn-a disabled" disabled style="background: #007bff; color: white; opacity: 0.8;">
                        <span style="font-size: 10px; line-height: 1.2;">A Đã Khóa:</span> ${selectedAData.id}
                    </button>` 
                : `
                    <button class="btn-measure btn-a" onclick="selectMeasurePoint('A', allPoints.find(p => p.id === '${pointId}'))" style="background: #007bff; color: white;">
                        <i class="fa-solid fa-location-dot"></i> Điểm A
                    </button>`)}
                
                ${isPointB ? `
                    <button class="btn-measure btn-b selected-blinking" onclick="selectMeasurePoint('B', null)" style="background: #dc3545; color: white; border: 2px solid white;">
                        <span style="font-size: 10px; line-height: 1.2;">Bỏ chọn B:</span> ${pointId}
                    </button>` 
                : (selectedBData ? `
                    <button class="btn-measure btn-b disabled" disabled style="background: #dc3545; color: white; opacity: 0.8;">
                        <span style="font-size: 10px; line-height: 1.2;">B Đã Khóa:</span> ${selectedBData.id}
                    </button>` 
                : `
                    <button class="btn-measure btn-b" onclick="selectMeasurePoint('B', allPoints.find(p => p.id === '${pointId}'))" style="background: #dc3545; color: white;">
                        <i class="fa-solid fa-location-dot"></i> Điểm B
                    </button>`)}
            </div>

            <div class="button-group measure-action-group" style="margin-top: 8px; gap: 8px; grid-template-columns: 1fr 1fr 1fr; display: grid;">
                <button class="btn-measure-action" onclick="measureRouteBetweenAandB()" title="Đo khoảng cách lái xe">
                    <i class="fa-solid fa-car"></i>
                </button>
                <button class="btn-measure-action" onclick="measureStraightLineBetweenAandB()" title="Đo đường chim bay">
                    <i class="fa-solid fa-feather-alt"></i>
                </button>
                <button class="btn-measure-action" onclick="clearMeasurement()" title="Xóa điểm đo">
                    <i class="fa-solid fa-trash-alt"></i>
                </button>
            </div>
            
            <hr style="margin: 8px 0; border-top: 1px solid #ddd;">

            <div class="action-popup-header">Chuyển Nhóm</div>
            <div class="button-group" style="margin-top: 0; gap: 4px; grid-template-columns: 1fr 1fr; display: grid;">
    `;
    
    // Logic Chuyển Nhóm (Giữ nguyên)
    const availableGroups = Object.keys(groups).filter(
        groupName => groups[groupName].id !== currentGroupId
    );
    
    const getTextColor = (bgColor) => {
        const color = (bgColor.charAt(0) === '#') ? bgColor.substring(1, 7) : bgColor;
        const r = parseInt(color.substring(0, 2), 16); 
        const g = parseInt(color.substring(2, 4), 16); 
        const b = parseInt(color.substring(4, 6), 16); 
        const uicolors = [r / 255, g / 255, b / 255];
        const c = uicolors.map((col) => {
            if (col <= 0.03928) { return col / 12.92; }
            return Math.pow((col + 0.055) / 1.055, 2.4);
        });
        const luminance = (0.2126 * c[0]) + (0.7152 * c[1]) + (0.0722 * c[2]);
        return (luminance > 0.179) ? '#000000' : '#FFFFFF'; 
    };

    if (availableGroups.length > 0) {
        availableGroups.forEach(groupName => {
            const groupId = groups[groupName].id;
            const groupColor = groups[groupName].color;
            const groupNumber = groupName.split(' ')[1]; 
            
            const textColor = getTextColor(groupColor);

            content += `
                <button 
                    class="btn-move" 
                    style="background-color: ${groupColor}; padding: 6px 4px; font-size: 12px; height: 40px; color: ${textColor};"
                    onclick="movePointToGroup('${pointId}', '${groupId}')"
                >
                    <i class="fas fa-layer-group"></i> HUB ${groupNumber}
                </button>
            `;
        });
    } else {
        content += `<div style="grid-column: span 2; text-align: center; color: #555;" class="action-popup-info">Chưa có nhóm nào khác để chuyển đến.</div>`;
    }

    content += `</div>`;
    return content;
}
/**
 * Thêm điểm hiện tại (từ Popup) vào danh sách đề xuất để tối ưu hóa.
 * Tự động mở Panel Tìm kiếm/Đo lường VÀ đóng Popup Hành động.
 * @param {string} pointId - ID của điểm cần thêm.
 */
function addProposalFromPopup(pointId) {
    if (proposedPoints.length >= 5) {
        showToast("Chỉ được đề xuất tối đa 5 điểm.", "error");
        return;
    }
    
    const point = allPoints.find(p => p.id === pointId);
    if (!point) return;

    if (proposedPoints.some(p => p.id === pointId)) {
        showToast(`Điểm ${pointId} đã có trong danh sách.`, "warning");
        return;
    }

    // Thêm điểm
    proposedPoints.push({...point}); 
    renderProposalList();

    // 1. Mở Panel Tìm kiếm/Đo lường (nếu đang đóng)
    const panel = document.getElementById('search-control-container');
    if (!panel.classList.contains('search-panel-active')) {
        toggleSearchPanel();
    }
    
    // 2. Đóng Popup Hành động
    if (currentPopup) {
        map.closePopup(currentPopup);
        currentPopup = null;
    }
    showToast(`Đã thêm ${pointId} vào danh sách đề xuất.`, "info");
}

/**
 * Xóa điểm khỏi danh sách đề xuất và đảm bảo đồng bộ hóa UI (Sidebar & Popup).
 * Hàm này được gọi khi click nút X trên Sidebar HOẶC nút "Đã Thêm (Click để xóa)" trong Popup.
 * @param {string} pointId - ID của điểm cần xóa.
 */
function removeProposal(pointId) {
    // 1. Xóa khỏi mảng proposedPoints
    const initialLength = proposedPoints.length;
    proposedPoints = proposedPoints.filter(p => p.id !== pointId);

    if (proposedPoints.length === initialLength) {
        showToast(`Không tìm thấy điểm ${pointId} trong danh sách đề xuất.`, "error");
        return;
    }
    
    // 2. Cập nhật danh sách bên Sidebar
    if (typeof renderProposalList === 'function') {
        renderProposalList();
    }
    
    // 3. Đồng bộ hóa trạng thái Popup/Ghim Bản đồ (Đóng Popup nếu nó đang hiển thị điểm bị xóa)
    if (currentPopup && currentPopup.getContent() && currentPopup.getContent().includes(pointId)) {
        map.closePopup(currentPopup);
        currentPopup = null;
    }
    
    showToast(`Đã xóa ${pointId} khỏi danh sách đề xuất.`, "warning");
}
        /**
        
         * (SỬA LỖI CHÍNH) Hàm chuyển một điểm từ nhóm cũ sang nhóm mới (gọi từ Popup).
        
         * Đã: 1. Đóng Popup sau khi chuyển (Fix Lỗi 3). 2. Đảm bảo loại trừ lẫn nhau (Fix Lỗi 2).
        
         */

        function movePointToGroup(pointId, targetGroupId) {

            // 1. Tìm thông tin nhóm mới

            const newGroupNameKey = Object.keys(groups).find(key => groups[key].id === targetGroupId);

            const newGroup = allGroups.find(g => String(g.id) === String(targetGroupId));
            // Tìm điểm cần chuyển

            const pointToMove = allPoints.find(p => String(p.id) === String(pointId));
            if (!pointToMove || !newGroup || !newGroupNameKey) {

                showToast("Lỗi: Không tìm thấy điểm hoặc nhóm đích.", "error");

                return;

            }
            const oldGroupId = pointToMove.groupId;
            if (oldGroupId === targetGroupId) {

                showToast(`Điểm ${pointId} đã ở trong ${newGroupNameKey}.`, "warning");

                if (currentPopup) map.closePopup(); // Fix Lỗi 3: Đóng popup

                return;

            }
            // === 2. XÓA ĐIỂM KHỎI NHÓM CŨ (MUTUAL EXCLUSION) ===

            if (oldGroupId) {

                const oldGroup = allGroups.find(g => String(g.id) === String(oldGroupId));

                if (oldGroup) {

                    // Xóa khỏi danh sách points trong allGroups (dữ liệu map)

                    oldGroup.points = oldGroup.points.filter(p => p.id !== pointToMove.id);

                }
                // Đồng bộ biến 'groups' (cho UI Popup) - XÓA KHỎI DANH SÁCH ID

                const oldGroupNameKey = Object.keys(groups).find(key => groups[key].id === oldGroupId);

                if (groups[oldGroupNameKey]) {

                    groups[oldGroupNameKey].pointIds = groups[oldGroupNameKey].pointIds.filter(id => id !== pointToMove.id);

                }

            }

            // =========================================================
            // 3. Cập nhật ID nhóm mới cho điểm và thêm vào nhóm mới

            pointToMove.groupId = targetGroupId;

            newGroup.points.push(pointToMove);
            // 4. Đồng bộ biến 'groups' (cho UI Popup) - THÊM VÀO DANH SÁCH ID

            if (!groups[newGroupNameKey].pointIds.includes(pointToMove.id)) {

                groups[newGroupNameKey].pointIds.push(pointToMove.id);

            }
            // 5. Cập nhật hiển thị và ĐÓNG POPUP (Fix Lỗi 3)

            if (currentPopup) map.closePopup();
            drawAllGroups();

            updateRankTable();

            updateFilterOptions();
            Toastify({

                text: `Đã chuyển điểm ${pointId} sang ${newGroupNameKey}`,

                className: "custom-toast success",

            }).showToast();

        }

        /**
        
         * (MỚI) Tìm và trả về đối tượng Leaflet Marker từ ID điểm
        
         */

        function getMarkerByPointId(pointId) {

            // Trả về Marker từ bản đồ lưu trữ

            return allMarkers[pointId];

        }

        /**
        
         * Hàm Khởi tạo và Thêm Marker vào Map
        
         */

        function createAndAddMarker(lat, lon, data) {

            // 1. Tạo Marker (Marker KHÔNG CÓ Popup TĨNH lúc này)

            const pointId = data.pointId || getUniquePointId(lat, lon);

            const marker = L.marker([lat, lon], {

                // ... các tùy chọn icon ...

            });
            marker.pointId = pointId; // Lưu ID vào đối tượng Marker

            marker.data = data; // Lưu dữ liệu gốc
            // 2. GẮN SỰ KIỆN CLICK để mở Popup HÀNH ĐỘNG

            marker.on('click', function (e) {
                // --- 2.1. Tìm Nhóm Hiện Tại ---

                let currentGroupId = null;

                for (const name in groups) {

                    if (groups[name].pointIds.includes(marker.pointId)) {

                        currentGroupId = groups[name].id;

                        break;

                    }

                }
                // --- 2.2. Tạo Nội Dung Popup ĐỘNG ---

                // SỬ DỤNG HÀM MÀ TÔI VỪA CHỈ BẠN

                const content = createActionPopupContent(marker.pointId, currentGroupId);
                // --- 2.3. Gán Popup MỚI và Mở ---

                marker.unbindPopup(); // RẤT QUAN TRỌNG: Gỡ bỏ popup cũ

                marker.bindPopup(content, {

                    className: 'action-popup', // Áp dụng CSS Hành Động

                    closeButton: true,

                    offset: L.point(0, -10)

                }).openPopup();

            });
            // 3. Thêm Marker vào Map

            marker.addTo(map);

            return marker;

        }

        /** * Ví dụ về cách tạo một mục kết quả tìm kiếm
        
         * và gán Tooltip tùy chỉnh (dùng thuộc tính data-title)
        
         */

        function createSearchResultItem(fullText, hubName) {

            const item = document.createElement('div');

            item.className = 'search-result-item';
            // *** BƯỚC QUAN TRỌNG: Gán nội dung đầy đủ vào data-title ***

            // Thay item.title = fullText;

            item.setAttribute('data-title', fullText);
            // Phần hiển thị trên bảng kết quả (có thể bị cắt)

            const displayLength = 30;

            const truncatedText = fullText.length > displayLength

                ? fullText.substring(0, displayLength) + '...'

                : fullText;
            item.innerHTML = `${truncatedText} <span class="hub-name"> (${hubName})</span>`;
            return item;

        }
        // Ví dụ sử dụng:

        const container = document.getElementById('search-results-container');

        const longDescription = "Tòa nhà này là Trụ sở chính và điểm giao dịch lớn nhất của ngân hàng ABC tại trung tâm thành phố.";

        const hubInfo = "Hub A";
        const resultItem = createSearchResultItem(longDescription, hubInfo);

        container.appendChild(resultItem);

        /**
        
         * (ĐÃ SỬA LỖI UI) Hàm tìm kiếm điểm trên bản đồ theo TERMID hoặc Tên HUB.
        
         * Hiện thị kết quả và thêm nút "Đề xuất" bằng phương pháp gán Node an toàn.
        
         */

        function searchByTermId() {

            const input = document.getElementById('termid-search-input');

            const resultsContainer = document.getElementById('search-results-container');

            const searchTerm = String(input.value).trim().toUpperCase();
            // Xóa kết quả cũ

            resultsContainer.innerHTML = '';
            if (!searchTerm) {

                resultsContainer.style.display = 'none';

                showToast("Vui lòng nhập Mã CN hoặc Tên HUB để tìm kiếm.", "warning");

                return;

            }
            // Lọc các điểm (PGD/ATM) dựa trên TERMID hoặc TENHUB

            const searchResults = allPoints.filter(p =>

                !p.nhnn && (

                    String(p.id).toUpperCase().includes(searchTerm) ||

                    (p.tenHub && String(p.tenHub).toUpperCase().includes(searchTerm))

                )

            );
            if (searchResults.length > 0) {

                resultsContainer.style.display = 'block';
                searchResults.slice(0, 10).forEach(point => { // Giới hạn 10 kết quả

                    const item = document.createElement('div');

                    // Sử dụng class flex để căn chỉnh nội dung và nút

                    item.className = 'search-result-item flex justify-between items-center';

                    item.dataset.pointId = point.id;
                    // 1. Xây dựng Nội dung (ID/Tên HUB)

                    let contentSpan = document.createElement('span');

                    contentSpan.className = 'flex-1 overflow-hidden whitespace-nowrap text-ellipsis mr-2';

                    let content = `ID: ${point.id}`;

                    if (point.tenHub) {

                        content += `<span class="hub-name"> (${point.tenHub})</span>`;

                    }

                    contentSpan.innerHTML = content;
                    // 2. Xây dựng Nút "Đề xuất"

                    const addButton = document.createElement('button');

                    addButton.className = 'flex-shrink-0 px-2 py-1 bg-green-500 text-white text-xs rounded hover:bg-green-600';

                    addButton.textContent = 'Đề xuất';
                    // Ngăn chặn sự kiện click lan truyền và gọi hàm addProposal

                    addButton.onclick = (e) => {

                        e.stopPropagation();

                        addProposal(point.id);

                    };
                    // 3. Gắn các phần tử vào Item chính (Dùng appendChild để tránh lỗi ghi đè)

                    item.appendChild(contentSpan); // Thêm nội dung

                    item.appendChild(addButton);   // Thêm nút


                    // Gắn sự kiện click để focus vào điểm (cho toàn bộ dòng)

                    item.addEventListener('click', () => {

                        focusOnPoint(point.id);

                        resultsContainer.style.display = 'none'; // Ẩn danh sách sau khi click

                        input.value = point.id; // Đặt TERMID vào ô tìm kiếm

                    });
                    resultsContainer.appendChild(item);

                });
                showToast(`Tìm thấy ${searchResults.length} kết quả.`, "info");

            } else {

                resultsContainer.style.display = 'none';

                showToast(`Không tìm thấy kết quả nào với từ khóa: ${searchTerm}`, "error");

            }

        }

        // (XÓA v35) Xóa bỏ CHI_NHANH_TO_VUNG_MAP, vì VUNG giờ đã có trong data
        // --- 1. KHAI BÁO BIẾN TOÀN CỤC BẰNG LET (FIX LỖI ReferenceError) ---

        let map = null;

        let clusterLayer = null;

        let standardLayer = null;

        let analysisLayer = null;

        let nhnnMarkersLayer = null;

        let previewLayer = null;

        let measureLayer = null; // Layer mới

        let pointMarkersLayer = null;

        let isSearchPanelOpen = false;

        let showTermIDLabels = true;

        let isOptimizationResultVisible = false; // ✨ MỚI: Theo dõi trạng thái vòng tròn tối ưu

        let proposedPoints = []; // Danh sách tối đa 5 điểm đề xuất

        // --- 2. Biến lưu trữ & Cấu hình (Giữ nguyên) ---

        let currentRadiusKm = 30; // Bán kính hiện tại (km)

        let RADIUS_METERS = 30000; // Bán kính hiện tại (mét)

        const GROUP_COLORS = [

            '#E6194B', '#F032E6', '#FFE119', '#4363D8', '#F58231', '#911EB4',

            '#008080', '#F032E6', '#BCF60C', '#FABEBE', '#008080', '#E6BEFF'

        ];

        const PREVIEW_COLOR = '#f59e0b';

        const NHNN_PREVIEW_LINE_COLOR = '#004aad';

        const OVERFLOW_COLOR = '#8b5cf6';
        let allPoints = [];

        let selectedPointA = null; // Lưu trữ dữ liệu điểm từ Search A

        let selectedPointB = null; // Lưu trữ dữ liệu điểm từ Search B

        let currentRoutingControl = null; // Lưu trữ đối tượng định tuyến hiện tại

        let currentStraightLine = null; // <<< ĐÃ THÊM BIẾN NÀY <<<

        let allGroups = [];

        let currentRankings = [];

        let currentPopup = null;

        let routingQueue = [];

        let isProcessingQueue = false;

        let groups = {};

        const ROUTING_DELAY_MS = 500;

        let allMarkers = {};

        let isBirdMode = true;

        let isBatteryView = false;

        let showDistanceLabels = true;

        let isClusteringEnabled = false;

        let showNhnnMarkers = true;

        // 3. HÀM KHỞI TẠO MAP VÀ LAYERS (Đã chỉnh sửa để gán cho các biến LET trên)

        function initializeMapAndLayers() {

            // Khởi tạo Map

            map = L.map('map').setView([21.0285, 105.8542], 13);

            map.createPane('borderPane');

            map.getPane('borderPane').style.zIndex = 399;

            L.tileLayer('http://{s}.google.com/vt/lyrs=r&x={x}&y={y}&z={z}&styles=feature:road|element:labels.text|visibility:off', {

                attribution: '&copy; Google Maps',

                subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],

                maxZoom: 20

            }).addTo(map);
            // Khởi tạo Layers và thêm vào map nếu cần

            clusterLayer = L.markerClusterGroup({

                chunkedLoading: true, maxClusterRadius: 70, disableClusteringAtZoom: 17, spiderfyOnMaxZoom: true, showCoverageOnHover: true,

                iconCreateFunction: function (cluster) {

                    const childCount = cluster.getChildCount();

                    let cname = 'my-cluster-icon ';

                    if (childCount < 10) { cname += 'small'; } else if (childCount < 100) { cname += 'medium'; } else { cname += 'large'; }

                    return L.divIcon({ html: `<div><span>${childCount}</span></div>`, className: cname, iconSize: L.point(40, 40) });

                }

            });

            standardLayer = L.layerGroup();

            analysisLayer = L.layerGroup().addTo(map);

            nhnnMarkersLayer = L.layerGroup().addTo(map);

            previewLayer = L.layerGroup([], { interactive: false }).addTo(map);
            // Layer đo lường mới

            measureLayer = L.layerGroup().addTo(map);
            pointMarkersLayer = isClusteringEnabled ? clusterLayer : standardLayer;

            map.addLayer(pointMarkersLayer);
        }

        initializeMapAndLayers();
        // Chạy khởi tạo map và layers


        // --- 3. Tạo Icon Tùy chỉnh (Động) ---
        // (SỬA v33) Hàm này giờ CHỦ YẾU dùng cho Tâm Nhóm (★)

        function createPointIcon(color, text = '') {

            return L.divIcon({

                className: 'point-icon',

                iconSize: [22, 22],

                iconAnchor: [11, 11],

                html: `<div style="background-color: ${color};" class="point-icon">${text}</div>`

            });

        }
        function createCenterPointIcon(color) {

            return L.divIcon({

                className: 'center-point-icon',

                iconSize: [24, 24],

                iconAnchor: [12, 12],

                html: `<div style="background-color: ${color};" class="center-point-icon">★</div>`

            });

        }
        /**
    
         * Icon cho điểm NHNN - Dùng ảnh (Code của bạn)
    
         */

        function createNHNNIcon() {

            const imageUrl = 'photo/icons8-bank-60.png';
            return L.icon({

                iconUrl: imageUrl,

                iconSize: [30, 30],

                iconAnchor: [15, 30], // [một nửa rộng, chiều cao]

                popupAnchor: [0, -30], // [0, -chiều cao]

                shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',

                shadowSize: [41, 41],

                shadowAnchor: [12, 41] // Giữ nguyên shadow anchor

            });

        }
        /**
    
         * (HÀM MỚI v33) Icon cho PGD/ATM (điểm thường)
    
         */

        function createPGDIcon() {

            // *** ĐÂY LÀ ẢNH ICON PGD CỦA BẠN ***

            const imageUrl = 'photo/icons8-place-marker-94.png';
            return L.icon({

                iconUrl: imageUrl,

                iconSize: [30, 30],

                iconAnchor: [15, 30],

                popupAnchor: [0, -30],

                shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',

                shadowSize: [41, 41],

                shadowAnchor: [12, 41]

            });

        }
        /**
    
         * (MỚI v39) Hàm định dạng tiền
    
         */

        function formatCurrency(value) {

            if (value >= 1000000000) {

                return (value / 1000000000).toFixed(1).replace('.0', '') + ' B';

            }

            if (value >= 1000000) {

                return (value / 1000000).toFixed(1).replace('.0', '') + ' M';

            }

            if (value >= 1000) {

                return (value / 1000).toFixed(1).replace('.0', '') + ' K';

            }

            return value;

        }
        /**
    
         * (MỚI v39) Hàm định dạng số đầy đủ
    
         */

        function formatFullNumber(value) {

            return new Intl.NumberFormat('vi-VN').format(value);

        }
        /**
        
         * Icon Pin với nhãn tiền VƯỢT HẠN MỨC
        
         * * @param {object} pointData - Dữ liệu điểm, chứa thuộc tính isBatteryPoint.
        
         * @returns {L.DivIcon | L.Icon} - Trả về icon Pin nếu là TSCN, nếu không trả về icon PGD chuẩn.
        
         */

        function createBatteryIcon(pointData) {
            // (*** LOGIC MỚI: Lọc theo thuộc tính isBatteryPoint/TSCN ***)

            // Nếu điểm KHÔNG PHẢI là TSCN, trả về icon PGD tiêu chuẩn.

            if (!pointData.isBatteryPoint) {

                return createPGDIcon();

            }

            // (*** KẾT THÚC LOGIC BỔ SUNG ***)
            let tonQuy = pointData.tonQuy || 0;

            let hanMuc = pointData.hanMuc || 0;
            // Tránh lỗi chia cho 0

            if (hanMuc === 0) {

                if (tonQuy > 0) { hanMuc = tonQuy; } else { hanMuc = 1; }

            }
            let percentage = (tonQuy / hanMuc) * 100;

            let fillPercent = Math.min(100, percentage);

            let overflowPercent = 0;

            let fillColor = '#16a34a'; // Xanh lá cây
            if (percentage >= 80 && percentage < 100) {

                fillColor = '#f59e0b'; // Vàng

            } else if (percentage >= 100) {

                fillColor = '#dc2626'; // Đỏ

            }
            percentage = Math.round(percentage);

            let amountLabelHtml = '';
            if (pointData.vuotHanMuc && tonQuy > hanMuc) {

                const overflowAmount = tonQuy - hanMuc;

                const formattedOverflowAmount = formatCurrency(overflowAmount);

                amountLabelHtml = `<div class="battery-amount-label">+${formattedOverflowAmount}</div>`;

                overflowPercent = Math.min(100, (overflowAmount / hanMuc) * 100);

            }
            let html = `

        <div class="battery-icon-div-wrapper"> 

            <div class="battery-icon-container">

                <div class="battery-fill" style="width: ${fillPercent}%; background-color: ${fillColor};"></div>

                ${overflowPercent > 0 ?

                    `<div class="battery-overflow" style="width: ${overflowPercent}%; background-color: ${OVERFLOW_COLOR};"></div>` : ''}

                <span class="battery-text">${percentage}%</span>

            </div>

            ${amountLabelHtml} </div>

    `;
            return L.divIcon({

                className: 'battery-icon',

                html: html,

                iconSize: [0, 0],

                iconAnchor: [0, 0]

            });

        }
        // (*** MỚI v48 ***) HÀM TOGGLE ĐÃ ĐƯỢC DI CHUYỂN RA ĐÚNG VỊ TRÍ
        /**
    
         * (MỚI v43) Hàm Bật/Tắt hiển thị nhãn khoảng cách (km)
    
         */

        function toggleDistanceLabels() {

            // 1. Đảo ngược trạng thái

            showDistanceLabels = !showDistanceLabels;

            const button = document.getElementById('labels-toggle-btn');
            if (currentPopup) map.closePopup(currentPopup);
            // 2. Cập nhật nút

            if (showDistanceLabels) {

                button.innerHTML = '<i class="fa-solid fa-tag w-4 h-4"></i> <span class="button-text">Nhãn KM (Bật)</span>';

                button.classList.add('labels-on');

                button.classList.remove('labels-off');

                showToast("Đã BẬT: Hiển thị nhãn KM", 'info');

            } else {

                // (Sửa icon) Dùng fa-tag-slash cho đẹp hơn

                button.innerHTML = '<i class="fa-solid fa-tag-slash w-4 h-4"></i> <span class="button-text">Nhãn KM (Tắt)</span>';

                button.classList.add('labels-off');

                button.classList.remove('labels-on');

                showToast("Đã TẮT: Hiển thị nhãn KM", 'warning');

            }
            // 3. Vẽ lại các nhóm

            drawAllGroups();
            // 4. Xóa preview (nếu có) để nó tự vẽ lại đúng khi hover

            clearPreview();

        }
        // (*** SỬA v50 ***) Sửa logic Bật/Tắt (Không đóng menu ☰)

        function toggleRankPanel() {

            const panel = document.getElementById('rank-table-container');

            const button = document.getElementById('rank-toggle-btn');

            if (!panel || !button) return;
            // Lấy panel/nút của Filter

            const filterPanel = document.getElementById('filter-controls-container');

            const filterButton = document.getElementById('filter-toggle-btn');
            if (panel.style.display === 'block') {

                // Đang Bật -> Tắt nó đi

                panel.style.display = 'none';

                button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt

            } else {

                // Đang Tắt -> Bật nó lên

                panel.style.display = 'block';

                button.style.cssText = 'background-color: #3b82f6 !important; color: white !important;'; // Style Bật
                // (SỬA v50) Tắt panel kia (nếu đang mở)

                if (filterPanel) filterPanel.style.display = 'none';

                if (filterButton) filterButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt

            }
            // (*** LỖI ĐÃ XÓA ***) Không còn dòng code đóng menu ☰ ở đây

        }
        // (SỬA v50) Sửa logic Bật/Tắt (Không đóng menu ☰)

        function toggleFilterControls() {

            const controls = document.getElementById('filter-controls-container');

            const button = document.getElementById('filter-toggle-btn');

            if (!controls || !button) return;
            // Lấy panel/nút của Rank

            const rankPanel = document.getElementById('rank-table-container');

            const rankButton = document.getElementById('rank-toggle-btn');
            if (controls.style.display === 'block') {

                controls.style.display = 'none';

                button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt

            } else {

                controls.style.display = 'block';

                button.style.cssText = 'background-color: #6b7280 !important; color: white !important;'; // Style Bật
                // (SỬA v50) Tắt panel kia (nếu đang mở)

                if (rankPanel) rankPanel.style.display = 'none';

                if (rankButton) rankButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt

            }
            // (*** LỖI ĐÃ XÓA ***) Không còn dòng code đóng menu ☰ ở đây

        }
        // --- 4. Thêm Nút điều khiển ---
        // (SỬA v50) Cập nhật Nút Thu Gọn + Style mặc định

        L.Control.MasterControls = L.Control.extend({

            onAdd: function (map) {

                // 1. Tạo container chính

                const container = L.DomUtil.create('div', 'leaflet-bar custom-controls-container');

                L.DomEvent.disableClickPropagation(container);
                // 2. (MỚI v47) Nút Bật/Tắt Panel (Hamburger)

                const toggleButton = L.DomUtil.create('button', 'leaflet-bar-part', container);

                toggleButton.id = 'panel-toggle-btn';

                toggleButton.innerHTML = '<i class="fa-solid fa-bars"></i>'; // Icon Hamburger
                // (*** SỬA LỖI v48.1 ***)

                toggleButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    // Logic Bật/Tắt class 'expanded' trên container chính

                    if (L.DomUtil.hasClass(container, 'expanded')) {

                        L.DomUtil.removeClass(container, 'expanded');

                    } else {

                        L.DomUtil.addClass(container, 'expanded');

                    }

                };
                // 3. (MỚI v47) Wrapper cho tất cả các nút con

                const buttonsWrapper = L.DomUtil.create('div', 'buttons-wrapper', container);
                // --- 4. Bắt đầu các nút con ---
                // (*** MỚI v50 ***) Nút ĐÓNG (Collapse) Panel

                const collapseButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);

                collapseButton.id = 'panel-collapse-btn';

                collapseButton.innerHTML = '<i class="fa-solid fa-chevron-right w-4 h-4"></i>';

                collapseButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    L.DomUtil.removeClass(container, 'expanded');

                };

                
                // (*** MỚI v48 ***) Nút Bảng Xếp Hạng (Toggle)

                const rankButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);

                rankButton.id = 'rank-toggle-btn';

                rankButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';

                rankButton.innerHTML = '<i class="fa-solid fa-trophy w-4 h-4"></i> <span class="button-text">Xếp Hạng</span>';

                rankButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    toggleRankPanel(); // Hàm mới

                };

                rankButton.style.display = 'none';

                // Thêm nút này bên trong buttonsWrapper trong MasterControls
const autoGroupButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg btn-new', buttonsWrapper);
autoGroupButton.id = 'auto-group-btn';
autoGroupButton.innerHTML = '<i class="fa-solid fa-list-ol w-4 h-4"></i> <span class="button-text">Tạo Top 20 Hub</span>';
autoGroupButton.onclick = (e) => {
    L.DomEvent.stopPropagation(e);
    createTop20Groups(); // Gọi hàm tự động tạo nhóm
};
                // (*** MỚI v48 ***) Nút Tùy Chỉnh Map (Filter)

                const filterButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);

                filterButton.id = 'filter-toggle-btn';

                filterButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';

                filterButton.innerHTML = '<i class="fa-solid fa-sliders w-4 h-4"></i> <span class="button-text">Tùy Chỉnh Map</span>';

                filterButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    toggleFilterControls();

                };

                // Nút Bật/Tắt Search Panel

                const searchToggleButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);

                searchToggleButton.id = 'search-panel-toggle-btn';

                searchToggleButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';

                searchToggleButton.innerHTML = '<i class="fa-solid fa-crosshairs w-4 h-4"></i> <span class="button-text">Tìm/Đo (Tắt)</span>';

                searchToggleButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    toggleSearchPanel(); // Hàm mới

                };

                // Nút Bật/Tắt TermID Labels

                const termIDToggleBtn = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);

                termIDToggleBtn.id = 'termid-toggle-btn';

                termIDToggleBtn.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;';

                termIDToggleBtn.innerHTML = '<i class="fa-solid fa-tag w-4 h-4"></i> <span class="button-text">TermID (Tắt)</span>';

                termIDToggleBtn.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    toggleTermIDLabels(); // Gọi hàm bật/tắt

                };

                // Nút Routing

                const routingButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg bird-mode', buttonsWrapper);

                routingButton.id = 'routing-toggle-btn';

                routingButton.innerHTML = '<i class="fa-solid fa-feather w-4 h-4"></i> <span class="button-text">Đường chim Bay</span>';

                routingButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    toggleRoutingMode();

                };
                // Nút Chế độ Pin (FIX LỖI: Gọi hàm trực tiếp)

                const batteryButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg pin-mode', buttonsWrapper);

                batteryButton.id = 'battery-toggle-btn';

                batteryButton.innerHTML = '<i class="fa-solid fa-battery-half w-4 h-4"></i> <span class="button-text">Chế độ Pin</span>';

                batteryButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    // GỌI HÀM AN TOÀN HƠN

                    if (typeof toggleBatteryView === 'function') {

                        toggleBatteryView();

                    } else {

                        console.error("Hàm toggleBatteryView chưa được định nghĩa.");

                    }

                };
                // Nút Bật/Tắt Gom Cụm

                const clusterButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg cluster-off', buttonsWrapper);

                clusterButton.id = 'cluster-toggle-btn';

                clusterButton.innerHTML = '<i class="fa-solid fa-braille w-4 h-4"></i> <span class="button-text">Gom Cụm (Tắt)</span>';

                clusterButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    toggleClustering();

                };
                // Nút Bật/Tắt Nhãn KM

                const labelsButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg labels-on', buttonsWrapper);

                labelsButton.id = 'labels-toggle-btn';

                labelsButton.innerHTML = '<i class="fa-solid fa-tag w-4 h-4"></i> <span class="button-text">Nhãn KM (Bật)</span>';

                labelsButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    toggleDistanceLabels();

                };
                // Nút Bật/Tắt NHNN

                const nhnnButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg nhnn-on', buttonsWrapper);

                nhnnButton.id = 'nhnn-toggle-btn';

                nhnnButton.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i> <span class="button-text">Ẩn NHNN</span>';

                nhnnButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    toggleNhnn();

                };

                // (*** MỚI ***) Nút LƯU/EXPORT DỮ LIỆU NHÓM

                const saveButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg btn-add', buttonsWrapper);

                saveButton.id = 'save-groups-btn';

                saveButton.innerHTML = '<i class="fa-solid fa-cloud-arrow-up w-4 h-4"></i> <span class="button-text">Lưu Dữ Liệu Nhóm</span>';

                saveButton.onclick = (e) => {

                    L.DomEvent.stopPropagation(e);

                    exportGroupsData(); // Gọi hàm xử lý chính

                };

                // --- Hết các nút con ---
                // (MỚI v47) Khi click vào bản đồ, đóng panel (nếu đang mở trên di động)

                map.on('click', () => { L.DomUtil.removeClass(container, 'expanded'); });

                map.on('dragstart', () => { L.DomUtil.removeClass(container, 'expanded'); });
                return container;

            },

            onRemove: function (map) { }

        });
        // Thêm control mới vào bản đồ (Chắc chắn chạy sau initializeMapAndLayers())

        new L.Control.MasterControls({ position: 'topright' }).addTo(map);

        // --- 5. Các Hàm Chức năng ---

        // Tên khóa dùng để lưu trữ trong localStorage

        const LOCAL_STORAGE_KEY = 'HMTQ_SAVED_GROUPS_V2'; // Dùng V2 để đảm bảo lưu Polyline Cache
        /**
        
         * (SỬA ĐỔI) Hàm xuất và LƯU dữ liệu nhóm đã tạo vào Local Storage.
        
         */

        function exportGroupsData() {

            if (allGroups.length === 0) {

                // Xóa dữ liệu cũ nếu không còn nhóm nào

                localStorage.removeItem(LOCAL_STORAGE_KEY);

                showToast("Đã xóa dữ liệu nhóm cũ trong trình duyệt.", "warning");

                return;

            }
            // 1. Chuyển đổi dữ liệu thô sang cấu trúc gọn gàng

            const exportedData = allGroups.map(group => {

                // Lọc ra ID của tất cả các điểm trong nhóm (bao gồm điểm tâm)

                const memberIds = group.points.map(p => p.id);
                return {

                    group_id: group.id,

                    group_number: group.groupNumber,

                    color: group.color,

                    center_point: {

                        id: group.centerPoint.id,

                        lat: group.centerPoint.latlng.lat,

                        lon: group.centerPoint.latlng.lng,

                    },

                    // ✨ SỬA LỖI: LƯU BÁN KÍNH CỐ ĐỊNH HIỆN TẠI ✨

                    fixedRadiusMeters: group.fixedRadiusMeters,

                    fixedRadiusKm: group.fixedRadiusKm,

                    member_ids: memberIds, // <--- ĐÃ GOM CẢ ĐIỂM TÂM

                    // LƯU CACHE POLYLINE 

                    polyline_cache: group.polylineCache,

                    member_count: memberIds.length

                };

            });
            const jsonOutput = JSON.stringify(exportedData);
            // 2. LƯU VÀO LOCAL STORAGE

            try {

                localStorage.setItem(LOCAL_STORAGE_KEY, jsonOutput);

                console.log("=== DỮ LIỆU NHÓM ĐÃ LƯU VÀO LOCAL STORAGE ===");

                console.log(JSON.parse(jsonOutput));

                showToast("Đã lưu trạng thái nhóm thành công!", "success");

            } catch (e) {

                showToast("Lỗi lưu trữ! Trình duyệt quá đầy hoặc đang ở chế độ ẩn danh.", "error");

            }

        }
        // (MỚI) Hàm hỗ trợ lấy dữ liệu điểm gốc từ ID

        function getPointDataById(pointId) {

            return allPoints.find(p => p.id === pointId);

        }
        /**
        
         * (SỬA LỖI PHỤC HỒI CACHE) Hàm tải và phục hồi dữ liệu nhóm đã lưu.
        
         * @param {Array} savedGroupsData - Dữ liệu JSON đã lưu trữ.
        
         */

        function loadSavedGroups(savedGroupsData) {

            if (!Array.isArray(savedGroupsData) || savedGroupsData.length === 0) {

                return;

            }
            // 1. Xóa trạng thái nhóm hiện tại và các nhóm cũ

            allGroups = [];

            groups = {};

            allPoints.forEach(p => p.groupId = null);
            let loadCount = 0;
            // 2. Tải từng nhóm

            savedGroupsData.forEach(savedGroup => {
                const centerPointId = savedGroup.center_point.id;

                const centerPointData = getPointDataById(centerPointId);
                if (!centerPointData) {

                    console.warn(`Bỏ qua nhóm ${savedGroup.group_id}: Không tìm thấy điểm tâm ID ${centerPointId}.`);

                    return;

                }
                const newGroup = {

                    id: savedGroup.group_id,

                    centerPoint: centerPointData,

                    color: savedGroup.color,

                    groupNumber: savedGroup.group_number,

                    routingControls: [],

                    // PHỤC HỒI POLYLINE CACHE (Giữ nguyên)

                    polylineCache: savedGroup.polyline_cache || {},

                    // ✨ SỬA LỖI: PHỤC HỒI BÁN KÍNH CỐ ĐỊNH VÀ ĐẢM BẢO LÀ SỐ HỢP LỆ ✨

                    fixedRadiusMeters: Number(savedGroup.fixedRadiusMeters) || 30000,

                    fixedRadiusKm: Number(savedGroup.fixedRadiusKm) || 30,

                    points: [] // Khởi tạo mảng điểm

                };
                // **********************************************

                // 3. Cập nhật các điểm thành viên VÀ ĐIỂM TÂM

                const memberIds = savedGroup.member_ids;

                const pointsInGroup = [];
                // Đảm bảo điểm tâm là thành viên của nhóm

                centerPointData.groupId = savedGroup.group_id;

                pointsInGroup.push(centerPointData);
                memberIds.forEach(memberId => {

                    if (memberId === centerPointId) return; // Bỏ qua nếu là điểm tâm (đã thêm)
                    const memberPoint = getPointDataById(memberId);

                    if (memberPoint) {

                        memberPoint.groupId = savedGroup.group_id;

                        pointsInGroup.push(memberPoint);

                    }

                });
                // Gán MẢNG ĐIỂM đã hoàn chỉnh (bao gồm điểm tâm) vào nhóm

                newGroup.points = pointsInGroup; // <--- DÒNG SỬA CHỮA
                allGroups.push(newGroup);
                // 4. Đồng bộ biến 'groups' (cho UI Popup)

                groups[`NHÓM ${savedGroup.group_number}`] = {

                    id: savedGroup.group_id,

                    color: savedGroup.color,

                    pointIds: memberIds

                };
                loadCount++;

            });
            // 6. Vẽ lại bản đồ

            drawAllGroups();

            updateRankTable();

            updateFilterOptions();
            if (loadCount > 0) {

                showToast(`Đã tải lại ${loadCount} nhóm từ bộ nhớ thành công!`, "info");

            }

        }
        /**
        
         * (MỚI) Xóa một nhóm đã chọn.
        
         * @param {string} groupId - ID của nhóm cần xóa (ví dụ: 'G_1').
        
         */

        function popup_deleteGroup(groupId) {

            // Thêm hộp thoại xác nhận để tránh xóa nhầm

            if (!confirm(`Bạn có chắc chắn muốn hủy Nhóm ID: ${groupId} không? Hành động này không thể hoàn tác.`)) {

                return;

            }
            if (currentPopup) {

                map.closePopup(currentPopup);

                currentPopup = null;

            }
            const groupIndex = allGroups.findIndex(g => String(g.id) === String(groupId));

            if (groupIndex === -1) {

                showToast(`Lỗi: Không tìm thấy nhóm ID ${groupId}.`, "error");

                return;

            }
            const groupToDelete = allGroups[groupIndex];

            const groupNumber = groupToDelete.groupNumber;
            // 1. Reset GroupID cho TẤT CẢ các điểm trong nhóm

            // Bao gồm các điểm trong mảng points và điểm centerPoint (cần tìm lại điểm centerPoint từ allPoints)
            // Tìm lại tất cả các điểm trên bản đồ mà có groupId này

            const pointsToReset = allPoints.filter(p => String(p.groupId) === String(groupId));
            pointsToReset.forEach(p => {

                p.groupId = null; // Đưa về trạng thái chưa được nhóm

            });
            // 2. Xóa khỏi danh sách nhóm (allGroups)

            allGroups.splice(groupIndex, 1);
            // 3. Xóa khỏi đối tượng groups (dùng cho UI/Popup)

            const groupKey = Object.keys(groups).find(key => groups[key].id === groupId);

            if (groupKey) {

                delete groups[groupKey];

            }
            // 4. CẬP NHẬT TRẠNG THÁI: Vẽ lại bản đồ và UI

            drawAllGroups();

            updateRankTable();

            updateFilterOptions();
            // 5. LƯU VÀO LOCAL STORAGE

            exportGroupsData();
            showToast(`Đã hủy thành công Nhóm ${groupNumber} và đưa ${pointsToReset.length} điểm về trạng thái chưa nhóm.`, "success");

        }

        /**
        
         * (FINAL SỬA LỖI & LOGGING) Hàm khởi tạo dữ liệu điểm và thêm Marker vào bản đồ.
        
         * Đã thêm logic CHẶN HOVER nếu kết quả tối ưu đang hiển thị.
        
         */

        function addPointToMap(latlng, termId, chinhanh, nhnn, vung, tonQuyStr, vuotHanMucStr, hanMucStr, hubYesStr, tenHubStr, plDgdStr) {

            // (*** Khai báo và khởi tạo biến giữ nguyên ***)

            const isNHNN = (nhnn === true || String(nhnn).toLowerCase() === 'true' || String(nhnn) === '1');

            const cleanChinhanh = chinhanh ? String(chinhanh).trim() : 'Không có';

            const cleanVung = vung ? String(vung).trim() : 'Không xác định';

            const cleanTonQuy = parseFloat(String(tonQuyStr).replace(/[\s,]/g, '')) || 0;

            const cleanHanMuc = parseFloat(String(hanMucStr).replace(/[\s,]/g, '')) || 0;

            const isVuotHanMuc = String(vuotHanMucStr).trim() !== '-' && String(vuotHanMucStr).trim() !== '';

            const isHubPoint = String(hubYesStr).trim().toUpperCase() === 'YES';

            const isBatteryPoint = String(plDgdStr).trim().toUpperCase() === 'TSCN';

            const cleanTenHub = tenHubStr ? String(tenHubStr).trim() : null;
            const newMarker = L.marker(latlng, {

                icon: isNHNN ? createNHNNIcon() : createPGDIcon()

            });
            const pointId = (termId ? String(termId).trim() : null) || L.stamp(newMarker);

            allMarkers[pointId] = newMarker;
            // (*** KHỐI LỆNH TẠO PERMANENT TOOLTIP CHO TERM ID ***)

            newMarker.bindTooltip(pointId, {

                permanent: true,

                direction: 'top',

                className: 'termid-label-tooltip', // CLASS ĐẶC TRƯNG

                offset: L.point(0, -15)

            });
            // (*** KẾT THÚC BỔ SUNG ***)
            if (isNHNN) { newMarker.addTo(nhnnMarkersLayer); }
            const newPointData = {

                id: pointId,

                latlng: latlng,

                marker: newMarker,

                groupId: isNHNN ? 'REFERENCE' : null,

                chinhanh: cleanChinhanh,

                vung: cleanVung,

                isVisible: true,

                nhnn: isNHNN,

                tonQuy: cleanTonQuy,

                hanMuc: cleanHanMuc,

                vuotHanMuc: isVuotHanMuc,

                isHub: isHubPoint,

                tenHub: cleanTenHub,

                isBatteryPoint: isBatteryPoint,

                // SỬA LỖI: Lưu đối tượng Tooltip hợp lệ

                termIDTooltip: newMarker.getTooltip()

            };
            if (isNHNN) {

                newMarker.on('click', (e) => { L.DomEvent.stopPropagation(e); handleMarkerClick(newPointData); });

            } else {

                newMarker.on('mouseover', (e) => {

                    // ✨ BỔ SUNG ĐIỀU KIỆN CHẶN HOVER KHI CÓ KẾT QUẢ TỐI ƯU ✨

                    if (isOptimizationResultVisible) {

                        // Nếu vòng tròn tối ưu đang hiển thị, CHẶN logic hover của các điểm khác

                        return;

                    }
                    highlightRankItem(newPointData.id);
                    // Điều kiện Preview: Chưa được nhóm VÀ không ở chế độ Pin

                    if (newPointData.groupId === null && !isBatteryView) {

                        const ungroupedPoints = allPoints.filter(p => p.groupId === null && p.isVisible && !p.nhnn);

                        let coveredPoints = [];
                        // ✨ KHỐI THỐNG KÊ CHI TIẾT VÀ KHÔNG TRÙNG LẶP (Đã gỡ lỗi tenHub) ✨

                        let stats = { TSCN: 0, PGD: 0, Other: 0 };

                        let countedIds = new Set();
                        const TSCN_KEYWORDS = ["TSCN", "TS CN", "TRU SO CN", "TRU SO CHI NHANH"];

                        const PGD_KEYWORDS = ["PGD", "PHONG GD", "PHONG GIAO DICH", "P GIAO DICH"];
                        console.log(`[PREVIEW LOG START] Bắt đầu phân loại cho Tâm: ${newPointData.id}`);
                        for (const pointToTest of ungroupedPoints) {

                            if (newPointData.latlng.distanceTo(pointToTest.latlng) <= RADIUS_METERS) {

                                coveredPoints.push(pointToTest);
                                let isClassified = false;

                                const checkTextUpper = (pointToTest.id || '').toUpperCase();
                                // --- 1. Phân loại TSCN (Nhóm 1) ---

                                if (pointToTest.isBatteryPoint || TSCN_KEYWORDS.some(keyword => checkTextUpper.includes(keyword))) {

                                    if (!countedIds.has(pointToTest.id)) {

                                        stats.TSCN++;

                                        isClassified = true;

                                        countedIds.add(pointToTest.id);

                                        const source = pointToTest.isBatteryPoint ? 'isBatteryPoint' : 'Keyword_ID';

                                        console.log(`[PREVIEW LOG] Điểm ${pointToTest.id} [${pointToTest.tenHub}] -> Nhóm 1 (TSCN - ${source}).`);

                                    }

                                }
                                // --- 2. Phân loại PGD (Nhóm 2) ---

                                if (!isClassified) {

                                    if (PGD_KEYWORDS.some(keyword => checkTextUpper.includes(keyword))) {

                                        if (!countedIds.has(pointToTest.id)) {

                                            stats.PGD++;

                                            isClassified = true;

                                            countedIds.add(pointToTest.id);

                                            console.log(`[PREVIEW LOG] Điểm ${pointToTest.id} [${pointToTest.tenHub}] -> Nhóm 2 (PGD - Keyword_ID).`);

                                        }

                                    }

                                }
                                // --- 3. Nhóm Khác (Nhóm 3) ---

                                if (!isClassified) {

                                    stats.Other++;

                                    console.log(`[PREVIEW LOG] Điểm ${pointToTest.id} [${pointToTest.tenHub}] -> Nhóm 3 (Khác/ATM).`);

                                }

                            }

                        }
                        // Xây dựng nội dung HTML chi tiết

                        const tooltipHtml = `

                    <div style="font-size: 13px; padding: 5px; min-width: 150px; line-height: 1.5;">

                        <strong style="display: block;">Tâm: ${newPointData.id} ${newPointData.tenHub ? `(${newPointData.tenHub})` : ''}</strong>

                        <hr style="margin: 4px 0;">

                        <div>Tổng phủ: <b>${coveredPoints.length}</b> điểm</div>

                        <div>Nhóm 1 (TSCN): <b style="color:#16a34a;">${stats.TSCN}</b></div>

                        <div>Nhóm 2 (PGD): <b style="color:#2563eb;">${stats.PGD}</b></div>

                        <div>Nhóm 3 (Khác): <b style="color:#d97706;">${stats.Other}</b></div>

                    </div>

                `;
                        const previewItem = {

                            type: 'NEW',

                            centerPoint: newPointData,

                            coveredPoints: coveredPoints,

                            color: PREVIEW_COLOR,

                            tooltipContent: tooltipHtml

                        };

                        showPreview(previewItem, null);

                    } else {

                        // Xóa Preview nếu đã nhóm hoặc đang ở chế độ Pin

                        clearRankItemHighlight();

                        clearPreview();

                    }

                });
                // Giữ lại sự kiện mouseout để xóa preview khi rời khỏi điểm

                newMarker.on('mouseout', () => {

                    if (isOptimizationResultVisible) return; // Không xóa nếu đang có kết quả tối ưu

                    clearRankItemHighlight();

                    clearPreview();

                });
                newMarker.on('click', (e) => {

                    L.DomEvent.stopPropagation(e);

                    handleMarkerClick(newPointData);

                });

            }

            newMarker.on('popupclose', () => {

                currentPopup = null;

            });
            allPoints.push(newPointData);

            return newPointData;

        }

        /**
    
         * (*** MỚI v45 ***) Hàm Bật/Tắt hiển thị lớp NHNN
    
         */

        function toggleNhnn() {

            // 1. Đảo ngược trạng thái

            showNhnnMarkers = !showNhnnMarkers;

            const button = document.getElementById('nhnn-toggle-btn');
            if (currentPopup) map.closePopup(currentPopup);
            // 2. Cập nhật nút

            if (showNhnnMarkers) {

                button.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i> <span class="button-text">Ẩn NHNN</span>';

                button.classList.add('nhnn-on');

                button.classList.remove('nhnn-off');

                showToast("Đã BẬT: Hiển thị NHNN", 'info');

            } else {

                button.innerHTML = '<i class="fa-solid fa-eye-slash w-4 h-4"></i> <span class="button-text">Hiện NHNN</span>';

                button.classList.add('nhnn-off');

                button.classList.remove('nhnn-on');

                showToast("Đã TẮT: Ẩn NHNN", 'warning');

            }
            // 3. (QUAN TRỌNG) Gọi lại hàm applyFilter

            applyFilter();

        }

        function loadPreloadedData() {

            const powerAutomateUrl = 'https://default460cecfbf0c64dd7a5ec66ef4d75ae.63.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/c7a3ba54b6604025882ae481816180bb/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=R88_MePGo47lYzv0ndIiVxbRUcMncU26zdMq9HGw9hs';
            showToast("Đang tải dữ liệu từ Power Automate...", 'info');
            fetch(powerAutomateUrl, {

                method: 'POST',

                headers: { 'Content-Type': 'application/json' },

                body: JSON.stringify({})

            })

                .then(response => {

                    if (!response.ok) {

                        throw new Error(`Lỗi HTTP! Trạng thái: ${response.status}`);

                    }

                    return response.json();

                })

                .then(data => {

                    let bounds = L.latLngBounds();
                    if (!Array.isArray(data)) {

                        throw new Error("Dữ liệu nhận được không phải là một mảng (array)!");

                    }
                    data.forEach(item => {

                        const lat = parseFloat(String(item.LATITUDE).trim());

                        const lng = parseFloat(String(item.LONGITUDE).replace('S', '').trim());
                        if (!isNaN(lat) && !isNaN(lng)) {

                            const latlng = L.latLng(lat, lng);
                            addPointToMap(

                                latlng,

                                item.TERMID,

                                item.CHINHANH,

                                item.NHNN,

                                item.VUNG,

                                item.Ton_quy_cuoi_ngay,

                                item.VUOT_HAN_MUC,

                                item.HMTQ_ngay,

                                item.HUBYES,

                                item.TENHUB,

                                item.PL_DGD // <--- THAM SỐ THỨ 11 MỚI

                            );

                            bounds.extend(latlng);

                        } else {

                            console.warn("Bỏ qua điểm có tọa độ không hợp lệ:", item.TERMID);

                        }

                    });
                    buildCascadingFiltersUI();
                    showToast(`Đã tải ${data.length} điểm dữ liệu.`, 'success');
                    updateRankTable();

                    renderProposalList();

                    updateMarkersVisibility();

                    loadGroupsFromLocalStorage();

                    if (bounds.isValid()) {

                        map.fitBounds(bounds.pad(0.1));

                    }

                    // Dòng Sửa Đổi: Buộc Tooltip Term ID phải ẩn nếu trạng thái mặc định là FALSE

                    if (!showTermIDLabels) {

                        toggleTermIDLabels();

                        toggleTermIDLabels(); // Gọi 2 lần để đảm bảo lần gọi đầu tiên ẩn chúng đi

                    } else {

                        // Nếu mặc định là true, chỉ gọi 1 lần để đảm bảo chúng hiện

                        toggleTermIDLabels();

                    }

                })

                .catch(error => {

                    console.error('Lỗi khi tải dữ liệu từ Power Automate:', error);

                    showToast(`Lỗi tải dữ liệu: ${error.message}`, 'error');

                    updateRankTable();

                    updateMarkersVisibility();

                });

        }

        /**
        
         * (MỚI) Đọc dữ liệu từ Local Storage và gọi phục hồi.
        
         */

        function loadGroupsFromLocalStorage() {

            try {

                const savedJson = localStorage.getItem(LOCAL_STORAGE_KEY);

                if (savedJson) {

                    const savedData = JSON.parse(savedJson);

                    loadSavedGroups(savedData);

                }

            } catch (e) {

                console.error("Lỗi khi đọc Local Storage:", e);

                showToast("Lỗi khi tải lại trạng thái nhóm từ bộ nhớ.", "error");

            }

        }

        // --- (MỚI v35) CỤM LOGIC LỌC GIA ĐÌNH ---
        /**
    
         * (SỬA v40) Thêm HTML cho bộ lọc Nhóm
    
         */

        function buildCascadingFiltersUI() {

            const container = document.getElementById('cascading-filter-container');

            if (!container) return;
            container.innerHTML = `

<hr class="my-3 border-t border-gray-300">

    <div class="filter-control">

        <label for="filter-vung">Lọc theo Vùng:</label>

        <select id="filter-vung" multiple size="4">

        </select>

    </div>

    <div class="filter-control">

        <label for="filter-chinhanh">Lọc theo Chi Nhánh:</label>

        <select id="filter-chinhanh" multiple size="5">

        </select>

    </div>

    <div class="filter-control">

        <label for="filter-termid">Lọc theo Mã CN (TERMID):</label>

        <select id="filter-termid" multiple size="5">

        </select>

    </div>

    <div class="filter-control">

        <label for="filter-vuothm">Lọc theo Hạn Mức:</label>

        <select id="filter-vuothm" multiple size="3">

        </select>

    </div>

    <div class="filter-control">

        <label for="filter-nhom">Lọc theo Nhóm:</label>

        <select id="filter-nhom" multiple size="5">

        </select>

    </div>

    <button id="reset-cascading-filter-btn">

        <i class="fa-solid fa-filter-circle-xmark"></i> Xóa Lọc

    </button>

        `;
            // Gắn sự kiện

            document.getElementById('filter-vung').addEventListener('change', () => {

                updateFilterOptions();

                applyFilter();

            });
            document.getElementById('filter-chinhanh').addEventListener('change', () => {

                updateFilterOptions(); // Cập nhật TERMID, Hạn Mức, Nhóm

                applyFilter();

            });
            document.getElementById('filter-termid').addEventListener('change', () => {

                updateFilterOptions(); // Cập nhật Hạn Mức, Nhóm

                applyFilter();

            });
            document.getElementById('filter-vuothm').addEventListener('change', () => {

                updateFilterOptions(); // Cập nhật Nhóm

                applyFilter();

            });
            // (MỚI v40) Gắn sự kiện cho bộ lọc Nhóm

            document.getElementById('filter-nhom').addEventListener('change', applyFilter);


            document.getElementById('reset-cascading-filter-btn').addEventListener('click', () => {
                // ✨ LOGIC ĐÃ SỬA: Lặp qua TẤT CẢ các select và hủy chọn tất cả options ✨

                const filterIds = ['filter-vung', 'filter-chinhanh', 'filter-termid', 'filter-vuothm', 'filter-nhom'];
                filterIds.forEach(id => {

                    const selectElement = document.getElementById(id);

                    if (selectElement) {

                        // Đặt tất cả options về trạng thái không được chọn

                        Array.from(selectElement.options).forEach(option => {

                            option.selected = false;

                        });


                    }

                });
                // Sau khi reset các lựa chọn, gọi updateFilterOptions để xây dựng lại các dropdown 

                // và applyFilter để hiển thị tất cả điểm.

                updateFilterOptions();

                applyFilter();

                showToast("Đã xóa lọc", "info");

            });
            // Tải dữ liệu lần đầu

            updateFilterOptions();

            setupMultiSelectToggle();

        }
        /**
    
     * (SỬA LỚN MULTI-SELECT) Cập nhật cả 5 dropdown, loại bỏ tùy chọn 'ALL', và thêm tùy chọn nhóm chi tiết.
    
     */

        function updateFilterOptions() {

            const vungSelect = document.getElementById('filter-vung');

            const chinhanhSelect = document.getElementById('filter-chinhanh');

            const termidSelect = document.getElementById('filter-termid');

            const vuothmSelect = document.getElementById('filter-vuothm');

            const nhomSelect = document.getElementById('filter-nhom');
            if (!vungSelect || !chinhanhSelect || !termidSelect || !vuothmSelect || !nhomSelect) return;
            // Hàm mới để lấy các giá trị đã chọn (trả về mảng)

            const getSelectedValues = (selectElement) => {

                if (!selectElement) return [];

                return Array.from(selectElement.options)

                    .filter(option => option.selected)

                    .map(option => option.value);

            };
            // Lấy các giá trị đã chọn hiện tại (đã là mảng)

            const selectedVung = getSelectedValues(vungSelect);

            const selectedChiNhanh = getSelectedValues(chinhanhSelect);

            const selectedTermid = getSelectedValues(termidSelect);

            const selectedVuotHM = getSelectedValues(vuothmSelect);

            const selectedNhom = getSelectedValues(nhomSelect);
            // Dùng một tập hợp điểm đang hiển thị (theo logic cũ) để xây dựng option cho dropdown tiếp theo

            let pointsToFilter = allPoints.filter(p => !p.nhnn);
            // 1. Cập nhật Vùng

            vungSelect.innerHTML = '';

            const vungSet = new Set(pointsToFilter.map(p => p.vung));

            vungSet.forEach(vung => {

                vungSelect.innerHTML += `<option value="${vung}">${vung}</option>`;

            });

            // Áp dụng lọc Vùng cho bước tiếp theo

            if (selectedVung.length > 0) {

                pointsToFilter = pointsToFilter.filter(p => selectedVung.includes(p.vung));

            }


            // 2. Cập nhật Chi Nhánh

            chinhanhSelect.innerHTML = '';

            const chinhanhSet = new Set(pointsToFilter.map(p => p.chinhanh));

            chinhanhSet.forEach(cn => {

                chinhanhSelect.innerHTML += `<option value="${cn}">${cn}</option>`;

            });

            // Áp dụng lọc Chi Nhánh cho bước tiếp theo

            if (selectedChiNhanh.length > 0) {

                pointsToFilter = pointsToFilter.filter(p => selectedChiNhanh.includes(p.chinhanh));

            }


            // 3. Cập nhật TERMID

            termidSelect.innerHTML = '';

            const termidSet = new Set(pointsToFilter.map(p => String(p.id)));

            const sortedTermids = [...termidSet].sort((a, b) => String(a).localeCompare(String(b)));

            sortedTermids.forEach(id => {

                termidSelect.innerHTML += `<option value="${id}">${id}</option>`;

            });

            // Áp dụng lọc TermID cho bước tiếp theo

            if (selectedTermid.length > 0) {

                pointsToFilter = pointsToFilter.filter(p => selectedTermid.includes(String(p.id)));

            }


            // 4. Cập nhật Hạn Mức

            vuothmSelect.innerHTML = '';

            const vuotHMSet = new Set(pointsToFilter.map(p => p.vuotHanMuc));

            vuothmSelect.innerHTML += '<option value="ALL_HM" selected>-- Tất cả Hạn Mức --</option>'; // Tùy chọn mặc định

            if (vuotHMSet.has(true)) {

                vuothmSelect.innerHTML += '<option value="YES">Vượt Hạn Mức</option>';

            }

            if (vuotHMSet.has(false)) {

                vuothmSelect.innerHTML += '<option value="NO">Không Vượt</option>';

            }

            // Áp dụng lọc Hạn Mức cho bước tiếp theo

            if (selectedVuotHM.length > 0 && !selectedVuotHM.includes('ALL_HM')) {

                pointsToFilter = pointsToFilter.filter(p => selectedVuotHM.some(filterValue => {

                    if (filterValue === 'YES') return p.vuotHanMuc === true;

                    if (filterValue === 'NO') return p.vuotHanMuc === false;

                    return false;

                }));

            }


            // 5. Cập nhật Nhóm (SỬA LỚN)

            nhomSelect.innerHTML = '';

            const nhomSet = new Set(pointsToFilter.map(p => p.groupId));
            // Tùy chọn mặc định: TẤT CẢ (Sửa tên từ ALL_POINTS thành ALL)

            nhomSelect.innerHTML += '<option value="ALL" selected>-- Tất cả --</option>';
            // Tùy chọn mới: TẤT CẢ NHÓM ĐÃ XÁC ĐỊNH (ALL_GROUPED)

            if (allGroups.length > 0) {

                nhomSelect.innerHTML += '<option value="ALL_GROUPED">-- TẤT CẢ NHÓM --</option>';

            }
            // Thêm lựa chọn [CHƯA CÓ NHÓM]

            if (nhomSet.has(null)) {

                nhomSelect.innerHTML += '<option value="NULL">[CHƯA CÓ NHÓM]</option>';

            }
            // Thêm các nhóm đã tạo (Nhóm 1, Nhóm 2,...)

            allGroups.forEach(group => {

                if (nhomSet.has(group.id)) {

                    nhomSelect.innerHTML += `<option value="${group.id}">Nhóm ${group.groupNumber}</option>`;

                }

            });
            // --- Khôi phục các lựa chọn đã chọn (Quan trọng) ---

            [...vungSelect.options].forEach(opt => opt.selected = selectedVung.includes(opt.value));

            [...chinhanhSelect.options].forEach(opt => opt.selected = selectedChiNhanh.includes(opt.value));

            [...termidSelect.options].forEach(opt => opt.selected = selectedTermid.includes(opt.value));

            [...vuothmSelect.options].forEach(opt => opt.selected = selectedVuotHM.includes(opt.value));

            [...nhomSelect.options].forEach(opt => opt.selected = selectedNhom.includes(opt.value));

        }

        /**
        
         * (SỬA LỚN MULTI-SELECT) Áp dụng các bộ lọc theo chế độ Multi-Select.
        
         */

        function applyFilter() {

            const selVung = document.getElementById('filter-vung');

            const selChiNhanh = document.getElementById('filter-chinhanh');

            const selTermid = document.getElementById('filter-termid');

            const selVuotHM = document.getElementById('filter-vuothm');

            const selNhom = document.getElementById('filter-nhom');
            // Hàm mới để lấy các giá trị đã chọn (trả về mảng)

            const getSelectedValues = (selectElement) => {

                if (!selectElement) return ['ALL']; // Mặc định là ALL nếu không tồn tại

                const selected = Array.from(selectElement.options)

                    .filter(option => option.selected)

                    .map(option => option.value);

                return selected.length > 0 ? selected : ['ALL']; // Nếu không chọn gì, coi như chọn ALL

            };
            // Lấy các giá trị đã chọn

            const selectedVung = getSelectedValues(selVung);

            const selectedChiNhanh = getSelectedValues(selChiNhanh);

            const selectedTermid = getSelectedValues(selTermid);

            const selectedVuotHM = getSelectedValues(selVuotHM);

            const selectedNhom = getSelectedValues(selNhom);
            allPoints.forEach(p => {
                // 1. Lọc Vùng/Chi Nhánh/TermID (Match: thuộc tính điểm NẰM TRONG mảng đã chọn)

                const vungMatch = selectedVung.includes('ALL') || selectedVung.includes(p.vung);

                const chiNhanhMatch = selectedChiNhanh.includes('ALL') || selectedChiNhanh.includes(p.chinhanh);

                const termidMatch = selectedTermid.includes('ALL') || selectedTermid.includes(String(p.id));
                // 2. Lọc Hạn Mức

                let vuotHMMatch = selectedVuotHM.includes('ALL');

                if (!vuotHMMatch && !p.nhnn) {

                    vuotHMMatch = selectedVuotHM.some(filterValue => {

                        if (filterValue === 'YES') return p.vuotHanMuc === true;

                        if (filterValue === 'NO') return p.vuotHanMuc === false;

                        return false;

                    });

                }
                // 3. Lọc Nhóm (SỬA LỚN LOGIC)

                let nhomMatch = selectedNhom.includes('ALL'); // Mặc định khớp nếu chọn 'ALL'
                if (!nhomMatch) {

                    if (selectedNhom.includes("ALL_GROUPED")) {

                        // Tùy chọn ALL_GROUPED: chỉ hiển thị điểm có Group ID (không phải NHNN)

                        nhomMatch = (p.groupId !== null && p.groupId !== 'REFERENCE');

                    } else if (selectedNhom.includes("NULL")) {

                        // Chỉ hiển thị điểm chưa có nhóm

                        nhomMatch = (p.groupId === null);

                    } else {

                        // Hiển thị các nhóm cụ thể được chọn

                        if (p.nhnn) {

                            nhomMatch = false; // Ẩn NHNN nếu chọn nhóm cụ thể

                        } else {

                            nhomMatch = selectedNhom.includes(String(p.groupId));

                        }

                    }

                }
                // 4. Lọc Nút Ẩn/Hiện NHNN

                let nhnnToggleMatch = true;

                if (p.nhnn && !showNhnnMarkers) {

                    nhnnToggleMatch = false;

                }
                // Final check: Tất cả điều kiện phải đúng

                p.isVisible = vungMatch && chiNhanhMatch && termidMatch && vuotHMMatch && nhomMatch && nhnnToggleMatch;

            });
            if (currentPopup) {

                map.closePopup(currentPopup);

                currentPopup = null;

            }
            updateMarkersVisibility();

            drawAllGroups();

            updateRankTable();
            // Đồng bộ nhãn Term ID

            if (typeof toggleTermIDLabels === 'function' && showTermIDLabels) {

                toggleTermIDLabels(); // Gọi lại để áp dụng p.isVisible mới

            }

        }

        /**
       
        * Xử lý sự kiện MOUSE DOWN để BẬT/TẮT trạng thái chọn (Toggle Select)
       
        * mà không cần giữ phím Ctrl/Cmd.
       
        */

        function toggleSelection(event) {

            const option = event.target;
            // Đảm bảo chỉ xử lý khi click vào thẻ <option>

            if (option.tagName !== 'OPTION') return;
            // Ngăn chặn hành vi mặc định của trình duyệt 

            // (như tự động bỏ chọn các mục khác khi click)

            event.preventDefault();
            // Đảo ngược trạng thái chọn của mục được click

            option.selected = !option.selected;
            // QUAN TRỌNG: Kích hoạt sự kiện 'change' để bộ lọc được áp dụng

            // Gọi applyFilter() để cập nhật bản đồ ngay lập tức

            const selectElement = option.parentElement;

            if (selectElement.id === 'filter-vung') {

                updateFilterOptions();

            }

            applyFilter();

        }

        // Khối lệnh để gán sự kiện cho tất cả các bộ lọc Multi-Select

        function setupMultiSelectToggle() {

            const filterIds = ['filter-vung', 'filter-chinhanh', 'filter-termid', 'filter-vuothm', 'filter-nhom'];
            filterIds.forEach(id => {

                const selectElement = document.getElementById(id);

                if (selectElement && selectElement.hasAttribute('multiple')) {

                    // Gán sự kiện 'mousedown' thay vì 'click' để chặn hành vi mặc định tốt hơn

                    selectElement.addEventListener('mousedown', toggleSelection);

                }

            });

        }

        /**
        
         * (SỬA LỚN) Cập nhật hiển thị marker dựa trên bộ lọc VÀ chế độ Pin.
        
         * Đảm bảo ẩn các điểm PGD (không phải TSCN) khi ở chế độ Pin.
        
         */

        function updateMarkersVisibility() {
            // --- 1. XỬ LÝ CÁC ĐIỂM PGD/ATM (CÓ GOM CỤM) ---
            // 1a. Lấy danh sách marker PGD/ATM (KHÔNG phải NHNN) cần hiển thị

            const visiblePgdMarkers = allPoints

                .filter(p => !p.nhnn)

                .filter(p => {

                    // (*** LOGIC LỌC MỚI CHO CHẾ ĐỘ PIN ***)

                    // ẨN TẤT CẢ CÁC ĐIỂM KHÔNG PHẢI TSCN KHI Ở CHẾ ĐỘ PIN

                    if (isBatteryView && !p.isBatteryPoint) {

                        return false;

                    }

                    // (*** KẾT THÚC LOGIC LỌC MỚI ***)
                    // Giữ nguyên điều kiện lọc cũ (Filter UI)

                    return p.isVisible;

                })

                .map(p => p.marker);
            // 1b. Xóa các PGD/ATM marker cũ khỏi lớp đang hoạt động

            pointMarkersLayer.clearLayers();
            // 1c. Thêm marker PGD/ATM vào lại, tùy theo loại layer

            if (isClusteringEnabled) {

                pointMarkersLayer.addLayers(visiblePgdMarkers);

            } else {

                visiblePgdMarkers.forEach(marker => {

                    pointMarkersLayer.addLayer(marker);

                });

            }
            // --- 2. XỬ LÝ CÁC ĐIỂM NHNN (KHÔNG GOM CỤM) ---
            // Lặp qua tất cả các điểm NHNN và ẩn/hiện chúng trên lớp cố định

            allPoints.filter(p => p.nhnn).forEach(nhnnPoint => {

                if (nhnnPoint.isVisible) {

                    if (!nhnnMarkersLayer.hasLayer(nhnnPoint.marker)) {

                        nhnnMarkersLayer.addLayer(nhnnPoint.marker);

                    }

                } else {

                    if (nhnnMarkersLayer.hasLayer(nhnnPoint.marker)) {

                        if (nhnnPoint.marker.getTooltip()) {

                            nhnnPoint.marker.unbindTooltip();

                        }

                        nhnnMarkersLayer.removeLayer(nhnnPoint.marker);

                    }

                }

            });

        }
        // --- HẾT CỤM LOGIC LỌC v35 ---


        /**
        
         * (SỬA ĐỔI v48: Ẩn/Hiện nút 🏆 thay vì ẩn/hiện panel)
        
         * (*** SỬA v51: Chỉ hiển thị điểm isHub=true trong xếp hạng NEW ***)
        
         */

        function updateRankTable() {

            const rankTableContainer = document.getElementById('rank-table-container');

            const rankToggleButton = document.getElementById('rank-toggle-btn'); // ID mới
            if (!rankToggleButton) return;
            // (MỚI v39) Không hiển thị bảng xếp hạng khi ở chế độ Pin

            if (isBatteryView) {

                rankTableContainer.style.display = 'none';

                rankToggleButton.style.display = 'none';

                currentRankings = [];

                return;

            }
            // (*** SỬA LỚN NHẤT ***)

            // 1. Lọc ra các điểm HUB CHƯA NHÓM VÀ HIỂN THỊ (Ứng viên TÂM NHÓM MỚI)

            const ungroupedHubPoints = allPoints.filter(p => p.groupId === null && p.isVisible && p.isHub);
            // 2. Lọc ra TẤT CẢ các điểm chưa nhóm VÀ HIỂN THỊ (Ứng viên THÀNH VIÊN)

            const allUngroupedAndVisible = allPoints.filter(p => p.groupId === null && p.isVisible);
            // (SỬA v48) Logic mới: Ẩn/Hiện NÚT BẤM

            if (ungroupedHubPoints.length === 0 && allGroups.length === 0) {

                rankToggleButton.style.display = 'none'; // Ẩn nút

                rankTableContainer.style.display = 'none'; // Tắt panel (phòng hờ)

                currentRankings = [];

                return;

            }
            // (SỬA v48) Hiển thị nút bấm (dạng flex)

            rankToggleButton.style.display = 'flex';
            currentRankings = [];
            // ---- BƯỚC 2: Xếp hạng "TẠO NHÓM MỚI" (CHỈ DÙNG ĐIỂM HUB) ----

            for (const centerCandidate of ungroupedHubPoints) { // <--- SỬ DỤNG HUB POINTS

                let coveredPoints = [];

                let totalDistanceScore = 0;
                // Lặp qua TẤT CẢ các điểm chưa nhóm & hiển thị

                for (const pointToTest of allUngroupedAndVisible) {

                    const distance = centerCandidate.latlng.distanceTo(pointToTest.latlng);

                    if (distance <= RADIUS_METERS) {

                        coveredPoints.push(pointToTest);

                        totalDistanceScore += (distance * distance);

                    }

                }
                if (coveredPoints.length > 0) {

                    currentRankings.push({

                        type: 'NEW',

                        centerId: centerCandidate.id,

                        centerPoint: centerCandidate,

                        coveredPoints: coveredPoints,

                        score: coveredPoints.length,

                        distanceScore: totalDistanceScore,

                        color: PREVIEW_COLOR

                    });

                }

            }
            // ---- BƯỚC 3: Xếp hạng "DI CHUYỂN NHÓM" (Giữ nguyên) ----

            const centerPointIds = new Set(allGroups.map(g => g.centerPoint.id));

            const movablePoints = allPoints.filter(p => p.groupId !== null && p.groupId !== 'REFERENCE' && !centerPointIds.has(p.id) && p.isVisible);
            for (const pointToMove of movablePoints) {

                for (const targetGroup of allGroups) {
                    if (!targetGroup.centerPoint.isVisible) continue;
                    if (pointToMove.groupId !== targetGroup.id) {

                        const distance = pointToMove.latlng.distanceTo(targetGroup.centerPoint.latlng);

                        if (distance <= RADIUS_METERS) {

                            currentRankings.push({

                                type: 'MOVE',

                                pointToMove: pointToMove,

                                targetGroup: targetGroup,

                                score: 0,

                                distanceScore: distance,

                                color: targetGroup.color

                            });

                        }

                    }

                }

            }
            currentRankings.sort((a, b) => {

                if (a.score !== b.score) {

                    return b.score - a.score;

                }

                return a.distanceScore - b.distanceScore;

            });
            renderRankTable();

        }
        /**
        
         * (SỬA ĐỔI v51 & v52) Vẽ Bảng Xếp Hạng - Thêm logic click focus vào điểm tương ứng
        
         */

        function renderRankTable() {

            const rankTableBody = document.getElementById('rank-table-body');

            rankTableBody.innerHTML = '';
            const newActions = currentRankings.filter(r => r.type === 'NEW');

            const moveActions = currentRankings.filter(r => r.type === 'MOVE');
            // 1. Render NEW (Tạo Mới)

            newActions.forEach((item, index) => {

                const row = document.createElement('div');

                row.className = 'rank-item rank-item-new';

                row.dataset.pointId = item.centerId;
                const hubNameHtml = item.centerPoint.tenHub ?

                    `<div><b>HUB:</b> ${item.centerPoint.tenHub}</div>` :

                    '';
                // Gắn sự kiện Click của Row để Focus/Zoom trên bản đồ

                row.addEventListener('click', (e) => {

                    // Chỉ focus nếu không click vào nút button

                    if (e.target.tagName !== 'BUTTON' && e.target.closest('button') === null) {

                        focusOnPoint(item.centerId);

                    }

                });
                row.innerHTML = `

            <b>(Tạo mới) Hạng ${index + 1}</b>

            ${hubNameHtml}

            <div>Tâm ID: ${item.centerId}</div>

            <div>Cover: <b>${item.score}</b> điểm mới</div>

            <button data-center-id="${item.centerId}">

                <i class="fa-solid fa-plus"></i> Tạo Nhóm Mới

            </button>

        `;
                row.addEventListener('mouseenter', (e) => showPreview(item, e.currentTarget));

                row.addEventListener('mouseleave', () => clearPreview());

                row.querySelector('button').addEventListener('click', (e) => {

                    e.stopPropagation();

                    popup_createGroup(item.centerId);

                });

                rankTableBody.appendChild(row);

            });
            // 2. Render MOVE (Di chuyển)

            const groupedMoveActions = new Map();

            moveActions.forEach(item => {

                if (!groupedMoveActions.has(item.pointToMove.id)) {

                    groupedMoveActions.set(item.pointToMove.id, []);

                }

                groupedMoveActions.get(item.pointToMove.id).push(item);

            });
            groupedMoveActions.forEach((actions, pointId) => {

                const pointToMove = actions[0].pointToMove;

                const currentGroup = allGroups.find(g => g.id === pointToMove.groupId);
                const row = document.createElement('div');

                row.className = 'rank-item rank-item-move';

                row.dataset.pointId = pointId;
                // Gắn sự kiện Click của Row để Focus/Zoom trên bản đồ

                row.addEventListener('click', (e) => {

                    // Chỉ focus nếu không click vào nút button

                    if (e.target.tagName !== 'BUTTON' && e.target.closest('button') === null) {

                        focusOnPoint(pointId);

                    }

                });
                let buttonsHTML = '';

                actions.forEach(item => {

                    buttonsHTML += `

                <button data-point-id="${item.pointToMove.id}" data-group-id="${item.targetGroup.id}">

                    <i class="fa-solid fa-arrow-right-arrow-left"></i> Chuyển G${item.targetGroup.groupNumber}

                </button>

            `;

                });
                row.innerHTML = `

            <b>(Di chuyển) Điểm ID: ${pointId}</b>

            <div>Từ: Nhóm ${currentGroup.groupNumber} (Tâm ID: ${currentGroup.centerPoint.id})</div>

            <div class="button-group">

                ${buttonsHTML}

            </div>

        `;
                row.addEventListener('mouseenter', (e) => {

                    showPreview(actions[0], e.currentTarget);

                });

                row.addEventListener('mouseleave', () => {

                    clearPreview();

                });
                row.querySelectorAll('button').forEach((button, index) => {

                    button.addEventListener('click', (e) => {

                        e.stopPropagation();

                        const pointId = e.currentTarget.dataset.pointId;

                        const groupId = parseInt(e.currentTarget.dataset.groupId);

                        movePoint(pointId, groupId);

                    });

                });
                rankTableBody.appendChild(row);

            });

        }

        /**
        
         * (SỬA LỖI ZOOM) Hàm tập trung (Focus) vào một điểm trên bản đồ.
        
         */

        function focusOnPoint(pointId) {

            const point = allPoints.find(p => String(p.id) === String(pointId));
            if (!point || !point.marker) {

                showToast(`Lỗi: Không tìm thấy điểm ID ${pointId} trên bản đồ.`, "error");

                return;

            }
            if (!point.isVisible) {

                showToast(`Điểm ID ${pointId} đang bị ẩn bởi bộ lọc hiện tại.`, "warning");

            }
            // [ĐÃ SỬA] Thay map.flyTo bằng map.panTo để chỉ di chuyển, giữ nguyên zoom

            map.panTo(point.latlng);
            // 2. Mở popup (nếu có)

            if (currentPopup) {

                map.closePopup(currentPopup);

                currentPopup = null;

            }
            // Kích hoạt sự kiện click của marker (như click bằng tay)

            if (point.marker) {

                point.marker.fire('click');

            }
            // [ĐÃ XÓA] Loại bỏ logic zoomToShowLayer để tránh thay đổi zoom

            /*
        
            if (isClusteringEnabled && pointMarkersLayer.hasLayer(clusterLayer)) {
        
                pointMarkersLayer.zoomToShowLayer(point.marker, () => {
        
                    if (point.marker) {
        
                        point.marker.fire('click');
        
                    }
        
                });
        
            }
        
            */
            showToast(`Đã tập trung vào Điểm ID: ${pointId}`, 'info');

        }

        /**
        
         * (SỬA LỖI HOÀN CHỈNH) Hàm xử lý sự kiện click trên Marker.
        
         * Quyết định hiển thị Popup Pin, Popup Tham Chiếu, hoặc Popup Hành Động (Action Popup).
        
         */

        function handleMarkerClick(pointData) {

            if (currentPopup) {

                map.closePopup(currentPopup);

                currentPopup = null;

            }
            let shouldZoom = false;
            if (pointData.nhnn) {

                // === XỬ LÝ ĐIỂM NHNN ===

                let html = `<div class="action-popup-header">Điểm Tham Chiếu</div>

                                <div class="action-popup-buttons">

                                    <div class="action-popup-info" style="text-align: center; padding: 10px 0;">

                                        <img src="${pointData.marker.options.icon.options.iconUrl}" style="width: 30px; height: 30px; margin: 0 auto 5px auto;"><br>

                                        <b>${pointData.id}</b><br>(Ngân hàng Nhà nước)

                                    </div>

                                </div>`;
                currentPopup = L.popup({ closeButton: true, minWidth: 220, className: 'action-popup' })

                    .setLatLng(pointData.latlng)

                    .setContent(html)

                    .openOn(map);
                shouldZoom = true;
            } else if (isBatteryView) {

                // === XỬ LÝ CHẾ ĐỘ PIN/TỒN QUỸ ===

                let html = `<div class="action-popup-header">${pointData.id}</div>

                                <div class="action-popup-info battery-info-popup">

                                    <b>Tồn quỹ:</b> ${formatFullNumber(pointData.tonQuy)}<br>

                                    <b>Hạn mức:</b> ${formatFullNumber(pointData.hanMuc)}<br>

                                    <b>Trạng thái:</b> ${pointData.vuotHanMuc ?

                        '<span style="color: red; font-weight: bold;">Vượt Hạn Mức</span>' :

                        'Trong Hạn Mức'}

                                </div>`;
                currentPopup = L.popup({ closeButton: true, minWidth: 220, className: 'action-popup' })

                    .setLatLng(pointData.latlng)

                    .setContent(html)

                    .openOn(map);
                shouldZoom = true;
            } else {

                // === XỬ LÝ POPUP HÀNH ĐỘNG (THÊM/HỦY NHÓM) ===
                // 1. Tìm nhóm hiện tại của điểm 

                let currentGroupId = null;

                for (const name in groups) {

                    if (groups[name].pointIds.includes(pointData.id)) {

                        currentGroupId = groups[name].id;

                        break;

                    }

                }
                // 2. Tạo nội dung Popup HÀNH ĐỘNG (gồm nút Hủy/Chuyển nhóm)

                const content = createActionPopupContent(pointData.id, currentGroupId);
                // 3. Gán Popup MỚI

                currentPopup = L.popup({ closeButton: true, minWidth: 220, className: 'action-popup' })

                    .setLatLng(pointData.latlng)

                    .setContent(content)

                    .openOn(map);
                // 4. Logic Zoom: Chỉ zoom khi điểm đã có nhóm (hoặc bạn có thể chọn luôn zoom)

                shouldZoom = (currentGroupId !== null);

            }
            // Chỉ zoom khi cờ shouldZoom = true

            if (shouldZoom) {

                const currentZoom = map.getZoom();

                map.flyTo(pointData.latlng, Math.max(currentZoom, 16));

            }

        }
        /**
        
         * (SỬA VỊ TRÍ) Hàm hiển thị vòng tròn 30km và Tooltip Thống Kê Chi Tiết.
        
         * Tooltip được đặt gần rìa vòng tròn bằng cách sử dụng L.tooltip() tại một vị trí cố định.
        
         */

        function showPreview(item, rowElement = null) {

            clearPreview();
            const centerPoint = (item.type === 'MOVE') ? item.targetGroup.centerPoint : item.centerPoint;

            if (!centerPoint) return;
            const color = item.color;
            // 1. Vẽ vòng tròn 30km

            L.circle(centerPoint.latlng, {

                radius: RADIUS_METERS,

                color: color,

                weight: 3.5,

                opacity: 0.95,

                fillColor: color,

                fillOpacity: 0.5,

                dashArray: '10, 10'

            }).addTo(previewLayer);
            // 2. TẠO TOOLTIP THỐNG KÊ CHI TIẾT (Chỉ cho loại 'NEW' - Tạo nhóm mới)

            if (item.type === 'NEW' && item.tooltipContent) {
                // ✨ LOGIC ĐẨY TOOLTIP SANG PHẢI (VỊ TRÍ CỐ ĐỊNH THEO PIXEL) ✨

                // Tăng Offset lên 250px để Tooltip nằm hẳn ngoài vòng tròn (tránh bị che)

                const PIXEL_OFFSET = L.point(250, 0);
                L.tooltip({

                    permanent: true,

                    direction: 'right', // Không quan trọng vì dùng offset lớn

                    className: 'distance-tooltip',

                    offset: PIXEL_OFFSET, // <-- ÁP DỤNG OFFSET LỚN

                    opacity: 0.95,

                    pane: 'popupPane'

                })

                    .setLatLng(centerPoint.latlng) // Vẫn gắn vào tọa độ tâm

                    .setContent(item.tooltipContent)

                    .addTo(previewLayer);

            }
            // 3. Logic cho chế độ MOVE / Tô màu điểm (Giữ nguyên)

            if (item.type === 'MOVE') {

                const pointToMove = item.pointToMove;

                const targetGroup = item.targetGroup;
                // 3a. Làm mờ tất cả điểm PGD/ATM đang hiển thị

                allPoints.filter(p => p.isVisible && !p.nhnn).forEach(p => {

                    if (p.marker && p.marker._map) { p.marker.setOpacity(0.3); }

                });
                // 3b. Làm nổi bật tâm và điểm sắp chuyển

                if (!targetGroup.centerPoint.nhnn && targetGroup.centerPoint.marker && targetGroup.centerPoint.marker._map) {

                    targetGroup.centerPoint.marker.setOpacity(1.0);

                }

                if (!pointToMove.nhnn && pointToMove.marker && pointToMove.marker._map) {

                    pointToMove.marker.setOpacity(1.0);

                }

            } else { // Xử lý làm mờ/sáng cho chế độ NEW

                const coveredIds = new Set(item.coveredPoints.map(p => p.id));
                // Làm mờ các điểm đã nhóm

                allPoints.filter(p => p.groupId !== null && p.isVisible && !p.nhnn).forEach(p => {

                    if (p.marker && p.marker._map) { p.marker.setOpacity(0.3); }

                });
                // Sáng điểm tâm (centerPoint) và các điểm được bao phủ

                allPoints.filter(p => p.groupId === null && p.isVisible && !p.nhnn).forEach(p => {

                    if (p.marker && p.marker._map) {

                        if (p.id === centerPoint.id || coveredIds.has(p.id)) {

                            p.marker.setOpacity(1.0);

                        } else {

                            p.marker.setOpacity(0.3); // Mờ các điểm không được bao phủ

                        }

                    }

                });

            }

        }
        /**
    
         * (SỬA ĐỔI v41: Thêm kiểm tra an toàn cho gom cụm)
    
         */

        function clearPreview() {

            previewLayer.clearLayers();
            allPoints.filter(p => p.isVisible && p.marker).forEach(p => { // (SỬA v41) Thêm check p.marker

                // Chỉ reset opacity nếu marker đang hiển thị

                if (p.marker._map) {

                    p.marker.setOpacity(1.0);

                }
                if (p.marker._icon) {

                    p.marker._icon.classList.remove('point-move-preview');

                }
                // Logic reset icon này đã an toàn, 

                // vì L.markerClusterGroup sẽ gọi lại icon function khi cần

                if (p.nhnn) { // Điểm NHNN

                    p.marker.setIcon(createNHNNIcon());

                } else if (p.groupId === null) { // Điểm PGD chưa nhóm

                    // (SỬA v37)

                    p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());

                } else if (p.groupId !== 'REFERENCE') { // Điểm PGD đã vào nhóm

                    const group = allGroups.find(g => g.id === p.groupId);

                    if (group) {

                        if (p.id === group.centerPoint.id) {

                            p.marker.setIcon(createCenterPointIcon(group.color));

                        } else {

                            // (SỬA v37)

                            p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());

                        }

                    }

                }

            });

        }
/**
 * (FIX: Đảm bảo khởi tạo polylineCache khi tạo nhóm)
 */
function popup_createGroup(pointId) {
    if (currentPopup) {
        map.closePopup(currentPopup);
        currentPopup = null;
    }
    const centerPoint = allPoints.find(p => String(p.id) === String(pointId));
    if (!centerPoint) {
        showToast(`Lỗi: Không tìm thấy điểm ID ${pointId}.`, "error");
        return;
    }
    // Tìm các điểm CHƯA NHÓM nằm trong bán kính
    const coveredPoints = allPoints.filter(p => {
        if (p.id === centerPoint.id || p.nhnn) return false;
        if (p.groupId !== null && p.groupId !== 'REFERENCE') return false;
        const distance = centerPoint.latlng.distanceTo(p.latlng);
        return distance <= RADIUS_METERS;
    });
    const newGroupNumber = allGroups.length + 1;
    const newGroupColor = GROUP_COLORS[allGroups.length % GROUP_COLORS.length];
    const newGroupId = `G_${newGroupNumber}`;
    // Tạo mảng điểm, BẮT ĐẦU VỚI ĐIỂM TÂM
    const pointsInGroup = [centerPoint, ...coveredPoints];
    const newGroup = {
        id: newGroupId,
        centerPoint: centerPoint,
        // ✨ THÊM THUỘC TÍNH NÀY KHI LƯU NHÓM ✨
        fixedRadiusMeters: RADIUS_METERS, // Lưu lại bán kính cố định
        fixedRadiusKm: currentRadiusKm,
        points: pointsInGroup, // <--- THÊM ĐIỂM TÂM VÀO MẢNG NÀY
        color: newGroupColor,
        groupNumber: newGroupNumber,
        routingControls: [],
        polylineCache: {}
    };
    allGroups.push(newGroup);
    // CẬP NHẬT DỮ LIỆU ĐIỂM TRƯỚC KHI VẼ
    centerPoint.groupId = newGroupId;
    const coveredIds = new Set(coveredPoints.map(p => p.id));
    allPoints.forEach(p => {
        if (coveredIds.has(p.id)) {
            p.groupId = newGroupId;
        }
    });
    // ĐỒNG BỘ: Cập nhật biến groups (cho Popup Chuyển Nhóm)
    const pointIdsInGroup = pointsInGroup.map(p => p.id); // Lấy tất cả ID (bao gồm tâm)
    groups[`NHÓM ${newGroupNumber}`] = {
        id: newGroupId,
        color: newGroupColor,
        pointIds: pointIdsInGroup
    };
    // ==========================================================
    drawAllGroups();
    updateRankTable();
    updateFilterOptions();
    // Fix Lỗi Zoom
    const message = (coveredPoints.length > 0)
        ? `Đã tạo thành công Nhóm ${newGroupNumber} với ${coveredPoints.length} điểm.`
        : "Đã tạo Nhóm mới, nhưng không có điểm nào chưa nhóm trong bán kính 30km.";
    Toastify({
        text: message,
        className: coveredPoints.length > 0 ? "custom-toast success" : "custom-toast warning",
    }).showToast();
}


        function popup_addPointToGroup(pointId, targetGroupId) {

            const pointToAdd = allPoints.find(p => String(p.id) === String(pointId));

            const targetGroup = allGroups.find(g => g.id === targetGroupId);
            if (!pointToAdd || !targetGroup) {

                showToast("Lỗi: Không tìm thấy điểm hoặc nhóm", "error");

                return;

            }
            targetGroup.points.push(pointToAdd);

            pointToAdd.groupId = targetGroupId;
            if (currentPopup) map.closePopup();

            updateRankTable();

            drawAllGroups();

            updateFilterOptions(); // (MỚI v40)

            showToast(`Đã thêm Điểm ${pointId} vào Nhóm ${targetGroup.groupNumber}`, 'success');

        }
        /**
        
         * (SỬA LỖI HOÀN CHỈNH) Hàm chuyển điểm từ Bảng Xếp Hạng.
        
         * Chỉ gọi hàm chính movePointToGroup để đảm bảo đồng bộ hóa dữ liệu.
        
         */

        function movePoint(pointId, newGroupId) {

            // Gọi hàm chính (đã có logic xử lý đồng bộ dữ liệu và loại trừ lẫn nhau)

            movePointToGroup(pointId, newGroupId);
            // Lưu ý: Các hàm updateRankTable, drawAllGroups, updateFilterOptions 

            // đã được gọi bên trong movePointToGroup.

        }
        /**
        
         * (SỬA LỖI FINAL BÁN KÍNH) Vẽ các nhóm đã lưu. 
        
         * Kiểm tra fixedRadiusMeters một cách cẩn thận để chống lỗi khi load từ localStorage.
        
         * Nếu fixedRadiusMeters hợp lệ (> 0), sử dụng nó. Nếu không, dùng 30km mặc định.
        
         */

        function drawAllGroups() {

            clearAnalysisVisuals();

            let bounds = L.latLngBounds();
            const allNHNNPoints = allPoints.filter(p => p.nhnn && p.isVisible);
            allGroups.forEach(group => {

                const { centerPoint, points, color, groupNumber } = group;
                if (!centerPoint.isVisible) { return; }
                // ✨ LOGIC ĐÃ SỬA: KIỂM TRA BÁN KÍNH MỘT CÁCH CHẮC CHẮN ✨

                const DEFAULT_RADIUS_METERS = 30000;
                // Kiểm tra group.fixedRadiusMeters: phải là số hữu hạn VÀ lớn hơn 0.

                // Nếu hợp lệ, sử dụng nó. Nếu không, dùng 30000m (30km).

                const groupRadius = (isFinite(group.fixedRadiusMeters) && group.fixedRadiusMeters > 0)

                    ? Number(group.fixedRadiusMeters)

                    : DEFAULT_RADIUS_METERS;
                // Chỉ vẽ Vòng tròn và Line nếu KHÔNG ở chế độ Pin

                if (!isBatteryView) {
                    // Vẽ vòng tròn phân tích

                    L.circle(centerPoint.latlng, {

                        radius: groupRadius, // SỬ DỤNG BÁN KÍNH CỐ ĐỊNH AN TOÀN

                        color: color,

                        weight: 3,

                        opacity: 0.9,

                        fillColor: color,

                        fillOpacity: 0.25

                    }).addTo(analysisLayer);
                    // Vẽ line từ TÂM NHÓM đến các NHNN lân cận

                    allNHNNPoints.forEach(nhnnPoint => {

                        const distance = centerPoint.latlng.distanceTo(nhnnPoint.latlng);

                        // Sử dụng groupRadius để kiểm tra khoảng cách

                        if (distance <= groupRadius) {

                            const distanceInKm = (distance / 1000).toFixed(2);

                            const labelContent = `~ ${distanceInKm} km`;

                            const line = L.polyline([centerPoint.latlng, nhnnPoint.latlng], { color: NHNN_PREVIEW_LINE_COLOR, weight: 2, opacity: 0.9, dashArray: '8, 4', className: 'animated-route-line' }).addTo(analysisLayer);

                            if (showDistanceLabels) { line.bindTooltip(labelContent, { permanent: true, direction: 'center', className: 'distance-tooltip', offset: [0, -8] }); }

                        }

                    });

                }
                bounds.extend(centerPoint.latlng);
                const visiblePointsInGroup = points.filter(p => p.isVisible);
                points.forEach(pointData => {

                    if (!pointData.isVisible) { return; }

                    bounds.extend(pointData.latlng);
                    if (pointData.id === centerPoint.id) {

                        pointData.marker.setIcon(createCenterPointIcon(color));
                        // (*** PHẦN ĐÃ SỬA: HIỂN THỊ GỌN GÀNG TRÊN 1 DÒNG ***)

                        const tooltipMessage = `${pointData.id} (${visiblePointsInGroup.length} điểm)`;
                        const centerTooltip = pointData.marker.bindTooltip(tooltipMessage, {

                            permanent: true,

                            direction: 'bottom',

                            offset: L.point(0, 10),

                            // SỬ DỤNG CLASS CŨ HOẶC MỚI (Tôi dùng class có sẵn của bạn)

                            className: 'distance-tooltip distance-tooltip-compact' // Thêm class mới

                        }).openTooltip();

                        // ... (giữ nguyên sự kiện add)

                        centerTooltip.on('add', function () {

                            const container = this.getElement();

                            if (container) {

                                container.style.borderColor = color;

                                L.DomEvent.on(container, 'click', (e) => { L.DomEvent.stopPropagation(e); handleMarkerClick(pointData); });

                            }

                        });

                    } else {

                        // Thành viên nhóm dùng icon Pin hoặc PGD (Icon Pin được kiểm tra TSCN bên trong hàm createBatteryIcon)

                        pointData.marker.setIcon(isBatteryView ? createBatteryIcon(pointData) : createPGDIcon());
                        // Chỉ vẽ đường line/routing nếu KHÔNG ở chế độ Pin

                        if (!isBatteryView) {

                            calculateAndDrawLine(centerPoint.latlng, pointData.latlng, pointData, group);

                        }

                    }

                });

            });

        }
        /**
        
         * (ĐÃ SỬA LỖI REMOVELAYER) Xóa toàn bộ đường phân tích (vòng tròn, polyline)
        
         */

        function clearAnalysisVisuals() {

            allGroups.forEach(group => {

                if (group.routingControls) {

                    group.routingControls.forEach(router => {

                        try {

                            // Xóa control định tuyến

                            map.removeControl(router);

                        } catch (e) {

                            // Xử lý lỗi nếu router đã bị xóa

                        }

                    });

                    // Rất quan trọng: Xóa sạch mảng sau khi xóa khỏi map

                    group.routingControls = [];

                }

            });
            analysisLayer.clearLayers();
            // (FIX LỖI) Kiểm tra measureLayer có tồn tại trước khi dùng

            if (measureLayer) {

                measureLayer.clearLayers();

            }
            allPoints.filter(p => p.isVisible).forEach(p => {

                if (p.nhnn) { // Giữ nguyên icon NHNN

                    p.marker.setIcon(createNHNNIcon());

                } else if (p.groupId === null) { // Điểm chưa nhóm

                    p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());

                } else if (p.groupId !== 'REFERENCE') { // Điểm đã vào nhóm (không phải NHNN)

                    // Reset về icon PGD/Pin

                    p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());

                }
                if (p.marker.getTooltip()) {

                    p.marker.unbindTooltip();

                }

            });

        }


        /**
    
         * (SỬA v48) Xóa logic của hàm ClearAll (vì nút đã bị xóa)
    
         * Giữ lại hàm rỗng để tránh lỗi nếu có code cũ gọi
    
         */

        function clearAll() {

            showToast("Chức năng Xóa Tất Cả đã bị tắt.", "warning");

            // (Toàn bộ logic xóa đã được gỡ bỏ)

        }
        /**
        
         * (SỬA VỊ TRÍ VÀ MÀU SẮC TOOLTIP) Hàm Hybrid: Vẽ chim bay hoặc Lái xe (Ưu tiên dùng Cache) và gán Tooltip.
        
         */

        function calculateAndDrawLine(startLatLng, endLatLng, pointData, group) {

            const { color, groupNumber } = group;

            const endMarker = pointData.marker;
            // Tính khoảng cách Chim Bay (dùng cho Tooltip chung)

            const distanceInKm = (startLatLng.distanceTo(endLatLng) / 1000).toFixed(2);
            let tooltipContent;

            let isCached = false;
            if (isBirdMode) {

                // === CHẾ ĐỘ CHIM BAY (Bird Mode) ===

                L.polyline([startLatLng, endLatLng], {

                    color: color,

                    opacity: 1.0,

                    weight: 5,

                    dashArray: '10, 10',

                    className: 'animated-route-line'

                }).addTo(analysisLayer);
                // [SỬA] Nội dung Tooltip: TermID + km (Không màu)

                tooltipContent = `<span class="group-name">${pointData.id}</span>~ ${distanceInKm} km`;

            } else {

                // === CHẾ ĐỘ LÁI XE (Car Mode) - ƯU TIÊN DÙNG CACHE ===

                const cachedJson = group.polylineCache[pointData.id];
                if (cachedJson) {

                    // ... (vẽ Polyline từ cache giữ nguyên) ...
                    // [SỬA] Nội dung Tooltip: TermID + km (cached)

                    tooltipContent = `<span class="group-name">${pointData.id}</span>🚗 ${distanceInKm} km (cached)`;

                    isCached = true;
                } else {

                    // [SỬA] Nội dung Tooltip: TermID + Loading

                    tooltipContent = `<span class="group-name">${pointData.id}</span>... <i class="fa-solid fa-spinner loading-spinner"></i>`;
                    routingQueue.push({

                        startLatLng, endLatLng, endMarker, pointData, color, groupNumber, group

                    });

                }

            }
            // (*** LOGIC GÁN TOOLTIP CHO MARKER VÀ CĂN CHỈNH ANCHOR ***)

            if (!isBatteryView && showDistanceLabels) {

                // Do TermID Tooltip là vĩnh viễn và căn trên, Tooltip này sẽ được căn dưới
                // Cần đảm bảo Tooltip khoảng cách CŨ (nếu có) bị hủy để Tooltip mới không bị chồng

                // Mặc dù Leaflet có thể tự xử lý, unbind để tránh lỗi logic.

                endMarker.unbindTooltip();
                const tooltip = endMarker.bindTooltip(tooltipContent, {

                    permanent: true,
                    // ĐIỀU CHỈNH: Đặt Tooltip phía dưới điểm

                    direction: 'bottom',
                    className: 'distance-tooltip',
                    // ĐIỀU CHỈNH OFFSET: Đẩy Tooltip xuống dưới một chút

                    offset: L.point(0, 10)
                }).openTooltip();
                tooltip.on('add', function () {

                    const container = this.getElement();

                    if (container) {

                        // [SỬA] Loại bỏ màu sắc Tooltip (chỉ giữ màu viền mặc định)

                        container.style.borderColor = '#ccc';
                        L.DomEvent.on(container, 'click', (e) => {

                            L.DomEvent.stopPropagation(e);

                            handleMarkerClick(pointData);

                        });

                    }

                });

            }
            // Chỉ chạy hàng đợi nếu đang ở chế độ Lái xe VÀ không sử dụng cache

            if (!isBirdMode && !isCached) {

                processRoutingQueue();

            }

        }
        /**
        
         * (ĐÃ SỬA LỖI REMOVELAYER) Xử lý hàng đợi định tuyến, từng bước một.
        
         * @param {boolean} [shouldExport=true] - Có nên gọi exportGroupsData() sau khi hoàn thành không.
        
         */

        async function processRoutingQueue(shouldExport = true) {

            // 1. Kiểm tra trạng thái an toàn

            if (isBirdMode) {

                // Đảm bảo không còn tác vụ nào chạy khi ở chế độ chim bay

                isProcessingQueue = false;

                return;

            }
            if (isProcessingQueue || routingQueue.length === 0) {

                return;

            }
            isProcessingQueue = true;

            const task = routingQueue.shift();
            // === LẤY THAM SỐ ===

            const { startLatLng, endLatLng, endMarker, pointData, color, groupNumber, group } = task;
            if (!group || !pointData || !endMarker) {

                console.error("Lỗi: Tác vụ định tuyến bị thiếu dữ liệu quan trọng.");

                isProcessingQueue = false;

                processRoutingQueue(shouldExport);

                return;

            }
            const cacheKey = pointData.id;
            // 2. Khởi tạo Routing Control

            const router = L.Routing.control({

                waypoints: [startLatLng, endLatLng],

                show: false,

                addWaypoints: false,

                createMarker: () => null,

                lineOptions: {

                    addWaypoints: false,

                    styles: [{

                        color: color,

                        opacity: 1.0,

                        weight: 5,

                        dashArray: '10, 10',

                        className: 'animated-route-line'

                    }]

                }

            }).addTo(map);
            // Lưu router vào mảng controls của nhóm

            group.routingControls.push(router);
            // === HÀM KẾT THÚC AN TOÀN ===

            const finishTask = async () => {

                // Gỡ Router khỏi Map một cách an toàn

                try {

                    map.removeControl(router);

                    // Xóa router khỏi mảng quản lý của nhóm để tránh xóa lần nữa

                    const index = group.routingControls.indexOf(router);

                    if (index > -1) {

                        group.routingControls.splice(index, 1);

                    }

                } catch (e) {

                    // console.warn("Lỗi an toàn khi removeControl:", e); // Gỡ lỗi

                }
                await new Promise(resolve => setTimeout(resolve, ROUTING_DELAY_MS));

                isProcessingQueue = false;

                processRoutingQueue(shouldExport);

            };

            // =============================


            router.on('routesfound', function (e) {

                // --- LƯU CACHE POLYLINE ---

                const route = e.routes[0];

                const coordinates = route.coordinates.map(c => ({ lat: c.lat, lon: c.lng }));
                group.polylineCache[cacheKey] = JSON.stringify(coordinates);
                if (shouldExport) {

                    exportGroupsData();

                }

                // -------------------------
                // Cập nhật tooltip

                const isMarkerStillOnMap = pointMarkersLayer.hasLayer(endMarker) || nhnnMarkersLayer.hasLayer(endMarker);

                if (pointData.isVisible && endMarker && isMarkerStillOnMap && !isBatteryView && showDistanceLabels) {

                    const distanceInKm = (route.summary.totalDistance / 1000).toFixed(2);

                    // [ĐÃ SỬA] Nội dung Tooltip: TermID + km (Đã tính)

                    const tooltipContent = `<span class="group-name" style="color: ${color};">${pointData.id}</span>🚗 ${distanceInKm} km`;

                    endMarker.unbindTooltip();
                    const newTooltip = endMarker.bindTooltip(tooltipContent, {

                        permanent: true, direction: 'top', className: 'distance-tooltip'

                    }).openTooltip();
                    newTooltip.on('add', function () {

                        const container = this.getElement();

                        if (container) {

                            container.style.borderColor = color;

                            L.DomEvent.on(container, 'click', (e) => {

                                L.DomEvent.stopPropagation(e);

                                handleMarkerClick(pointData);

                            });

                        }

                    });

                }
                finishTask();

            });
            router.on('routingerror', function (e) {

                console.error(`Lỗi định tuyến cho điểm ${pointData.id}:`, e.message);

                showToast(`Lỗi định tuyến cho ${pointData.id}.`, "error");
                // Vẽ đường chim bay để thay thế

                L.polyline([startLatLng, endLatLng], {

                    color: color,

                    opacity: 0.5,

                    weight: 3,

                    dashArray: '5, 5'

                }).addTo(analysisLayer);
                finishTask();

            });

        }


        /**
    
         * Hàm hiển thị thông báo (Toastify)
    
         */

        function showToast(message, type = 'info') {

            const typeClasses = { info: 'info', success: 'success', warning: 'warning', error: 'error' };

            const iconMap = { info: 'ℹ️', success: '✅', warning: '⚠️', 'error': '❌' };
            Toastify({

                text: `${iconMap[type]} ${message}`,

                duration: 2500,

                gravity: "bottom",

                position: "right",

                className: `custom-toast ${typeClasses[type]} text-white`

            }).showToast();

        }
        function highlightRankItem(pointId) {

            const newRow = document.querySelector(`.rank-item-new[data-point-id="${pointId}"]`);

            if (newRow) {

                newRow.classList.add('rank-item-highlight');

                newRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            }
            const moveRow = document.querySelector(`.rank-item-move[data-point-id="${pointId}"]`);

            if (moveRow) {

                moveRow.classList.add('rank-item-highlight');

                moveRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            }

        }
        function clearRankItemHighlight() {

            document.querySelectorAll('.rank-item-highlight').forEach(row => {

                row.classList.remove('rank-item-highlight');

            });

        }
        /**
    
         * (SỬA v38) Cập nhật style cho nút
    
         */

        function toggleRoutingMode() {

            isBirdMode = !isBirdMode;

            const button = document.getElementById('routing-toggle-btn');
            if (currentPopup) map.closePopup(currentPopup);
            if (isBirdMode) {

                button.innerHTML = '<i class="fa-solid fa-feather w-4 h-4"></i> <span class="button-text">Đường chim Bay</span>'; // Sửa chữ v48

                button.classList.add('bird-mode');

                button.classList.remove('car-mode');

                routingQueue = [];

                isProcessingQueue = false;

                showToast("Đã BẬT: Chế độ Chim Bay (Nhanh)", 'warning');

            } else {

                button.innerHTML = '<i class="fa-solid fa-car w-4 h-4"></i> <span class="button-text">Lái xe (Chậm)</span>'; // Sửa chữ v48

                button.classList.add('car-mode');

                button.classList.remove('bird-mode');

                showToast("Đã BẬT: Chế độ Lái xe (Chậm)", 'info');

            }
            drawAllGroups();

        }
        /**
    
         * (MỚI v42) Hàm Bật/Tắt tính năng Gom Cụm (Clustering)
    
         */

        function toggleClustering() {

            // 1. Đảo ngược trạng thái

            isClusteringEnabled = !isClusteringEnabled;

            const button = document.getElementById('cluster-toggle-btn');
            if (currentPopup) map.closePopup(currentPopup);
            // 2. Xóa layer CŨ khỏi bản đồ

            map.removeLayer(pointMarkersLayer);
            // 3. (Quan trọng) Cập nhật con trỏ pointMarkersLayer

            if (isClusteringEnabled) {

                pointMarkersLayer = clusterLayer; // Trỏ sang LỚP GOM CỤM
                // Cập nhật nút

                button.innerHTML = '<i class="fa-solid fa-boxes-stacked w-4 h-4"></i> <span class="button-text">Gom Cụm (Bật)</span>';

                button.classList.add('cluster-on');

                button.classList.remove('cluster-off');

                showToast("Đã BẬT: Gom Cụm", 'info');
            } else {

                pointMarkersLayer = standardLayer; // Trỏ sang LỚP TIÊU CHUẨN
                // Cập nhật nút

                button.innerHTML = '<i class="fa-solid fa-braille w-4 h-4"></i> <span class="button-text">Gom Cụm (Tắt)</span>';

                button.classList.add('cluster-off');

                button.classList.remove('cluster-on');

                showToast("Đã TẮT: Gom Cụm (Hiển thị tất cả)", 'warning');

            }
            // 4. Thêm layer MỚI vào bản đồ

            map.addLayer(pointMarkersLayer);
            // 5. Yêu cầu vẽ lại các marker

            updateMarkersVisibility();
            // 6. Vẽ lại các đường line/vòng tròn

            drawAllGroups();

        }


        /**
    
         * (MỚI v40) Hàm tải và vẽ viền GeoJSON của Việt Nam
    
         */

        function loadVietnamBorder() {

            // Đường dẫn đến file GeoJSON (bao gồm Hoàng Sa, Trường Sa)

            // Nguồn: https://github.com/thangdng/vietnam-boundary

            const geoJsonUrl = 'https://raw.githubusercontent.com/thangdng/vietnam-boundary/master/vietnam-with-islands.geojson';
            // Tùy chỉnh style cho viền

            const borderStyle = {

                "color": "#00008B",  // (Bạn có thể đổi màu viền ở đây, vd: "#FF0000" cho màu đỏ)

                "weight": 2,        // Độ dày của viền

                "opacity": 0.8,

                "fillOpacity": 0.0, // Quan trọng: Không tô màu nền

                "pane": "borderPane" // (MỚI v40) Vẽ lên pane đã tạo

            };
            fetch(geoJsonUrl)

                .then(response => response.json())

                .then(data => {

                    L.geoJSON(data, {

                        style: borderStyle

                    }).addTo(map); // Thêm vào bản đồ

                })

                .catch(error => {

                    console.error('Lỗi khi tải viền bản đồ Việt Nam:', error);

                    showToast("Không tải được viền bản đồ VN", "error");

                });

        }
        /**
       
        * (SỬA LỚN) Bật/Tắt chế độ Pin và áp dụng bộ lọc hiển thị.
       
        */

        function toggleBatteryView() {

            isBatteryView = !isBatteryView;

            const button = document.getElementById('battery-toggle-btn');
            if (isBatteryView) {

                button.innerHTML = '<i class="fa-solid fa-map-pin w-4 h-4"></i> <span class="button-text">Chế độ Ghim</span>';

                button.classList.add('battery-mode');

                button.classList.remove('pin-mode');

                showToast("Đã BẬT: Chế độ Pin", 'info');
                // YÊU CẦU MỚI: ẨN CÁC ĐƯỜNG PHÂN TÍCH (Vòng tròn Hub & Routing)

                if (analysisLayer) analysisLayer.clearLayers();

                if (measureLayer) measureLayer.clearLayers();
            } else {

                button.innerHTML = '<i class="fa-solid fa-battery-half w-4 h-4"></i> <span class="button-text">Chế độ Pin</span>';

                button.classList.add('pin-mode');

                button.classList.remove('battery-mode');

                showToast("Đã TẮT: Chế độ Pin", 'warning');

            }
            // (*** QUAN TRỌNG: Gọi hàm lọc mới để ẩn các chấm ghim ***)

            updateMarkersVisibility();

            // ----------------------------------------------------
            // Vẽ lại toàn bộ map để cập nhật icon (và vẽ lại layer analysis nếu Tắt Pin)

            drawAllGroups();

            clearPreview();

            // (MỚI v39) Cập nhật Bảng Xếp Hạng (để ẩn nó đi khi bật Pin)

            updateRankTable();

        }
        // *** Tự động gọi hàm tải dữ liệu sau khi map khởi tạo ***
        loadPreloadedData();


        // --- LOGIC ĐIỀU KHIỂN BỘ LỌC BẢN ĐỒ ---

        const tilePane = document.querySelector('.leaflet-tile-pane');

        const grayscaleSlider = document.getElementById('grayscale-slider');

        const brightnessSlider = document.getElementById('brightness-slider');

        const contrastSlider = document.getElementById('contrast-slider');

        const blurSlider = document.getElementById('blur-slider');
        const grayscaleLabel = document.querySelector('label[for="grayscale-slider"]');

        const brightnessLabel = document.querySelector('label[for="brightness-slider"]');

        const contrastLabel = document.querySelector('label[for="contrast-slider"]');

        const blurLabel = document.querySelector('label[for="blur-slider"]');
        function updateMapFilter() {

            if (!tilePane) return;
            const grayscale = grayscaleSlider.value;

            const brightness = brightnessSlider.value;

            const contrast = contrastSlider.value;

            const blur = blurSlider.value;
            grayscaleLabel.innerText = `Độ xám: ${Number(grayscale).toFixed(1)}`;

            brightnessLabel.innerText = `Độ sáng: ${Number(brightness).toFixed(2)}`;

            contrastLabel.innerText = `Tương phản: ${Number(contrast).toFixed(1)}`;

            if (blurLabel) {

                blurLabel.innerText = `Độ nhòe (Blur): ${Number(blur).toFixed(1)} px`;

            }
            const filterString = `grayscale(${grayscale}) brightness(${brightness}) contrast(${contrast}) blur(${blur}px)`;
            tilePane.style.filter = filterString;

        }
        grayscaleSlider.addEventListener('input', updateMapFilter);

        brightnessSlider.addEventListener('input', updateMapFilter);

        contrastSlider.addEventListener('input', updateMapFilter);

        blurSlider.addEventListener('input', updateMapFilter);
        // Gọi hàm lần đầu để áp dụng giá trị mặc định (từ HTML)

        updateMapFilter();
        // (MỚI v54) Bắt sự kiện Enter trong ô tìm kiếm

        document.getElementById('termid-search-input').addEventListener('keydown', (e) => {

            if (e.key === 'Enter') {

                e.preventDefault(); // Ngăn chặn form submit

                searchByTermId();

            }

        });

        // (*** MỚI v50 ***) Hàm đóng Bảng Xếp Hạng (gọi từ nút X)

        function closeRankPanel() {

            const panel = document.getElementById('rank-table-container');

            const button = document.getElementById('rank-toggle-btn');

            if (panel) panel.style.display = 'none';
            // Cũng cập nhật style của nút 🏆 trong menu ☰

            if (button) {

                button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt

            }

        }

    </script>

</body>

</html>