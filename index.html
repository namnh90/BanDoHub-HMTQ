<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BAN DO HUB - HMTQ</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>

<style>
    /* KHỐI STYLE CỦA BẠN (SỬA ĐỔI RẤT ÍT) */
    html, body, #map {
        height: 100vh;
        width: 100vw;
        margin: 0;
        padding: 0;
        font-family: 'Times New Roman', Times, serif;
        overflow: hidden;
    }
    
    .leaflet-tile-pane {
         filter: grayscale(1) contrast(1.1) brightness(0.95); 
    }
    /* (MỚI v40) CSS cho Lớp Viền (Pane) */
    .leaflet-border-pane {
        pointer-events: none; /* Không bắt click chuột */
    }
    /* Bảng xếp hạng */
    #rank-table-container {
        position: absolute;
        top: 60px;
        left: 10px;
        width: 280px; 
        max-height: calc(100vh - 80px); 
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 2001;
        font-size: 14px;
        display: none; 
    }
    #rank-table-header {
        padding: 8px 12px;
        font-weight: bold;
        font-size: 16px;
        border-bottom: 1px solid #ddd;
        background-color: #f9f9f9;
        border-radius: 8px 8px 0 0;
    }
    #rank-table-body {
        overflow-y: auto;
        max-height: calc(100vh - 130px);
    }
    .rank-item {
        padding: 8px 12px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .rank-item:hover {
        background-color: #f0f8ff;
    }
    .rank-item-move {
        background-color: #fffbeb; /* Vàng nhạt */
    }
    .rank-item button {
        width: 100%;
        padding: 4px 8px;
        font-size: 12px;
        font-weight: 600;
        color: white;
        border: none;
        border-radius: 4px;
        margin-top: 6px;
        cursor: pointer;
    }
    
    /* CSS cho các nút trong 1 hàng (cho chức năng Move) */
    .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        margin-top: 6px;
    }
    .button-group button {
        width: auto;
        flex-grow: 1;
        background: #d97706; /* Cam */
    }
    .button-group button:hover {
        background: #b45309;
    }

    .rank-item-new button { background: #2563eb; } /* Xanh dương */
    .rank-item-new button:hover { background: #1d4ed8; }


    /* Icon cho điểm TÂM (dùng ngôi sao) */
    .center-point-icon {
        width: 24px !important;
        height: 24px !important;
        border-radius: 50%;
        border: 3px solid white;
        box-shadow: 0 2px 6px rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: white;
        animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(255,255,255, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(255,255,255, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255,255,255, 0); }
    }


    
    /* (MỚI v39) CSS cho Icon Pin (Battery) và Nhãn Tiền */
    .battery-icon-div-wrapper { /* Div ngoài cùng của L.divIcon */
        display: flex;
        align-items: center;
        /* Căn giữa div này so với tọa độ lat/lng */
        position: absolute;
        left: 50%;
        top: 50%;
         /* Dịch chuyển [-(width_pin/2 + đầu pin/2), -(height_pin/2)] */
        transform: translate(-23px, -11px);
    }
    .battery-icon-container {
        width: 40px; /* (SỬA v39) To hơn */
        height: 20px; /* (SỬA v39) To hơn */
        border: 2px solid #555;
        border-radius: 4px; 
        background-color: #f0f0f0;
        position: relative; 
        display: flex;
        align-items: center;
        box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        flex-shrink: 0;
    }
    .battery-icon-container::after {
        content: '';
        position: absolute;
        right: -6px; 
        top: 4px; 
        width: 4px; 
        height: 10px; 
        background-color: #555;
        border-radius: 0 2px 2px 0;
    }
    .battery-fill {
        height: 100%;
        border-radius: 1px 0 0 1px;
        transition: width 0.3s ease;
        position: absolute;
        left: 0;
        top: 0;
    }
    .battery-overflow {
        height: 100%;
        border-radius: 1px 0 0 1px;
        transition: width 0.3s ease;
        position: absolute;
        left: 0;
        top: 0;
        z-index: 10; 
    }
    .battery-text {
        width: 100%;
        text-align: center;
        font-size: 11px; 
        font-weight: bold;
        color: black;
        z-index: 20; 
        text-shadow: 0 0 2px white, 0 0 2px white; 
        position: relative; 
    }
    /* (SỬA v39) Nhãn tiền có viền */
    .battery-amount-label { 
        margin-left: 8px; /* Khoảng cách từ đầu pin */
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #333;
        border-radius: 3px;
        padding: 1px 4px;
        font-size: 11px;
        font-weight: bold;
        color: black;
        white-space: nowrap;
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    
    /* CSS cho điểm "phình to, nhấp nháy" khi hover MOVE */
    .point-move-preview {
        transform: scale(1.5); 
        animation: blink-animation 0.7s infinite alternate;
        z-index: 1001 !important; 
    }
    @keyframes blink-animation {
        from { opacity: 1.0; transform: scale(1.5); }
        to { opacity: 0.6; transform: scale(1.4); }
    }
    
    /* CSS cho Bảng Rank nhấp nháy */
    .rank-item-highlight {
        animation: highlight-green 1.2s ease-in-out infinite alternate;
    }
    @keyframes highlight-green {
        from { 
            background-color: #f0f8ff; 
        }
        to { 
            background-color: #d1fae5; 
            border-left: 4px solid #10b981; 
            margin-left: -4px; 
        }
    }

    /* CSS cho Popup Hành Động */
    .action-popup .leaflet-popup-content-wrapper {
        border-radius: 8px;
        padding: 0;
        background: rgba(255, 255, 255, 0.95);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .action-popup .leaflet-popup-content {
        margin: 0;
        padding: 10px;
        width: 220px !important;
        font-size: 14px;
    }
    .action-popup-header {
        font-weight: bold;
        font-size: 16px;
        border-bottom: 1px solid #ddd;
        padding-bottom: 8px;
        margin-bottom: 8px;
    }
    .action-popup-buttons {
        display: flex;
        flex-direction: column;
        gap: 6px;
        max-height: 150px;
        overflow-y: auto;
    }
    .action-popup-buttons button {
        padding: 5px 10px;
        font-size: 13px;
        font-weight: 600;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .btn-new { background: #2563eb; } 
    .btn-new:hover { background: #1d4ed8; }
    .btn-add { background: #059669; } 
    .btn-add:hover { background: #047857; }
    .btn-move { background: #d97706; } 
    .btn-move:hover { background: #b45309; }
    .action-popup-info {
        font-style: italic;
        color: #555;
    }
    /* (MỚI v39) Style cho popup info pin */
    .battery-info-popup {
        font-style: normal !important;
        color: #333 !important;
        font-size: 13px; /* To hơn một chút */
    }
    .battery-info-popup b {
        display: inline-block;
        width: 70px; /* Căn lề cho đẹp */
        color: #555;
    }


    /* Tooltip khoảng cách */
    .distance-tooltip {
        background-color: rgba(255, 255, 255, 0.95) !important;
        border: 1.5px solid;
        color: #333 !important;
        font-weight: bold;
        font-size: 12px;
        font-family: 'Times New Roman', Times, serif;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2) !important;
        padding: 3px 6px !important;
        border-radius: 4px;
        cursor: pointer; 
    }
    .distance-tooltip .group-name {
        font-size: 10px;
        opacity: 0.8;
        display: block;
        text-align: center;
        border-bottom: 1px dashed #ccc;
        margin-bottom: 2px;
    }
    .distance-tooltip .loading-spinner {
        font-size: 10px;
        color: #999;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-left: 4px;
    }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* (ĐÃ SỬA) Ẩn chỉ dẫn của Leaflet Routing Machine MẶC ĐỊNH */
    .leaflet-routing-container { display: none; }

    /* (SỬA v38) Bỏ width: 110px, đổi sang 100% */
    .leaflet-bar button, .leaflet-bar button:hover {
        width: 100% !important; /*(SỬA)*/
        height: 32px !important; 
        font-size: 13px !important;
        font-weight: 600 !important; 
        display: flex; 
        align-items: center; 
        justify-content: center;
        gap: 6px; 
        background-color: white !important; 
        color: #1f2937 !important;
        margin-bottom: 6px; /*(MỚI v38)*/
    }
    .leaflet-bar button:hover { background-color: #f3f4f6 !important; }
    
    /* (MỚI v38) CSS cho Bảng Điều Khiển Mới */
    .custom-controls-container {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        border: 1px solid #ccc;
        padding: 8px;
        width: 150px; /* Chiều rộng cố định cho panel */
    }
    .custom-controls-container .leaflet-bar-part {
        border: none !important;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .custom-controls-container .leaflet-bar-part:last-child {
        margin-bottom: 0;
    }
    
    
    /* Nút Routing */
    #routing-toggle-btn.bird-mode { background-color: #fffbeb !important; color: #d97706 !important; }
    #routing-toggle-btn.car-mode { background-color: #3b82f6 !important; color: white !important; }
    
    /* Nút Pin */
    #battery-toggle-btn.pin-mode { background-color: #ecfdf5 !important; color: #059669 !important; }
    #battery-toggle-btn.battery-mode { background-color: #16a34a !important; color: white !important; }

    /* Nút Filter */
    #filter-toggle-btn { background-color: #6b7280 !important; color: white !important; }
    #filter-toggle-btn:hover { background-color: #4b5563 !important; }

    /* (MỚI v42) CSS cho Nút Bật/Tắt Gom Cụm */
    #cluster-toggle-btn.cluster-on { background-color: #8b5cf6 !important; color: white !important; }
    #cluster-toggle-btn.cluster-off { background-color: #f3f4f6 !important; color: #4b5563 !important; }
    #cluster-toggle-btn.cluster-off:hover { background-color: #e5e7eb !important; }
    /* (MỚI v43) CSS cho Nút Bật/Tắt Nhãn KM */
    #labels-toggle-btn.labels-on { background-color: #f59e0b !important; color: white !important; }
    #labels-toggle-btn.labels-off { background-color: #f3f4f6 !important; color: #4b5563 !important; }
    #labels-toggle-btn.labels-off:hover { background-color: #e5e7eb !important; }
    /* (*** MỚI v45 ***) CSS cho Nút Bật/Tắt NHNN */
    #nhnn-toggle-btn.nhnn-on { background-color: #059669 !important; color: white !important; } /* Màu xanh lá cây */
    #nhnn-toggle-btn.nhnn-off { background-color: #f3f4f6 !important; color: #4b5563 !important; }
    #nhnn-toggle-btn.nhnn-off:hover { background-color: #e5e7eb !important; }
    /* Toastify */
    .custom-toast { font-family: 'Times New Roman', Times, serif !important; font-size: 14px !important; font-weight: 600 !important; border-radius: 8px !important; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15) !important; }
    .custom-toast.success { background: linear-gradient(135deg, #10b981, #059669) !important; }
    .custom-toast.info { background: linear-gradient(135deg, #3b82f6, #2563eb) !important; }
    .custom-toast.warning { background: linear-gradient(135deg, #f59e0b, #d97706) !important; }
    .custom-toast.error { background: linear-gradient(135deg, #ef4444, #dc2626) !important; }

    
    /* CSS CHO ROUTING ĐỘNG */
    @keyframes route-flow {
        to {
            stroke-dashoffset: -20;
        }
    }
    .animated-route-line {
        animation: route-flow 1s linear infinite;
    }

    /* === CSS CHO BẢNG ĐIỀU KHIỂN BỘ LỌC (SỬA VỊ TRÍ) === */
    #filter-controls-container {
        position: absolute;
        top: 10px; /* Đẩy lên trên cùng */
        /* (SỬA v55) Vị trí mặc định lùi khỏi Search Bar */
        right: 320px; 
        width: 250px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1003; /* Nổi lên trên Search (1001) */
        font-size: 13px;
        padding: 10px 15px;
        font-family: 'Times New Roman', Times, serif;
        display: none; 
        
        max-height: calc(100vh - 20px); 
        overflow-y: auto;
        transition: right 0.3s ease; /* Thêm transition */
    }
    #filter-controls-header {
        font-size: 16px;
        font-weight: bold;
        border-bottom: 1px solid #ddd;
        padding-bottom: 8px;
        margin-bottom: 10px;
        /* (MỚI) Căn chỉnh tiêu đề và nút đóng */
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    /* (MỚI) CSS cho nút đóng 'X' */
    #close-filter-btn {
        font-size: 24px;
        font-weight: bold;
        color: #777;
        cursor: pointer;
        line-height: 1;
        padding: 0 5px;
    }
    #close-filter-btn:hover {
        color: #000;
    }
    .filter-control {
        margin-bottom: 8px;
    }
    .filter-control label {
        display: block;
        margin-bottom: 4px;
        font-weight: 600;
        color: #333;
    }
    .filter-control input[type="range"] {
        width: 100%;
        cursor: pointer;
    }
    
    /* (MỚI v35) CSS cho dropdown filter */
    .filter-control select {
        width: 100%;
        padding: 5px 8px;
        font-size: 13px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-family: 'Times New Roman', Times, serif;
        background-color: white;
    }
    
    /* (MỚI v35) CSS cho nút Reset Filter */
    #reset-cascading-filter-btn {
        width: 100%;
        padding: 5px 8px;
        font-size: 13px;
        font-weight: 600;
        color: white;
        background-color: #dc2626; /* Màu đỏ */
        border: none;
        border-radius: 4px;
        margin-top: 10px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    #reset-cascading-filter-btn:hover {
        background-color: #b91c1c;
    }
/* === (MỚI v41.1) CSS CHO ICON GOM CỤM TÙY CHỈNH === */
    .my-cluster-icon {
        /* (Bạn có thể thay màu nền tại đây) */
        background-color: rgba(245, 130, 49, 0.8); /* Màu cam */
        border: 2px solid rgba(245, 130, 49, 1);
        border-radius: 50%; /* Bo tròn */
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        
        /* Dùng flex để căn giữa số đếm */
        display: flex;
        align-items: center;
        justify-content: center;
        
        text-align: center;
        color: white;
        font-weight: bold;
        font-size: 14px;
        font-family: Arial, sans-serif;
        
        /* Dịch chuyển icon một chút để nó căn đúng vào tâm */
        margin-left: -20px;
        margin-top: -20px;
    }
    
    /* CSS cho số đếm bên trong */
    .my-cluster-icon span {
        /* Không cần thiết lắm vì đã dùng flex, nhưng để cho chắc */
        line-height: 1; 
    }

    /* Định nghĩa kích thước dựa trên "cấp độ" */
    .my-cluster-icon.small {
        width: 30px;
        height: 30px;
        margin-left: -15px;
        margin-top: -15px;
        font-size: 13px;
    }
    .my-cluster-icon.medium {
        width: 40px;
        height: 40px;
        margin-left: -20px;
        margin-top: -20px;
        font-size: 14px;
    }
    .my-cluster-icon.large {
        width: 50px;
        height: 50px;
        margin-left: -25px;
        margin-top: -25px;
        font-size: 16px;
    }
/* (*** MỚI v49 ***) CSS cho Nút Toggle Panel Chính (Nút Hamburger) */
    #panel-toggle-btn {
        width: 100%;
        height: 100%;
        font-size: 18px !important;
        background-color: #059669 !important; /* (SỬA v49) MÀU XANH LÁ */
        color: white !important; 
        border-radius: 8px; /* Khớp với container */
        border: none !important;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    #panel-toggle-btn:hover {
        background-color: #047857 !important; /* (SỬA v49) Xanh đậm hơn */
    }

    /* (*** MỚI v49 ***) CSS cho Nút Thu Gọn (Collapse) */
    #panel-collapse-btn { 
        background-color: #6b7280 !important; 
        color: white !important; 
        /* (SỬA v49) Căn giữa icon (vì không còn chữ) */
        justify-content: center !important; 
        padding-left: 0 !important;
    }
    #panel-collapse-btn:hover { background-color: #4b5563 !important; }


    /* (*** MỚI v47 ***) CSS Ẩn/Hiện Wrapper chứa các nút */
    .buttons-wrapper {
        display: block; /* Hiển thị mặc định (cho desktop) */
    }
    
    /* === (SỬA v55) CSS MỚI CHO BỐ CỤC CHUNG === */
    
    /* 1. Panel Bảng Xếp Hạng: LUÔN Ở BÊN TRÁI */
    /* (Vị trí gốc được giữ nguyên) */


    /* 2. Panel Filter: (SỬA v55) LUÔN Ở BÊN PHẢI */
    #filter-controls-container {
        /* Vị trí mặc định lùi khỏi Search Bar */
        right: 10px; 
        left: auto; 
        z-index: 2000; 
    }

    
    /* 3. Panel Nút Bấm: LUÔN ở góc TRÊN bên phải */
    .leaflet-top.leaflet-right {
        top: 360px;
        bottom: auto; 
        right: 0px;
        /* (*** SỬA LỖI v55 ***) Đảm bảo Menu ☰ nổi lên trên Search và Filter */
        z-index: 1005; 
    }
    
    /* 4. Panel chính (custom-controls-container) LUÔN là nút ☰ */
    .custom-controls-container {
        width: 40px; /* Kích thước nút toggle */
        height: 40px;
        padding: 0; /* Xóa padding */
        overflow: hidden; /* Ẩn các nút con */
        background: transparent; /* Tắt nền trắng của panel */
        border: none; /* Tắt viền của panel */
        box-shadow: none; /* Tắt bóng của panel */
        transition: width 0.3s ease; /* Thêm transition */
    }

    /* 5. Panel chính khi được BẬT (expanded) */
    .custom-controls-container.expanded {
        width: 180px; /* DÀI RA CHÚT (từ 150px) */
        height: auto;
        padding: 8px; /* Thêm lại padding */
        background: rgba(255, 255, 255, 0.9); /* Thêm lại nền */
        border: 1px solid #ccc; /* Thêm lại viền */
        box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* Thêm lại bóng */
    }
    
    /* 6. Ẩn wrapper nút con MẶC ĐỊNH */
    .buttons-wrapper {
        display: none; 
    }
    
    /* 7. Hiển thị wrapper khi panel được BẬT */
    .custom-controls-container.expanded .buttons-wrapper {
        display: block;
    }

    /* 8. Ẩn nút toggle (hamburger) khi panel được BẬT */
    .custom-controls-container.expanded #panel-toggle-btn {
        display: none;
    }

    /* 9. Hiển thị nút toggle (hamburger) MẶC ĐỊNH */
    #panel-toggle-btn {
        display: flex; /* Hiển thị nút hamburger */
    }
    
    /* 10. Ẩn chữ (span) mặc định (khi co lại) */
    .custom-controls-container .button-text {
        display: none; 
    }

    /* 11. Hiển thị chữ khi panel bung ra */
    .custom-controls-container.expanded .button-text {
        display: inline; /* Hiện lại chữ */
    }
    
    /* 12. Các nút con bên trong khi bung ra */
    .custom-controls-container.expanded .leaflet-bar-part {
        width: 100% !important; /* Các nút con 100% width */
        height: 40px !important;
        font-size: 16px !important;
        /* (MỚI v49) Căn lề chữ cho đẹp (hết díu) */
        justify-content: flex-start !important; 
        padding-left: 10px !important;
    }
    
    /* 13. Nút hamburger (khi chưa bung) */
    #panel-toggle-btn.leaflet-bar-part {
        width: 40px !important;
        height: 40px !important;
        font-size: 16px !important;
        /* (MỚI v49) Ghi đè: Giữ nút ☰ ở giữa */
        justify-content: center !important;
        padding-left: 0 !important;
    }

    /* 14. (Ghi đè Desktop) Áp dụng luật mobile cho desktop */
    @media (min-width: 769px) {
        #panel-toggle-btn {
            display: flex; /* Vẫn hiển thị nút ☰ */
        }
        .buttons-wrapper {
            display: none; /* Vẫn ẩn wrapper */
        }
        /* Sửa lại panel Filter trên desktop */
         #filter-controls-container {
            width: 250px; /* Trả về độ rộng cũ */
            right: 320px; /* Giữ nguyên vị trí lùi khỏi Search */
            left: auto;
        }
    }
    #close-filter-btn:hover {
        color: #000;
    }

    /* (*** MỚI v50 ***) CSS cho nút đóng Bảng Xếp Hạng */
    #close-rank-btn {
        font-size: 24px;
        font-weight: bold;
        color: #777;
        cursor: pointer;
        line-height: 1;
        padding: 0 5px;
        float: right; /* Căn sang phải */
    }
    #close-rank-btn:hover {
        color: #000;
    }
    
    /* (SỬA v50) Sửa Header của Bảng Xếp Hạng để chứa nút X */
      #rank-table-header {
        display: block; /* Đảm bảo nút X (dùng float) hoạt động */
      }


    /* === SỬA ĐỔI VỊ TRÍ VÀ HIỂN THỊ CỦA THANH TÌM KIẾM (SỬA LỖI v55) === */
    #search-control-container {
        position: absolute;
        top: 10px;
        /* (SỬA LỖI v55) Mặc định lùi sang trái Menu ☰ */
        right: 10px; /* 10px (margin menu) + 40px (menu rộng) + 10px (gap) = 60px */
        width: 250px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1999; /* (SỬA LỖI v55) Nổi lên trên Menu ☰ (1005) và Filter (1003) */
        padding: 8px;
        flex-direction: column;
        height: auto;
        transition: right 0.3s ease; /* Thêm transition để di chuyển mượt mà */
    }

    /* (MỚI v54) Vùng chứa Input & Button */
    .search-input-group {
        display: flex;
        gap: 5px;
    }
    #search-control-container input {
        flex-grow: 1;
        padding: 6px 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        font-family: 'Times New Roman', Times, serif;
        outline: none;
    }
    #search-control-container button {
        padding: 6px 10px;
        background-color: #3b82f6;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    #search-control-container button:hover {
        background-color: #2563eb;
    }


    /* === KHẮC PHỤC TRÙNG LẤN VỚI MENU MỞ RỘNG (EXPANDED) === */
    
    /* (SỬA LỖI v55) Đẩy Thanh Tìm Kiếm ra khi Menu ☰ mở rộng */
    .custom-controls-container.expanded + #search-control-container { 
        /* Menu rộng 180px, để gap 10px */
        right: 190px; 
    }

    /* (SỬA LỖI v55) Đẩy Panel Filter ra khi Menu ☰ mở rộng */
    .custom-controls-container.expanded + #search-control-container + #filter-controls-container {
        /* 190px (right Search) + 250px (Search width) + 10px (gap) = 450px */
        right: 10px; 
    }

    /* (Mặc định: Menu ☰ KHÔNG MỞ RỘNG) - Đảm bảo Filter lùi khỏi Search bar */
    #search-control-container + #filter-controls-container {
        right: 10px; /* 60px (right Search) + 250px (Search width) + 10px (gap) = 320px */
    }

    /* === STYLE CHO PHẦN KẾT QUẢ/GỢI Ý TÌM KIẾM (MỚI v54) === */
    #search-results-container {
        max-height: 200px;
        overflow-y: auto;
        border-top: 1px solid #eee;
        margin-top: 8px;
        padding-top: 5px;
        display: none; /* Mặc định ẩn */
    }
    /* === (MỚI v57) CSS cho Tooltip Tùy Chỉnh === */

.search-result-item {
    position: relative; /* Quan trọng: Để tooltip căn theo vị trí này */
    /* ... các thuộc tính cũ ... */
}

/* Ẩn tooltip mặc định của trình duyệt */
.search-result-item[title]:hover {
    pointer-events: none; /* Ngăn chặn Tooltip mặc định */
}

.search-result-item::before,
.search-result-item::after {
    --arrow-size: 6px; /* Kích thước mũi tên */
    position: absolute;
    display: none; /* Mặc định ẩn */
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
    z-index: 2001; /* Đảm bảo nổi lên trên mọi thứ */
}

/* Tooltip: Dùng ::after */
.search-result-item::after {
    content: attr(data-title); /* Lấy nội dung từ thuộc tính data-title */
    top: calc(100% + var(--arrow-size) + 5px); /* Vị trí bên dưới item + khoảng cách mũi tên */
    left: 50%;
    transform: translateX(-50%);
    
    padding: 6px 10px;
    min-width: 150px;
    max-width: 250px;
    
    background-color: #333; /* Màu nền đen */
    color: white;
    border-radius: 4px;
    text-align: center;
    font-size: 13px;
    line-height: 1.4;
    white-space: normal; /* Cho phép chữ xuống dòng */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

/* Mũi tên: Dùng ::before */
.search-result-item::before {
    content: '';
    top: calc(100% + 5px); /* Vị trí của mũi tên */
    left: 50%;
    transform: translateX(-50%) rotate(45deg);
    
    width: var(--arrow-size);
    height: var(--arrow-size);
    background-color: #333; /* Màu nền đen */
    border-radius: 2px;
}

/* HIỂN THỊ khi HOVER */
.search-result-item:hover::before,
.search-result-item:hover::after {
    display: block;
    opacity: 1;
}

/* --- STYLE BỔ SUNG CHO MEASURE SEARCH --- */
.search-results-container {
    max-height: 150px;
    overflow-y: auto;
    border-top: 1px solid #eee;
    background-color: white;
    z-index: 1000;
    position: relative; 
    border: 1px solid #ddd;
    border-top: none;
    border-radius: 0 0 4px 4px;
}
.search-input-group input {
    border-radius: 4px; /* Reset Tailwind's default */
}
.search-input-group button {
    padding: 6px 10px;
    background-color: #6b7280; /* Màu xám đậm */
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.15s ease-in-out;
}
.search-input-group button:hover {
    background-color: #4b5563; /* Màu xám tối hơn khi hover */
}
.search-result-item {
    padding: 8px 10px;
    cursor: pointer;
    border-bottom: 1px solid #eee;
    font-size: 0.9rem;
}
.search-result-item:hover {
    background-color: #f0f0f0;
}
</style>    
</head>
<body>

<div id="map"></div>
<div id="rank-table-container">
    <div id="rank-table-header">
        Bảng Xếp Hạng Lựa Chọn
        <span id="close-rank-btn" 
              onclick="event.stopPropagation(); closeRankPanel();"
        >&times;</span>
    </div>
    <div id="rank-table-body">
    </div>
</div>
<div id="search-control-container">
    <div class="search-input-group">
        <input type="text" id="termid-search-input" placeholder="Tìm theo Mã CN hoặc Tên HUB...">
        <button id="search-button" onclick="searchByTermId()">
            <i class="fa-solid fa-magnifying-glass"></i>
        </button>
    </div>
    <div id="search-results-container">
    </div>
    
    <hr class="my-3 border-t border-gray-300">
    
    <div id="measurement-log" style="font-size: 14px; font-weight: bold; padding: 5px 0; min-height: 20px; color: #333; border-bottom: 1px solid #ddd; margin-bottom: 10px; display: none;">
        </div>
    <div id="search-a-container">
        <label for="search-a-input" style="font-weight: bold; margin-bottom: 5px; display: block;">Điểm Bắt đầu (A):</label>
        <div class="search-input-group">
            <input type="text" id="search-a-input" placeholder="Mã CN/Tên HUB (Start)">
            <button onclick="searchMeasurePoint('A')">
                <i class="fa-solid fa-magnifying-glass"></i>
            </button>
        </div>
        <div id="search-a-results" class="search-results-container"></div>
    </div>
    
    <div id="search-b-container" style="margin-top: 10px;">
        <label for="search-b-input" style="font-weight: bold; margin-bottom: 5px; display: block;">Điểm Kết thúc (B):</label>
        <div class="search-input-group">
            <input type="text" id="search-b-input" placeholder="Mã CN/Tên HUB (End)">
            <button onclick="searchMeasurePoint('B')">
                <i class="fa-solid fa-magnifying-glass"></i>
            </button>
        </div>
        <div id="search-b-results" class="search-results-container"></div>
    </div>
    
    <div class="flex space-x-2 mt-4">
        <button id="measure-route-btn" 
                onclick="measureRouteBetweenAandB()" 
                class="flex-1 px-3 py-2 bg-yellow-600 hover:bg-yellow-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out">
            <i class="fa-solid fa-route mr-1"></i> Đo Lái Xe
        </button>
        <button id="measure-straight-btn" 
                onclick="measureStraightLineBetweenAandB()" 
                class="flex-1 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out">
            <i class="fa-solid fa-ruler mr-1"></i> Đường Chim Bay
        </button>
        <button id="clear-measure-btn" 
                onclick="clearMeasurement()" 
                class="flex-1 px-3 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md text-sm font-semibold transition duration-150 ease-in-out">
            <i class="fa-solid fa-trash mr-1"></i> Xóa Đo
        </button>
    </div>
    
</div>

<div id="filter-controls-container">
    <div id="filter-controls-header">
        Tùy Chỉnh Bản Đồ
        <span id="close-filter-btn" 
              onclick="event.stopPropagation(); toggleFilterControls();"
        >&times;</span>
    </div>
    <div class="filter-control">
        <label for="grayscale-slider">Độ xám: 1.0</label>
        <input type="range" id="grayscale-slider" min="0" max="1" step="0.1" value="1">
    </div>
    <div class="filter-control">
        <label for="brightness-slider">Độ sáng: 0.95</label>
        <input type="range" id="brightness-slider" min="0.5" max="1.5" step="0.05" value="0.95">
    </div>
    <div class="filter-control">
        <label for="contrast-slider">Tương phản: 1.1</label>
        <input type="range" id="contrast-slider" min="0.5" max="2" step="0.1" value="1.1">
    </div>
    
    <div class="filter-control">
        <label for="blur-slider">Độ nhòe (Blur): 0 px</label>
        <input type="range" id="blur-slider" min="0" max="10" step="0.5" value="0">
    </div>
    
    <div id="cascading-filter-container">
        </div>
    
</div>


<script>
// (*** MỚI: HÀM CẬP NHẬT LOG KẾT QUẢ ĐO LƯỜNG CỐ ĐỊNH ***)
function updateMeasurementLog(message, type) {
    const logDiv = document.getElementById('measurement-log');
    if (!logDiv) return;

    // Định dạng màu sắc và icon
    let color = '#333';
    let icon = '';
    
    if (type === 'route') {
        color = '#d97706'; // Cam (Lái xe)
        icon = '<i class="fa-solid fa-car mr-1"></i>';
    } else if (type === 'straight') {
        color = '#1d4ed8'; // Xanh dương (Chim bay)
        icon = '<i class="fa-solid fa-feather-alt mr-1"></i>';
    } else {
        logDiv.style.display = 'none'; // Ẩn nếu không có dữ liệu
        return;
    }

    logDiv.style.display = 'block';
    logDiv.style.color = color;
    logDiv.innerHTML = `${icon} ${message}`;
}
// (*** HÀM CHỈ XÓA GIAO DIỆN CŨ ***)
// Cần định nghĩa lại hàm này nếu bạn chưa có, hoặc đảm bảo nó nằm ngoài clearMeasurement()
/**
 * Hàm chỉ xóa các đường vẽ và marker trên map (GIỮ LẠI DỮ LIỆU selectedPointA/B).
 */
function clearMapVisuals() {
    // 1. Xóa routing machine nếu có
    if (currentRoutingControl) {
        try {
            map.removeControl(currentRoutingControl);
        } catch (e) {}
        currentRoutingControl = null;
    }
    // 2. Xóa đường chim bay nếu có
    if (currentStraightLine) {
        measureLayer.removeLayer(currentStraightLine);
        currentStraightLine = null;
    }
    // 3. Xóa các marker tự tạo bởi routing machine (nếu có)
    measureLayer.clearLayers(); 
}
// (*** HÀM GỐC XÓA TẤT CẢ - CHO NÚT "XÓA ĐO" ***)
// Sửa đổi: Thêm logic xóa log cố định
function clearMeasurement() {
    // 1. Xóa giao diện khỏi Map
    clearMapVisuals();

    // 2. Xóa dữ liệu điểm và input
    document.getElementById('search-a-input').value = '';
    document.getElementById('search-b-input').value = '';
    document.getElementById('search-a-results').style.display = 'none';
    document.getElementById('search-b-results').style.display = 'none';
    selectedPointA = null;
    selectedPointB = null;

    // 3. Xóa log cố định
    updateMeasurementLog('', 'clear'); 

    showToast("Đã xóa tất cả các đường đo.", "info");
}
// (*** HÀM ĐO ĐƯỜNG CHIM BAY - ĐÃ SỬA LỖI midPoint ***)
function measureStraightLineBetweenAandB(isFallback = false) {
    // [ĐÃ SỬA] Chỉ xóa giao diện cũ (nhưng giữ lại selectedPointA/B)
    clearMapVisuals(); 
    
    if (!selectedPointA || !selectedPointB) {
        showToast("Vui lòng chọn cả Điểm Bắt đầu (A) và Điểm Kết thúc (B).", "warning");
        return;
    }
    
    if (selectedPointA.id === selectedPointB.id) {
        showToast("Hai điểm A và B phải khác nhau.", "warning");
        return;
    }
    
    if (isBatteryView) {
        toggleBatteryView();
    }
    
    // 1. Vẽ đường chim bay
    currentStraightLine = L.polyline([selectedPointA.latlng, selectedPointB.latlng], {
        color: '#1a73e8', // Màu xanh dương
        weight: 5, 
        opacity: 0.7, 
        dashArray: '10, 5' // Đường nét đứt
    }).addTo(measureLayer);

    // 2. Tính khoảng cách
    const distanceMeters = selectedPointA.latlng.distanceTo(selectedPointB.latlng);
    const distanceKm = (distanceMeters / 1000).toFixed(2);

    showToast(`${isFallback ? 'Đường chim bay (Lỗi Routing):' : 'Đo Đường Chim Bay:'} ${distanceKm} km.`, isFallback ? 'warning' : 'success');
    
    // 3. Focus vào điểm A và B
    // (*** SỬA LỖI midPoint ***)
    const midLat = (selectedPointA.latlng.lat + selectedPointB.latlng.lat) / 2;
    const midLng = (selectedPointA.latlng.lng + selectedPointB.latlng.lng) / 2;
    const centerLatLng = L.latLng(midLat, midLng);

    map.panTo(centerLatLng);
    // (*** KẾT THÚC SỬA LỖI ***)

    // Cập nhật log
    updateMeasurementLog(`Kết quả Đường Chim Bay: ${distanceKm} km`, 'straight');
}
// (*** HÀM TÌM KIẾM CHO SEARCH A/B ***)
function searchMeasurePoint(searchId) {
    const inputId = `search-${searchId.toLowerCase()}-input`;
    const resultsId = `search-${searchId.toLowerCase()}-results`;
    const input = document.getElementById(inputId);
    const resultsContainer = document.getElementById(resultsId);
    const searchTerm = String(input.value).trim().toUpperCase();

    resultsContainer.innerHTML = '';

    if (!searchTerm) {
        resultsContainer.style.display = 'none';
        return;
    }

    const searchResults = allPoints.filter(p => 
        !p.nhnn && (
            String(p.id).toUpperCase().includes(searchTerm) || 
            (p.tenHub && String(p.tenHub).toUpperCase().includes(searchTerm))
        )
    );

    if (searchResults.length > 0) {
        resultsContainer.style.display = 'block';
        
        searchResults.slice(0, 5).forEach(point => {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            
            let content = `ID: ${point.id}`;
            if (point.tenHub) {
                content += `<span class="hub-name"> (${point.tenHub})</span>`;
            }
            
            item.innerHTML = content;
            item.dataset.pointId = point.id;

            item.addEventListener('click', () => {
                selectMeasurePoint(searchId, point);
                resultsContainer.style.display = 'none';
            });

            resultsContainer.appendChild(item);
        });
    } else {
        resultsContainer.style.display = 'none';
    }
}

// (*** HÀM GÁN ĐIỂM ĐƯỢC CHỌN CHO A HOẶC B - ĐÃ SỬA LỖI ZOOM ***)
function selectMeasurePoint(searchId, pointData) {
    const input = document.getElementById(`search-${searchId.toLowerCase()}-input`);
    const resultsContainer = document.getElementById(`search-${searchId.toLowerCase()}-results`);
    
    if (searchId === 'A') {
        selectedPointA = pointData;
    } else {
        selectedPointB = pointData;
    }
    
    input.value = `${pointData.id} (${pointData.tenHub || 'PGD'})`;
    resultsContainer.style.display = 'none'; // Ẩn kết quả sau khi chọn
    
    // Focus vào điểm ngay khi chọn
    if (pointData && pointData.latlng) {
        // [ĐÃ SỬA] Sử dụng panTo và setZoom để không zoom quá đột ngột, giữ zoom hiện tại hoặc zoom lên 15.
        const currentZoom = map.getZoom();
        map.panTo(pointData.latlng);
        map.setZoom(Math.max(currentZoom, 15));
    }
    
    showToast(`Đã chọn Điểm ${searchId}: ${pointData.id}`, 'info');
}

// (*** HÀM CHÍNH ĐO KÍCH THƯỚC LÁI XE - CÓ LOG CỐ ĐỊNH ***)
function measureRouteBetweenAandB() {
    // [ĐÃ SỬA] Chỉ xóa giao diện cũ (nhưng giữ lại selectedPointA/B)
    clearMapVisuals();
    
    if (!selectedPointA || !selectedPointB) {
        showToast("Vui lòng chọn cả Điểm Bắt đầu (A) và Điểm Kết thúc (B).", "warning");
        return;
    }
    
    if (selectedPointA.id === selectedPointB.id) {
        showToast("Hai điểm A và B phải khác nhau.", "warning");
        return;
    }
    
    // 2. Tắt chế độ Pin (nếu đang bật)
    if (isBatteryView) {
        toggleBatteryView();
    }
    
    showToast("Đang tính toán tuyến đường lái xe...", 'info');
    updateMeasurementLog("Đang tính toán tuyến đường...", 'route'); // Cập nhật log tạm thời

    // 3. Khởi tạo Leaflet Routing Machine
    const router = L.Routing.control({
        waypoints: [
            selectedPointA.latlng,
            selectedPointB.latlng
        ],
        router: L.Routing.osrmv1({
            serviceUrl: 'https://router.project-osrm.org/route/v1',
            profile: 'driving'
        }),
        show: true,
        routeWhileDragging: false,
        createMarker: (i, waypoint, n) => {
             const pointData = (i === 0) ? selectedPointA : selectedPointB;
             const icon = isBatteryView ? createBatteryIcon(pointData) : createPGDIcon();
             return L.marker(waypoint.latLng, { 
                 icon: icon,
                 title: (i === 0) ? `Start: ${pointData.id}` : `End: ${pointData.id}`
             });
        },
        lineOptions: {
            styles: [{ color: '#f59e0b', weight: 7, opacity: 0.8 }]
        }
    });

    // 4. Bắt sự kiện tuyến đường tìm thấy
    router.on('routesfound', function(e) {
        const route = e.routes[0];
        const distanceKm = (route.summary.totalDistance / 1000).toFixed(2);
        
        showToast(`Đo kích thước thành công! ${distanceKm} km (Lái xe)`, 'success');
        // (*** LƯU KẾT QUẢ VÀO LOG CỐ ĐỊNH ***)
        updateMeasurementLog(`Kết quả Đo Lái Xe: ${distanceKm} km`, 'route');
        
        router.getContainer().style.display = 'block';
    });
    
    router.on('routingerror', function(e) {
        console.error("Lỗi định tuyến:", e.error);
        showToast(`Lỗi tính toán đường lái xe. Đã vẽ đường chim bay thay thế.`, "error");
        // (*** LƯU KẾT QUẢ VÀO LOG CỐ ĐỊNH ***)
        updateMeasurementLog(`Lỗi Đo Lái Xe. Xem kết quả Đường Chim Bay thay thế.`, 'route');

        // Vẽ đường chim bay để thay thế
        L.polyline([selectedPointA.latlng, selectedPointB.latlng], {
            color: '#f59e0b', 
            opacity: 0.5, 
            weight: 3, 
            dashArray: '5, 5'
        }).addTo(measureLayer);
    });

    currentRoutingControl = router.addTo(map);
    
    const container = router.getContainer();
    if (container) {
        container.style.display = 'block';
        container.style.position = 'absolute';
        container.style.top = '10px';
        container.style.left = '10px';
        container.style.zIndex = '2000'; 
    }
}
    // Hàm giả định để lấy ID duy nhất cho điểm (nếu bạn chưa có)
function getUniquePointId(lat, lon) {
    // Có thể dùng hash hoặc kết hợp Lat/Lon thành chuỗi
    return `P_${Math.round(lat*10000)}_${Math.round(lon*10000)}`;
}

// Hàm giả định để cập nhật hiển thị Marker sau khi nhóm thay đổi
function updateMarkerIcon(marker, groupColor) {
    // TODO: Triển khai logic thay đổi icon Marker (ví dụ: đổi màu icon pin)
    // Hiện tại: Giả định bạn có hàm renderMarkerIcon(level, amount, color)
    // Ví dụ: marker.setIcon(createBatteryIcon(100, 100000, groupColor));
    
    // Đơn giản nhất: Thay đổi màu viền icon nếu bạn dùng L.DivIcon
    const element = marker.getElement();
    if (element) {
        const container = element.querySelector('.battery-icon-container');
        if (container) {
            container.style.borderColor = groupColor;
        }
    }
}
/**
 * Đặt trung tâm bản đồ và zoom đến vị trí của một Marker.
 */
function setMapCenterFromMarker(pointId) {
    const point = allPoints.find(p => String(p.id) === String(pointId));
    
    if (!point || !point.latlng) {
        showToast(`Lỗi: Không tìm thấy điểm ID ${pointId} hoặc không có tọa độ.`, "error");
        console.error("Lỗi setMapCenterFromMarker: Không tìm thấy đối tượng điểm trong allPoints hoặc không có latlng.");
        return;
    }

    // [ĐÃ SỬA] Thay thế map.flyTo(..., 15) bằng map.panTo() để giữ nguyên zoom
    map.panTo(point.latlng);
    
    // (Tùy chọn) Kích hoạt click để mở popup nếu bạn muốn
    if (point.marker) {
        if (currentPopup) {
            map.closePopup(currentPopup);
            currentPopup = null;
        }
        point.marker.fire('click'); 
    }
    
    showToast(`Đã chuyển đến Tâm Điểm: ${pointId}`, 'info');
}
/**
 * (SỬA LỖI UI) Tạo nội dung HTML cho Popup Hành Động (Action Popup).
 * Đã thêm nút "Hủy Nhóm" (chỉ khi điểm là Tâm Nhóm).
 * @param {string} pointId - ID duy nhất của điểm (Marker).
 * @param {string} currentGroupId - ID của nhóm hiện tại mà điểm đang thuộc về (có thể là null).
 */
function createActionPopupContent(pointId, currentGroupId) {
    let content = `
        <div class="action-popup-header">Hành Động cho Điểm ${pointId}</div>
        <div class="action-popup-buttons">
            
            <button class="btn-new" onclick="setMapCenterFromMarker('${pointId}')">
                <i class="fas fa-bullseye"></i> Chọn làm Tâm Bản Đồ
            </button>
            
            <hr style="margin: 5px 0; border-top: 1px solid #ddd;">
            
            <button class="btn-new" onclick="popup_createGroup('${pointId}')" style="margin-bottom: 5px;">
                <i class="fa-solid fa-plus"></i> Tạo Nhóm Mới (làm tâm)
            </button>
            <hr style="margin: 5px 0; border-top: 1px solid #ddd;">
    `;
    
    // --- Lấy thông tin Nhóm hiện tại ---
    let isCenterPoint = false;
    const currentGroup = allGroups.find(g => String(g.id) === String(currentGroupId));
    if (currentGroup && String(currentGroup.centerPoint.id) === String(pointId)) {
        isCenterPoint = true;
    }
    
    // 1. THÊM NÚT HỦY NHÓM (CHỈ CHO ĐIỂM TÂM)
    if (isCenterPoint) {
        content += `
            <button 
                class="btn-delete" 
                style="background-color: #dc2626; margin-bottom: 5px;"
                onclick="popup_deleteGroup('${currentGroupId}')"
            >
                <i class="fa-solid fa-trash-alt"></i> Hủy Nhóm ${currentGroup.groupNumber}
            </button>
            <hr style="margin: 5px 0; border-top: 1px solid #ddd;">
        `;
    }

    // 2. Lấy danh sách các nhóm có thể chuyển đến (trừ nhóm hiện tại)
    const availableGroups = Object.keys(groups).filter(
        groupName => groups[groupName].id !== currentGroupId
    );
    
    // Nút cho phép chuyển điểm sang nhóm khác
    if (availableGroups.length > 0) {
        content += `<div class="action-popup-info" style="margin-top: 5px;">Chọn nhóm để chuyển đến:</div>`;
        
        availableGroups.forEach(groupName => {
            const groupId = groups[groupName].id;
            const groupColor = groups[groupName].color;
            
            // Nút Chuyển Nhóm
            content += `
                <button 
                    class="btn-move" 
                    style="background-color: ${groupColor};"
                    onclick="movePointToGroup('${pointId}', '${groupId}')"
                >
                    <i class="fas fa-layer-group"></i> Chuyển sang ${groupName}
                </button>
            `;
        });
    } else if (currentGroupId) { 
         const currentGroupDisplayName = Object.keys(groups).find(key => groups[key].id === currentGroupId) || currentGroupId;
         content += `<div class="action-popup-info">Đang thuộc **${currentGroupDisplayName}**.</div>`;
    } else {
         content += `<div class="action-popup-info">Chưa có nhóm nào khác để chuyển đến.</div>`;
    }

    content += `</div>`;
    return content;
}

/**
 * (SỬA LỖI CHÍNH) Hàm chuyển một điểm từ nhóm cũ sang nhóm mới (gọi từ Popup).
 * Đã: 1. Đóng Popup sau khi chuyển (Fix Lỗi 3). 2. Đảm bảo loại trừ lẫn nhau (Fix Lỗi 2).
 */
function movePointToGroup(pointId, targetGroupId) {
    // 1. Tìm thông tin nhóm mới
    const newGroupNameKey = Object.keys(groups).find(key => groups[key].id === targetGroupId);
    const newGroup = allGroups.find(g => String(g.id) === String(targetGroupId));
    
    // Tìm điểm cần chuyển
    const pointToMove = allPoints.find(p => String(p.id) === String(pointId));
    
    if (!pointToMove || !newGroup || !newGroupNameKey) {
        showToast("Lỗi: Không tìm thấy điểm hoặc nhóm đích.", "error");
        return;
    }

    const oldGroupId = pointToMove.groupId;
    
    if (oldGroupId === targetGroupId) {
        showToast(`Điểm ${pointId} đã ở trong ${newGroupNameKey}.`, "warning");
        if (currentPopup) map.closePopup(); // Fix Lỗi 3: Đóng popup
        return;
    }

    // === 2. XÓA ĐIỂM KHỎI NHÓM CŨ (MUTUAL EXCLUSION) ===
    if (oldGroupId) {
        const oldGroup = allGroups.find(g => String(g.id) === String(oldGroupId));
        if (oldGroup) {
            // Xóa khỏi danh sách points trong allGroups (dữ liệu map)
            oldGroup.points = oldGroup.points.filter(p => p.id !== pointToMove.id);
        }
        
        // Đồng bộ biến 'groups' (cho UI Popup) - XÓA KHỎI DANH SÁCH ID
        const oldGroupNameKey = Object.keys(groups).find(key => groups[key].id === oldGroupId);
        if (groups[oldGroupNameKey]) {
            groups[oldGroupNameKey].pointIds = groups[oldGroupNameKey].pointIds.filter(id => id !== pointToMove.id);
        }
    }
    // =========================================================

    // 3. Cập nhật ID nhóm mới cho điểm và thêm vào nhóm mới
    pointToMove.groupId = targetGroupId;
    newGroup.points.push(pointToMove);

    // 4. Đồng bộ biến 'groups' (cho UI Popup) - THÊM VÀO DANH SÁCH ID
    if (!groups[newGroupNameKey].pointIds.includes(pointToMove.id)) {
        groups[newGroupNameKey].pointIds.push(pointToMove.id);
    }
    
    // 5. Cập nhật hiển thị và ĐÓNG POPUP (Fix Lỗi 3)
    if (currentPopup) map.closePopup(); 

    drawAllGroups(); 
    updateRankTable();
    updateFilterOptions();

    Toastify({
        text: `Đã chuyển điểm ${pointId} sang ${newGroupNameKey}`,
        className: "custom-toast success",
    }).showToast();
}
/**
 * (MỚI) Tìm và trả về đối tượng Leaflet Marker từ ID điểm
 */
function getMarkerByPointId(pointId) {
    // Trả về Marker từ bản đồ lưu trữ
    return allMarkers[pointId]; 
}
/**
 * Hàm Khởi tạo và Thêm Marker vào Map
 */
function createAndAddMarker(lat, lon, data) {
    // 1. Tạo Marker (Marker KHÔNG CÓ Popup TĨNH lúc này)
    const pointId = data.pointId || getUniquePointId(lat, lon); 
    const marker = L.marker([lat, lon], {
        // ... các tùy chọn icon ...
    });

    marker.pointId = pointId; // Lưu ID vào đối tượng Marker
    marker.data = data; // Lưu dữ liệu gốc

    // 2. GẮN SỰ KIỆN CLICK để mở Popup HÀNH ĐỘNG
    marker.on('click', function(e) {
        
        // --- 2.1. Tìm Nhóm Hiện Tại ---
        let currentGroupId = null;
        for (const name in groups) {
            if (groups[name].pointIds.includes(marker.pointId)) {
                currentGroupId = groups[name].id;
                break;
            }
        }
        
        // --- 2.2. Tạo Nội Dung Popup ĐỘNG ---
        // SỬ DỤNG HÀM MÀ TÔI VỪA CHỈ BẠN
        const content = createActionPopupContent(marker.pointId, currentGroupId);
        
        // --- 2.3. Gán Popup MỚI và Mở ---
        marker.unbindPopup(); // RẤT QUAN TRỌNG: Gỡ bỏ popup cũ
        marker.bindPopup(content, { 
            className: 'action-popup', // Áp dụng CSS Hành Động
            closeButton: true,
            offset: L.point(0, -10)
        }).openPopup();
    });

    // 3. Thêm Marker vào Map
    marker.addTo(map);
    return marker;
}
/** * Ví dụ về cách tạo một mục kết quả tìm kiếm
 * và gán Tooltip tùy chỉnh (dùng thuộc tính data-title)
 */
function createSearchResultItem(fullText, hubName) {
    const item = document.createElement('div');
    item.className = 'search-result-item';

    // *** BƯỚC QUAN TRỌNG: Gán nội dung đầy đủ vào data-title ***
    // Thay item.title = fullText;
    item.setAttribute('data-title', fullText); 
    
    // Phần hiển thị trên bảng kết quả (có thể bị cắt)
    const displayLength = 30;
    const truncatedText = fullText.length > displayLength 
        ? fullText.substring(0, displayLength) + '...' 
        : fullText;
    
    item.innerHTML = `${truncatedText} <span class="hub-name"> (${hubName})</span>`;
    
    return item;
}

// Ví dụ sử dụng:
const container = document.getElementById('search-results-container');
const longDescription = "Tòa nhà này là Trụ sở chính và điểm giao dịch lớn nhất của ngân hàng ABC tại trung tâm thành phố.";
const hubInfo = "Hub A";

const resultItem = createSearchResultItem(longDescription, hubInfo);
container.appendChild(resultItem);
/**
 * (SỬA ĐỔI v54) Hàm tìm kiếm điểm trên bản đồ theo TERMID hoặc Tên HUB.
 * Hiển thị kết quả trong Autocomplete/List.
 */
function searchByTermId() {
    const input = document.getElementById('termid-search-input');
    const resultsContainer = document.getElementById('search-results-container');
    const searchTerm = String(input.value).trim().toUpperCase();

    // Xóa kết quả cũ
    resultsContainer.innerHTML = '';

    if (!searchTerm) {
        resultsContainer.style.display = 'none';
        showToast("Vui lòng nhập Mã CN hoặc Tên HUB để tìm kiếm.", "warning");
        return;
    }

    // Lọc các điểm (PGD/ATM) dựa trên TERMID hoặc TENHUB
    const searchResults = allPoints.filter(p => 
        !p.nhnn && (
            String(p.id).toUpperCase().includes(searchTerm) || 
            (p.tenHub && String(p.tenHub).toUpperCase().includes(searchTerm))
        )
    );

    if (searchResults.length > 0) {
        resultsContainer.style.display = 'block';
        
        searchResults.slice(0, 10).forEach(point => { // Giới hạn 10 kết quả
            const item = document.createElement('div');
            item.className = 'search-result-item';
            
            // Xây dựng nội dung item
            let content = `ID: ${point.id}`;
            if (point.tenHub) {
                content += `<span class="hub-name"> (${point.tenHub})</span>`;
            }
            
            item.innerHTML = content;
            item.dataset.pointId = point.id;

            // Gắn sự kiện click để focus vào điểm
            item.addEventListener('click', () => {
                focusOnPoint(point.id);
                resultsContainer.style.display = 'none'; // Ẩn danh sách sau khi click
                input.value = point.id; // Đặt TERMID vào ô tìm kiếm
            });

            resultsContainer.appendChild(item);
        });
        
        showToast(`Tìm thấy ${searchResults.length} kết quả.`, "info");
    } else {
        resultsContainer.style.display = 'none';
        showToast(`Không tìm thấy kết quả nào với từ khóa: ${searchTerm}`, "error");
    }
}
    // (XÓA v35) Xóa bỏ CHI_NHANH_TO_VUNG_MAP, vì VUNG giờ đã có trong data

    // --- 1. KHAI BÁO BIẾN TOÀN CỤC BẰNG LET (FIX LỖI ReferenceError) ---
let map = null;
let clusterLayer = null;
let standardLayer = null; 
let analysisLayer = null;
let nhnnMarkersLayer = null;
let previewLayer = null;
let measureLayer = null; // Layer mới
let pointMarkersLayer = null;

// --- 2. Biến lưu trữ & Cấu hình (Giữ nguyên) ---
const RADIUS_METERS = 30 * 1000;
const GROUP_COLORS = [
    '#E6194B', '#3CB44B', '#FFE119', '#4363D8', '#F58231', '#911EB4', 
    '#46F0F0', '#F032E6', '#BCF60C', '#FABEBE', '#008080', '#E6BEFF'
];
const PREVIEW_COLOR = '#f59e0b';
const NHNN_PREVIEW_LINE_COLOR = '#004aad'; 
const OVERFLOW_COLOR = '#8b5cf6'; 

let allPoints = []; 
let selectedPointA = null; // Lưu trữ dữ liệu điểm từ Search A
let selectedPointB = null; // Lưu trữ dữ liệu điểm từ Search B
let currentRoutingControl = null; // Lưu trữ đối tượng định tuyến hiện tại
let currentStraightLine = null; // <<< ĐÃ THÊM BIẾN NÀY <<<
let allGroups = []; 
let currentRankings = []; 
let currentPopup = null; 
let routingQueue = [];
let isProcessingQueue = false;
let groups = {}; 
const ROUTING_DELAY_MS = 500; 
let allMarkers = {}; 
let isBirdMode = true; 
let isBatteryView = false;
let showDistanceLabels = true; 
let isClusteringEnabled = false; 
let showNhnnMarkers = true; 



// 3. HÀM KHỞI TẠO MAP VÀ LAYERS (Đã chỉnh sửa để gán cho các biến LET trên)
function initializeMapAndLayers() {
    // Khởi tạo Map
    map = L.map('map').setView([21.0285, 105.8542], 13);
    map.createPane('borderPane');
    map.getPane('borderPane').style.zIndex = 399;
    L.tileLayer('http://{s}.google.com/vt/lyrs=r&x={x}&y={y}&z={z}&styles=feature:road|element:labels.text|visibility:off', {
        attribution: '&copy; Google Maps',
        subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
        maxZoom: 20
    }).addTo(map);

    // Khởi tạo Layers và thêm vào map nếu cần
    clusterLayer = L.markerClusterGroup({
        chunkedLoading: true, maxClusterRadius: 70, disableClusteringAtZoom: 17, spiderfyOnMaxZoom: true, showCoverageOnHover: true,
        iconCreateFunction: function(cluster) {
            const childCount = cluster.getChildCount();
            let cname = 'my-cluster-icon ';
            if (childCount < 10) { cname += 'small'; } else if (childCount < 100) { cname += 'medium'; } else { cname += 'large'; }
            return L.divIcon({ html: `<div><span>${childCount}</span></div>`, className: cname, iconSize: L.point(40, 40) });
        }
    });
    standardLayer = L.layerGroup(); 
    analysisLayer = L.layerGroup().addTo(map);
    nhnnMarkersLayer = L.layerGroup().addTo(map);
    previewLayer = L.layerGroup([], { interactive: false }).addTo(map);
    
    // Layer đo lường mới
    measureLayer = L.layerGroup().addTo(map); 
    
    pointMarkersLayer = isClusteringEnabled ? clusterLayer : standardLayer;
    map.addLayer(pointMarkersLayer);
}

initializeMapAndLayers(); // Chạy khởi tạo map và layers


    // --- 3. Tạo Icon Tùy chỉnh (Động) ---
    
    // (SỬA v33) Hàm này giờ CHỦ YẾU dùng cho Tâm Nhóm (★)
    function createPointIcon(color, text = '') {
        return L.divIcon({
            className: 'point-icon',
            iconSize: [22, 22],
            iconAnchor: [11, 11],
            html: `<div style="background-color: ${color};" class="point-icon">${text}</div>`
        });
    }

    function createCenterPointIcon(color) {
        return L.divIcon({
            className: 'center-point-icon',
            iconSize: [24, 24],
            iconAnchor: [12, 12],
            html: `<div style="background-color: ${color};" class="center-point-icon">★</div>`
        });
    }

    /**
     * Icon cho điểm NHNN - Dùng ảnh (Code của bạn)
     */
    function createNHNNIcon() { 
        const imageUrl = 'photo/icons8-bank-60.png';
        
        return L.icon({
            iconUrl: imageUrl,
            iconSize: [30, 30], 
            iconAnchor: [15, 30], // [một nửa rộng, chiều cao]
            popupAnchor: [0, -30], // [0, -chiều cao]
            shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
            shadowSize: [41, 41],
            shadowAnchor: [12, 41] // Giữ nguyên shadow anchor
        });
    }

    /**
     * (HÀM MỚI v33) Icon cho PGD/ATM (điểm thường)
     */
    function createPGDIcon() { 
        // *** ĐÂY LÀ ẢNH ICON PGD CỦA BẠN ***
        const imageUrl = 'photo/icons8-place-marker-94.png';
        
        return L.icon({
            iconUrl: imageUrl,
            iconSize: [30, 30], 
            iconAnchor: [15, 30], 
            popupAnchor: [0, -30],
            shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
            shadowSize: [41, 41],
            shadowAnchor: [12, 41]
        });
    }
    
    /**
     * (MỚI v39) Hàm định dạng tiền
     */
    function formatCurrency(value) {
        if (value >= 1000000000) {
            return (value / 1000000000).toFixed(1).replace('.0', '') + ' B';
        }
        if (value >= 1000000) {
            return (value / 1000000).toFixed(1).replace('.0', '') + ' M';
        }
        if (value >= 1000) {
            return (value / 1000).toFixed(1).replace('.0', '') + ' K';
        }
        return value;
    }
    
    /**
     * (MỚI v39) Hàm định dạng số đầy đủ
     */
    function formatFullNumber(value) {
        return new Intl.NumberFormat('vi-VN').format(value);
    }
    
/**
 * Icon Pin với nhãn tiền VƯỢT HẠN MỨC
 * * @param {object} pointData - Dữ liệu điểm, chứa thuộc tính isBatteryPoint.
 * @returns {L.DivIcon | L.Icon} - Trả về icon Pin nếu là TSCN, nếu không trả về icon PGD chuẩn.
 */
function createBatteryIcon(pointData) {
    
    // (*** LOGIC MỚI: Lọc theo thuộc tính isBatteryPoint/TSCN ***)
    // Nếu điểm KHÔNG PHẢI là TSCN, trả về icon PGD tiêu chuẩn.
    if (!pointData.isBatteryPoint) { 
        return createPGDIcon();
    }
    // (*** KẾT THÚC LOGIC BỔ SUNG ***)

    let tonQuy = pointData.tonQuy || 0;
    let hanMuc = pointData.hanMuc || 0; 
    
    // Tránh lỗi chia cho 0
    if (hanMuc === 0) {
         if (tonQuy > 0) { hanMuc = tonQuy; } else { hanMuc = 1; }
    }

    let percentage = (tonQuy / hanMuc) * 100;
    let fillPercent = Math.min(100, percentage);
    let overflowPercent = 0;
    let fillColor = '#16a34a'; // Xanh lá cây

    if (percentage >= 80 && percentage < 100) {
        fillColor = '#f59e0b'; // Vàng
    } else if (percentage >= 100) {
        fillColor = '#dc2626'; // Đỏ
    }

    percentage = Math.round(percentage);
    let amountLabelHtml = ''; 
    
    if (pointData.vuotHanMuc && tonQuy > hanMuc) {
        const overflowAmount = tonQuy - hanMuc;
        const formattedOverflowAmount = formatCurrency(overflowAmount); 
        amountLabelHtml = `<div class="battery-amount-label">+${formattedOverflowAmount}</div>`;
        overflowPercent = Math.min(100, (overflowAmount / hanMuc) * 100); 
    }

    let html = `
        <div class="battery-icon-div-wrapper"> 
            <div class="battery-icon-container">
                <div class="battery-fill" style="width: ${fillPercent}%; background-color: ${fillColor};"></div>
                ${overflowPercent > 0 ? 
                    `<div class="battery-overflow" style="width: ${overflowPercent}%; background-color: ${OVERFLOW_COLOR};"></div>` : ''}
                <span class="battery-text">${percentage}%</span>
            </div>
            ${amountLabelHtml} </div>
    `;
    
    return L.divIcon({
        className: 'battery-icon', 
        html: html,
        iconSize: [0, 0], 
        iconAnchor: [0, 0] 
    });
}

    // (*** MỚI v48 ***) HÀM TOGGLE ĐÃ ĐƯỢC DI CHUYỂN RA ĐÚNG VỊ TRÍ
    
    /**
     * (MỚI v43) Hàm Bật/Tắt hiển thị nhãn khoảng cách (km)
     */
    function toggleDistanceLabels() {
        // 1. Đảo ngược trạng thái
        showDistanceLabels = !showDistanceLabels;
        const button = document.getElementById('labels-toggle-btn');
        
        if (currentPopup) map.closePopup(currentPopup);

        // 2. Cập nhật nút
        if (showDistanceLabels) {
            button.innerHTML = '<i class="fa-solid fa-tag w-4 h-4"></i> <span class="button-text">Nhãn KM (Bật)</span>';
            button.classList.add('labels-on');
            button.classList.remove('labels-off');
            showToast("Đã BẬT: Hiển thị nhãn KM", 'info');
        } else {
            // (Sửa icon) Dùng fa-tag-slash cho đẹp hơn
            button.innerHTML = '<i class="fa-solid fa-tag-slash w-4 h-4"></i> <span class="button-text">Nhãn KM (Tắt)</span>';
            button.classList.add('labels-off');
            button.classList.remove('labels-on');
            showToast("Đã TẮT: Hiển thị nhãn KM", 'warning');
        }

        // 3. Vẽ lại các nhóm
        drawAllGroups();
        
        // 4. Xóa preview (nếu có) để nó tự vẽ lại đúng khi hover
        clearPreview();
    }

    // (*** SỬA v50 ***) Sửa logic Bật/Tắt (Không đóng menu ☰)
    function toggleRankPanel() {
        const panel = document.getElementById('rank-table-container');
        const button = document.getElementById('rank-toggle-btn');
        if (!panel || !button) return;

        // Lấy panel/nút của Filter
        const filterPanel = document.getElementById('filter-controls-container');
        const filterButton = document.getElementById('filter-toggle-btn');
        
        if (panel.style.display === 'block') {
            // Đang Bật -> Tắt nó đi
            panel.style.display = 'none';
            button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt
        } else {
            // Đang Tắt -> Bật nó lên
            panel.style.display = 'block';
            button.style.cssText = 'background-color: #3b82f6 !important; color: white !important;'; // Style Bật
            
            // (SỬA v50) Tắt panel kia (nếu đang mở)
            if (filterPanel) filterPanel.style.display = 'none'; 
            if (filterButton) filterButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt
        }
        
        // (*** LỖI ĐÃ XÓA ***) Không còn dòng code đóng menu ☰ ở đây
    }

    // (SỬA v50) Sửa logic Bật/Tắt (Không đóng menu ☰)
    function toggleFilterControls() {
        const controls = document.getElementById('filter-controls-container');
        const button = document.getElementById('filter-toggle-btn');
        if (!controls || !button) return;
        
        // Lấy panel/nút của Rank
        const rankPanel = document.getElementById('rank-table-container');
        const rankButton = document.getElementById('rank-toggle-btn');

        if (controls.style.display === 'block') {
            controls.style.display = 'none';
            button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt
        } else {
            controls.style.display = 'block';
            button.style.cssText = 'background-color: #6b7280 !important; color: white !important;'; // Style Bật
            
            // (SỬA v50) Tắt panel kia (nếu đang mở)
            if (rankPanel) rankPanel.style.display = 'none'; 
            if (rankButton) rankButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt
        }
        
        // (*** LỖI ĐÃ XÓA ***) Không còn dòng code đóng menu ☰ ở đây
    }
    
// --- 4. Thêm Nút điều khiển ---
   
// (SỬA v50) Cập nhật Nút Thu Gọn + Style mặc định
L.Control.MasterControls = L.Control.extend({
    onAdd: function(map) {
        // 1. Tạo container chính
        const container = L.DomUtil.create('div', 'leaflet-bar custom-controls-container');
        L.DomEvent.disableClickPropagation(container);
        
        // 2. (MỚI v47) Nút Bật/Tắt Panel (Hamburger)
        const toggleButton = L.DomUtil.create('button', 'leaflet-bar-part', container);
        toggleButton.id = 'panel-toggle-btn';
        toggleButton.innerHTML = '<i class="fa-solid fa-bars"></i>'; // Icon Hamburger
        
        // (*** SỬA LỖI v48.1 ***)
        toggleButton.onclick = (e) => {
            L.DomEvent.stopPropagation(e);
            // Logic Bật/Tắt class 'expanded' trên container chính
            if (L.DomUtil.hasClass(container, 'expanded')) {
                L.DomUtil.removeClass(container, 'expanded');
            } else {
                L.DomUtil.addClass(container, 'expanded');
            }
        };
        
        // 3. (MỚI v47) Wrapper cho tất cả các nút con
        const buttonsWrapper = L.DomUtil.create('div', 'buttons-wrapper', container);
        
        // --- 4. Bắt đầu các nút con ---
        
        // (*** MỚI v50 ***) Nút ĐÓNG (Collapse) Panel
        const collapseButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);
        collapseButton.id = 'panel-collapse-btn';
        collapseButton.innerHTML = '<i class="fa-solid fa-chevron-right w-4 h-4"></i>';
        collapseButton.onclick = (e) => {
            L.DomEvent.stopPropagation(e);
            L.DomUtil.removeClass(container, 'expanded');
        };
        
        // (*** MỚI v48 ***) Nút Bảng Xếp Hạng (Toggle)
        const rankButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);
        rankButton.id = 'rank-toggle-btn';
        rankButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; 
        rankButton.innerHTML = '<i class="fa-solid fa-trophy w-4 h-4"></i> <span class="button-text">Xếp Hạng</span>';
        rankButton.onclick = (e) => {
            L.DomEvent.stopPropagation(e);
            toggleRankPanel(); // Hàm mới
        };
        rankButton.style.display = 'none'; 

        // (*** MỚI v48 ***) Nút Tùy Chỉnh Map (Filter)
        const filterButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg', buttonsWrapper);
        filterButton.id = 'filter-toggle-btn';
        filterButton.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; 
        filterButton.innerHTML = '<i class="fa-solid fa-sliders w-4 h-4"></i> <span class="button-text">Tùy Chỉnh Map</span>';
        filterButton.onclick = (e) => {
            L.DomEvent.stopPropagation(e);
            toggleFilterControls();
        };

        // Nút Routing
        const routingButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg bird-mode', buttonsWrapper);
        routingButton.id = 'routing-toggle-btn'; 
        routingButton.innerHTML = '<i class="fa-solid fa-feather w-4 h-4"></i> <span class="button-text">Đường chim Bay</span>';
        routingButton.onclick = (e) => {
            L.DomEvent.stopPropagation(e);
            toggleRoutingMode();
        };
        
        // Nút Chế độ Pin (FIX LỖI: Gọi hàm trực tiếp)
        const batteryButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg pin-mode', buttonsWrapper); 
        batteryButton.id = 'battery-toggle-btn'; 
        batteryButton.innerHTML = '<i class="fa-solid fa-battery-half w-4 h-4"></i> <span class="button-text">Chế độ Pin</span>'; 
        batteryButton.onclick = (e) => {
            L.DomEvent.stopPropagation(e);
            // GỌI HÀM AN TOÀN HƠN
            if (typeof toggleBatteryView === 'function') {
                toggleBatteryView();
            } else {
                console.error("Hàm toggleBatteryView chưa được định nghĩa.");
            }
        };

        // Nút Bật/Tắt Gom Cụm
        const clusterButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg cluster-off', buttonsWrapper); 
        clusterButton.id = 'cluster-toggle-btn';
        clusterButton.innerHTML = '<i class="fa-solid fa-braille w-4 h-4"></i> <span class="button-text">Gom Cụm (Tắt)</span>'; 
        clusterButton.onclick = (e) => {
            L.DomEvent.stopPropagation(e);
            toggleClustering();
        };

        // Nút Bật/Tắt Nhãn KM
        const labelsButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg labels-on', buttonsWrapper);
        labelsButton.id = 'labels-toggle-btn';
        labelsButton.innerHTML = '<i class="fa-solid fa-tag w-4 h-4"></i> <span class="button-text">Nhãn KM (Bật)</span>';
        labelsButton.onclick = (e) => {
            L.DomEvent.stopPropagation(e);
            toggleDistanceLabels();
        };
        
        // Nút Bật/Tắt NHNN
        const nhnnButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg nhnn-on', buttonsWrapper);
        nhnnButton.id = 'nhnn-toggle-btn';
        nhnnButton.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i> <span class="button-text">Ẩn NHNN</span>';
        nhnnButton.onclick = (e) => {
            L.DomEvent.stopPropagation(e);
            toggleNhnn();
        };
        // (*** MỚI ***) Nút LƯU/EXPORT DỮ LIỆU NHÓM
        const saveButton = L.DomUtil.create('button', 'leaflet-bar-part rounded-lg btn-add', buttonsWrapper);
        saveButton.id = 'save-groups-btn';
        saveButton.innerHTML = '<i class="fa-solid fa-cloud-arrow-up w-4 h-4"></i> <span class="button-text">Lưu Dữ Liệu Nhóm</span>';
        saveButton.onclick = (e) => {
            L.DomEvent.stopPropagation(e);
            exportGroupsData(); // Gọi hàm xử lý chính
        };
        // --- Hết các nút con ---

        // (MỚI v47) Khi click vào bản đồ, đóng panel (nếu đang mở trên di động)
        map.on('click', () => { L.DomUtil.removeClass(container, 'expanded'); });
        map.on('dragstart', () => { L.DomUtil.removeClass(container, 'expanded'); });

        return container;
    },
    onRemove: function(map) {}
});

// Thêm control mới vào bản đồ (Chắc chắn chạy sau initializeMapAndLayers())
new L.Control.MasterControls({ position: 'topright' }).addTo(map);
    // --- 5. Các Hàm Chức năng ---
// Tên khóa dùng để lưu trữ trong localStorage
const LOCAL_STORAGE_KEY = 'HMTQ_SAVED_GROUPS_V2'; // Dùng V2 để đảm bảo lưu Polyline Cache

/**
 * (SỬA ĐỔI) Hàm xuất và LƯU dữ liệu nhóm đã tạo vào Local Storage.
 */
function exportGroupsData() {
    if (allGroups.length === 0) {
        // Xóa dữ liệu cũ nếu không còn nhóm nào
        localStorage.removeItem(LOCAL_STORAGE_KEY);
        showToast("Đã xóa dữ liệu nhóm cũ trong trình duyệt.", "warning");
        return;
    }
    
    // 1. Chuyển đổi dữ liệu thô sang cấu trúc gọn gàng
    const exportedData = allGroups.map(group => {
        // Lọc ra ID của tất cả các điểm trong nhóm (bao gồm điểm tâm)
        const memberIds = group.points.map(p => p.id); 

        return {
            group_id: group.id,
            group_number: group.groupNumber,
            color: group.color,
            center_point: {
                id: group.centerPoint.id,
                lat: group.centerPoint.latlng.lat,
                lon: group.centerPoint.latlng.lng,
            },
            member_ids: memberIds, // <--- ĐÃ GOM CẢ ĐIỂM TÂM
            // LƯU CACHE POLYLINE 
            polyline_cache: group.polylineCache, 
            member_count: memberIds.length
        };
    });
    
    const jsonOutput = JSON.stringify(exportedData); 
    
    // 2. LƯU VÀO LOCAL STORAGE
    try {
        localStorage.setItem(LOCAL_STORAGE_KEY, jsonOutput);
        console.log("=== DỮ LIỆU NHÓM ĐÃ LƯU VÀO LOCAL STORAGE ===");
        console.log(JSON.parse(jsonOutput));
        showToast("Đã lưu trạng thái nhóm thành công!", "success");
    } catch (e) {
        showToast("Lỗi lưu trữ! Trình duyệt quá đầy hoặc đang ở chế độ ẩn danh.", "error");
    }
}

// (MỚI) Hàm hỗ trợ lấy dữ liệu điểm gốc từ ID
function getPointDataById(pointId) {
    return allPoints.find(p => p.id === pointId);
}

/**
 * (SỬA LỖI PHỤC HỒI CACHE) Hàm tải và phục hồi dữ liệu nhóm đã lưu.
 * @param {Array} savedGroupsData - Dữ liệu JSON đã lưu trữ.
 */
function loadSavedGroups(savedGroupsData) {
    if (!Array.isArray(savedGroupsData) || savedGroupsData.length === 0) {
        return;
    }

    // 1. Xóa trạng thái nhóm hiện tại và các nhóm cũ
    allGroups = [];
    groups = {};
    allPoints.forEach(p => p.groupId = null);

    let loadCount = 0;
    
    // 2. Tải từng nhóm
    savedGroupsData.forEach(savedGroup => {
        
        const centerPointId = savedGroup.center_point.id;
        const centerPointData = getPointDataById(centerPointId);

        if (!centerPointData) {
            console.warn(`Bỏ qua nhóm ${savedGroup.group_id}: Không tìm thấy điểm tâm ID ${centerPointId}.`);
            return;
        }

        const newGroup = {
            id: savedGroup.group_id,
            centerPoint: centerPointData,
            color: savedGroup.color,
            groupNumber: savedGroup.group_number,
            routingControls: [],
            // PHỤC HỒI POLYLINE CACHE
            polylineCache: savedGroup.polyline_cache || {}, 
            points: [] // Khởi tạo mảng điểm
        };
        
        // **********************************************
        // 3. Cập nhật các điểm thành viên VÀ ĐIỂM TÂM
        const memberIds = savedGroup.member_ids;
        const pointsInGroup = [];
        
        // Đảm bảo điểm tâm là thành viên của nhóm
        centerPointData.groupId = savedGroup.group_id; 
        pointsInGroup.push(centerPointData);
        
        memberIds.forEach(memberId => {
            if (memberId === centerPointId) return; // Bỏ qua nếu là điểm tâm (đã thêm)
            
            const memberPoint = getPointDataById(memberId);
            if (memberPoint) {
                memberPoint.groupId = savedGroup.group_id;
                pointsInGroup.push(memberPoint);
            }
        });

        // Gán MẢNG ĐIỂM đã hoàn chỉnh (bao gồm điểm tâm) vào nhóm
        newGroup.points = pointsInGroup; // <--- DÒNG SỬA CHỮA
        
        allGroups.push(newGroup);

        // 4. Đồng bộ biến 'groups' (cho UI Popup)
        groups[`NHÓM ${savedGroup.group_number}`] = { 
            id: savedGroup.group_id, 
            color: savedGroup.color, 
            pointIds: memberIds
        };
        
        loadCount++;
    });
    
    // 6. Vẽ lại bản đồ
    drawAllGroups();
    updateRankTable();
    updateFilterOptions();
    
    if (loadCount > 0) {
        showToast(`Đã tải lại ${loadCount} nhóm từ bộ nhớ thành công!`, "info");
    }
}

/**
 * (MỚI) Xóa một nhóm đã chọn.
 * @param {string} groupId - ID của nhóm cần xóa (ví dụ: 'G_1').
 */
function popup_deleteGroup(groupId) {
    // Thêm hộp thoại xác nhận để tránh xóa nhầm
    if (!confirm(`Bạn có chắc chắn muốn hủy Nhóm ID: ${groupId} không? Hành động này không thể hoàn tác.`)) {
        return;
    }
    
    if (currentPopup) {
        map.closePopup(currentPopup);
        currentPopup = null;
    }

    const groupIndex = allGroups.findIndex(g => String(g.id) === String(groupId));
    if (groupIndex === -1) {
        showToast(`Lỗi: Không tìm thấy nhóm ID ${groupId}.`, "error");
        return;
    }

    const groupToDelete = allGroups[groupIndex];
    const groupNumber = groupToDelete.groupNumber;

    // 1. Reset GroupID cho TẤT CẢ các điểm trong nhóm
    // Bao gồm các điểm trong mảng points và điểm centerPoint (cần tìm lại điểm centerPoint từ allPoints)
    
    // Tìm lại tất cả các điểm trên bản đồ mà có groupId này
    const pointsToReset = allPoints.filter(p => String(p.groupId) === String(groupId));
    
    pointsToReset.forEach(p => {
        p.groupId = null; // Đưa về trạng thái chưa được nhóm
    });

    // 2. Xóa khỏi danh sách nhóm (allGroups)
    allGroups.splice(groupIndex, 1);

    // 3. Xóa khỏi đối tượng groups (dùng cho UI/Popup)
    const groupKey = Object.keys(groups).find(key => groups[key].id === groupId);
    if (groupKey) {
        delete groups[groupKey];
    }
    
    // 4. CẬP NHẬT TRẠNG THÁI: Vẽ lại bản đồ và UI
    drawAllGroups();
    updateRankTable();
    updateFilterOptions();

    // 5. LƯU VÀO LOCAL STORAGE
    exportGroupsData();

    showToast(`Đã hủy thành công Nhóm ${groupNumber} và đưa ${pointsToReset.length} điểm về trạng thái chưa nhóm.`, "success");
}
/**
 * (SỬA LỖI VÀ BỔ SUNG) Hàm khởi tạo dữ liệu điểm và thêm Marker vào bản đồ.
 * Đã sửa lỗi ReferenceError: pointId is not defined.
 */
function addPointToMap(latlng, termId, chinhanh, nhnn, vung, tonQuyStr, vuotHanMucStr, hanMucStr, hubYesStr, tenHubStr, plDgdStr) { // <--- THÊM plDgdStr
    // (SỬA v44.1) Logic check 'isNHNN' này mạnh hơn
    const isNHNN = (nhnn === true || String(nhnn).toLowerCase() === 'true' || String(nhnn) === '1');
    
    const cleanChinhanh = chinhanh ? String(chinhanh).trim() : 'Không có';
    const cleanVung = vung ? String(vung).trim() : 'Không xác định';
    const cleanTonQuy = parseFloat(String(tonQuyStr).replace(/[\s,]/g, '')) || 0;
    const cleanHanMuc = parseFloat(String(hanMucStr).replace(/[\s,]/g, '')) || 0;
    const isVuotHanMuc = String(vuotHanMucStr).trim() !== '-' && String(vuotHanMucStr).trim() !== '';

    const isHubPoint = String(hubYesStr).trim().toUpperCase() === 'YES';
    
    // (*** LOGIC MỚI: XÁC ĐỊNH ĐIỂM PIN (TSCN) ***)
    const isBatteryPoint = String(plDgdStr).trim().toUpperCase() === 'TSCN'; 
    
    const cleanTenHub = tenHubStr ? String(tenHubStr).trim() : null;

    
    // (*** KHẮC PHỤC LỖI REFERENCE ERROR Ở ĐÂY ***)
    const newMarker = L.marker(latlng, { 
        icon: isNHNN ? createNHNNIcon() : createPGDIcon() 
    });

    // 1. KHAI BÁO pointId NGAY LẬP TỨC
    const pointId = (termId ? String(termId).trim() : null) || L.stamp(newMarker); 

    // 2. LƯU MARKER VÀO BIẾN TOÀN CỤC BẰNG pointId
    allMarkers[pointId] = newMarker; 
    // ===========================================
    
    // (*** MỚI v44 ***) Thêm vào layer NHNN nếu cần
    if (isNHNN) {
        newMarker.addTo(nhnnMarkersLayer); 
    }
    
    const newPointData = {
        id: pointId, 
        latlng: latlng,
        marker: newMarker,
        groupId: isNHNN ? 'REFERENCE' : null, 
        chinhanh: cleanChinhanh, 
        vung: cleanVung, 
        isVisible: true,
        nhnn: isNHNN, 
        tonQuy: cleanTonQuy,
        hanMuc: cleanHanMuc,
        vuotHanMuc: isVuotHanMuc,
        isHub: isHubPoint, 
        tenHub: cleanTenHub,
        isBatteryPoint: isBatteryPoint // <--- THUỘC TÍNH MỚI DÙNG CHO LỌC PIN
    };
    
    if (isNHNN) {
        newMarker.on('click', (e) => {
            L.DomEvent.stopPropagation(e); 
            handleMarkerClick(newPointData); 
        });
    } else {
        newMarker.on('mouseover', (e) => {
            highlightRankItem(newPointData.id);
            if (newPointData.groupId === null && !isBatteryView && newPointData.isHub) {
                const ungroupedPoints = allPoints.filter(p => p.groupId === null && p.isVisible && !p.nhnn); 
                let coveredPoints = [];
                for (const pointToTest of ungroupedPoints) { 
                    if (newPointData.latlng.distanceTo(pointToTest.latlng) <= RADIUS_METERS) {
                        coveredPoints.push(pointToTest);
                    }
                }
                const previewItem = {
                    type: 'NEW', 
                    centerPoint: newPointData,
                    coveredPoints: coveredPoints,
                    color: PREVIEW_COLOR 
                };
                showPreview(previewItem, null); 
            }
        });
        newMarker.on('mouseout', () => {
            clearRankItemHighlight(); 
            clearPreview();
        });
        newMarker.on('click', (e) => {
            L.DomEvent.stopPropagation(e); 
            handleMarkerClick(newPointData);
        });
    }
    newMarker.on('popupclose', () => {
        currentPopup = null;
    });
    
    allPoints.push(newPointData); 
    return newPointData; 
}
    
    /**
     * (*** MỚI v45 ***) Hàm Bật/Tắt hiển thị lớp NHNN
     */
    function toggleNhnn() {
        // 1. Đảo ngược trạng thái
        showNhnnMarkers = !showNhnnMarkers;
        const button = document.getElementById('nhnn-toggle-btn');
        
        if (currentPopup) map.closePopup(currentPopup);

        // 2. Cập nhật nút
        if (showNhnnMarkers) {
            button.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i> <span class="button-text">Ẩn NHNN</span>';
            button.classList.add('nhnn-on');
            button.classList.remove('nhnn-off');
            showToast("Đã BẬT: Hiển thị NHNN", 'info');
        } else {
            button.innerHTML = '<i class="fa-solid fa-eye-slash w-4 h-4"></i> <span class="button-text">Hiện NHNN</span>';
            button.classList.add('nhnn-off');
            button.classList.remove('nhnn-on');
            showToast("Đã TẮT: Ẩn NHNN", 'warning');
        }

        // 3. (QUAN TRỌNG) Gọi lại hàm applyFilter
        applyFilter();
    }
function loadPreloadedData() {
    const powerAutomateUrl = 'https://default460cecfbf0c64dd7a5ec66ef4d75ae.63.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/c7a3ba54b6604025882ae481816180bb/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=R88_MePGo47lYzv0ndIiVxbRUcMncU26zdMq9HGw9hs'; 

    showToast("Đang tải dữ liệu từ Power Automate...", 'info');

    fetch(powerAutomateUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({}) 
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Lỗi HTTP! Trạng thái: ${response.status}`);
        }
        return response.json(); 
    })
    .then(data => {
        let bounds = L.latLngBounds();
        
        if (!Array.isArray(data)) {
            throw new Error("Dữ liệu nhận được không phải là một mảng (array)!");
        }

        data.forEach(item => {
            const lat = parseFloat(String(item.LATITUDE).trim());
            const lng = parseFloat(String(item.LONGITUDE).replace('S', '').trim());

            if (!isNaN(lat) && !isNaN(lng)) {
                const latlng = L.latLng(lat, lng);

                addPointToMap(
                    latlng, 
                    item.TERMID, 
                    item.CHINHANH, 
                    item.NHNN, 
                    item.VUNG,
                    item.Ton_quy_cuoi_ngay,
                    item.VUOT_HAN_MUC,
                    item.HMTQ_ngay,
                    item.HUBYES,
                    item.TENHUB,
                    item.PL_DGD // <--- THAM SỐ THỨ 11 MỚI
                ); 
                bounds.extend(latlng);
            } else {
                console.warn("Bỏ qua điểm có tọa độ không hợp lệ:", item.TERMID);
            }
        });
        
        buildCascadingFiltersUI(); 

        showToast(`Đã tải ${data.length} điểm dữ liệu.`, 'success');
        
        updateRankTable(); 

        updateMarkersVisibility();
        loadGroupsFromLocalStorage(); 
        if (bounds.isValid()) {
            map.fitBounds(bounds.pad(0.1));
        }
    })
    .catch(error => {
        console.error('Lỗi khi tải dữ liệu từ Power Automate:', error);
        showToast(`Lỗi tải dữ liệu: ${error.message}`, 'error');
        updateRankTable();
        updateMarkersVisibility(); 
    });
}
/**
 * (MỚI) Đọc dữ liệu từ Local Storage và gọi phục hồi.
 */
function loadGroupsFromLocalStorage() {
    try {
        const savedJson = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (savedJson) {
            const savedData = JSON.parse(savedJson);
            loadSavedGroups(savedData);
        }
    } catch (e) {
        console.error("Lỗi khi đọc Local Storage:", e);
        showToast("Lỗi khi tải lại trạng thái nhóm từ bộ nhớ.", "error");
    }
}
    // --- (MỚI v35) CỤM LOGIC LỌC GIA ĐÌNH ---
    
    /**
     * (SỬA v40) Thêm HTML cho bộ lọc Nhóm
     */
    function buildCascadingFiltersUI() {
        const container = document.getElementById('cascading-filter-container');
        if (!container) return;

        container.innerHTML = `
            <hr class="my-3 border-t border-gray-300">
            <div class="filter-control">
                <label for="filter-vung">Lọc theo Vùng:</label>
                <select id="filter-vung">
                </select>
            </div>
            <div class="filter-control">
                <label for="filter-chinhanh">Lọc theo Chi Nhánh:</label>
                <select id="filter-chinhanh">
                </select>
            </div>
            <div class="filter-control">
                <label for="filter-termid">Lọc theo Mã CN (TERMID):</label>
                <select id="filter-termid">
                </select>
            </div>
            <div class="filter-control">
                <label for="filter-vuothm">Lọc theo Hạn Mức:</label>
                <select id="filter-vuothm">
                </select>
            </div>
            <div class="filter-control">
                <label for="filter-nhom">Lọc theo Nhóm:</label>
                <select id="filter-nhom">
                </select>
            </div>
            <button id="reset-cascading-filter-btn">
                <i class="fa-solid fa-filter-circle-xmark"></i> Xóa Lọc
            </button>
        `;

        // Gắn sự kiện
        document.getElementById('filter-vung').addEventListener('change', () => {
            updateFilterOptions();
            applyFilter();
        });
        
        document.getElementById('filter-chinhanh').addEventListener('change', () => {
            updateFilterOptions(); // Cập nhật TERMID, Hạn Mức, Nhóm
            applyFilter();
        });
        
        document.getElementById('filter-termid').addEventListener('change', () => {
            updateFilterOptions(); // Cập nhật Hạn Mức, Nhóm
            applyFilter();
        });
        
        document.getElementById('filter-vuothm').addEventListener('change', () => {
            updateFilterOptions(); // Cập nhật Nhóm
            applyFilter();
        });
        
        // (MỚI v40) Gắn sự kiện cho bộ lọc Nhóm
        document.getElementById('filter-nhom').addEventListener('change', applyFilter);

        
        document.getElementById('reset-cascading-filter-btn').addEventListener('click', () => {
            const vungSelect = document.getElementById('filter-vung');
            if (vungSelect) vungSelect.value = 'ALL';
            
            // Gọi update 4 lần để reset tất cả
            updateFilterOptions(); 
            updateFilterOptions(); 
            updateFilterOptions(); 
            updateFilterOptions(); // Lần 4: Reset Nhóm
            applyFilter();
            showToast("Đã xóa lọc", "info");
        });

        // Tải dữ liệu lần đầu
        updateFilterOptions();
    }

    /**
     * (SỬA v40) Cập nhật cả 5 dropdown
     */
    function updateFilterOptions() {
        const vungSelect = document.getElementById('filter-vung');
        const chinhanhSelect = document.getElementById('filter-chinhanh');
        const termidSelect = document.getElementById('filter-termid');
        const vuothmSelect = document.getElementById('filter-vuothm');
        const nhomSelect = document.getElementById('filter-nhom'); // (MỚI v40)
        
        if (!vungSelect || !chinhanhSelect || !termidSelect || !vuothmSelect || !nhomSelect) return; 

        const selectedVung = vungSelect.value || 'ALL';
        const oldChiNhanhValue = chinhanhSelect.value || 'ALL';
        const oldTermidValue = termidSelect.value || 'ALL'; 
        const oldVuotHMValue = vuothmSelect.value || 'ALL'; // (MỚI v40)
        const oldNhomValue = nhomSelect.value || 'ALL'; // (MỚI v40)

        // 1. Cập nhật Vùng (Chỉ chạy 1 lần)
        if (vungSelect.options.length <= 1) {
            const vungSet = new Set(allPoints.map(p => p.vung));
            vungSelect.innerHTML = '<option value="ALL">-- Tất cả Vùng --</option>';
            [...vungSet].sort().forEach(vung => {
                vungSelect.innerHTML += `<option value="${vung}">${vung}</option>`;
            });
        }

        // 2. Cập nhật Chi Nhánh (dựa trên Vùng)
        const chinhanhSet = new Set(
            allPoints
                .filter(p => selectedVung === 'ALL' || p.vung === selectedVung)
                .map(p => p.chinhanh)
        );
        chinhanhSelect.innerHTML = '<option value="ALL">-- Tất cả Chi Nhánh --</option>';
        [...chinhanhSet].sort().forEach(cn => {
            chinhanhSelect.innerHTML += `<option value="${cn}">${cn}</option>`;
        });
        
        if (chinhanhSet.has(oldChiNhanhValue)) {
            chinhanhSelect.value = oldChiNhanhValue;
        }

        // 3. Cập nhật TERMID (dựa trên Vùng và Chi Nhánh *mới*)
        const currentSelectedChiNhanh = chinhanhSelect.value || 'ALL';
        const termidSet = new Set(
            allPoints
                .filter(p => (selectedVung === 'ALL' || p.vung === selectedVung) &&
                             (currentSelectedChiNhanh === 'ALL' || p.chinhanh === currentSelectedChiNhanh))
                .map(p => p.id) 
        );
        termidSelect.innerHTML = '<option value="ALL">-- Tất cả Mã CN --</option>';
        const sortedTermids = [...termidSet].sort((a, b) => String(a).localeCompare(String(b)));
        
        sortedTermids.forEach(id => {
            termidSelect.innerHTML += `<option value="${id}">${id}</option>`;
        });
        
        if (termidSet.has(oldTermidValue)) {
            termidSelect.value = oldTermidValue;
        }
        
        // 4. Cập nhật Hạn Mức (dựa trên 3 filter trên)
        const currentSelectedTermid = termidSelect.value || 'ALL';
        const vuotHMSet = new Set(
             allPoints
                 .filter(p => !p.nhnn) 
                 .filter(p => (selectedVung === 'ALL' || p.vung === selectedVung) &&
                              (currentSelectedChiNhanh === 'ALL' || p.chinhanh === currentSelectedChiNhanh) &&
                              (currentSelectedTermid === 'ALL' || String(p.id) === String(currentSelectedTermid)))
                 .map(p => p.vuotHanMuc) 
        );
        vuothmSelect.innerHTML = '<option value="ALL">-- Tất cả Hạn Mức --</option>';
        if (vuotHMSet.has(true)) {
            vuothmSelect.innerHTML += '<option value="YES">Vượt Hạn Mức</option>';
        }
        if (vuotHMSet.has(false)) {
            vuothmSelect.innerHTML += '<option value="NO">Không Vượt</option>';
        }
        if (["ALL", "YES", "NO"].includes(oldVuotHMValue)) { // Khôi phục lựa chọn Hạn Mức
            vuothmSelect.value = oldVuotHMValue;
        }
        
        // 5. (MỚI v40) Cập nhật Nhóm (dựa trên 4 filter trên)
        const currentSelectedVuotHM = vuothmSelect.value || 'ALL';
        const filteredPoints = allPoints.filter(p => 
            (selectedVung === 'ALL' || p.vung === selectedVung) &&
            (currentSelectedChiNhanh === 'ALL' || p.chinhanh === currentSelectedChiNhanh) &&
            (currentSelectedTermid === 'ALL' || String(p.id) === String(currentSelectedTermid)) &&
            (p.nhnn || // Luôn bỏ qua NHNN khỏi logic filter này
             (currentSelectedVuotHM === 'ALL') ||
             (currentSelectedVuotHM === 'YES' && p.vuotHanMuc === true) ||
             (currentSelectedVuotHM === 'NO' && p.vuotHanMuc === false))
        );
        
        const nhomSet = new Set(filteredPoints.map(p => p.groupId));
        nhomSelect.innerHTML = '<option value="ALL">-- Tất cả Nhóm --</option>';
        
        // Thêm lựa chọn [CHƯA CÓ NHÓM] (chỉ nếu nó tồn tại)
        if (nhomSet.has(null)) {
             nhomSelect.innerHTML += '<option value="NULL">[CHƯA CÓ NHÓM]</option>';
        }
        
        // Thêm các nhóm đã tạo (chỉ nếu chúng có trong danh sách đã lọc)
        allGroups.forEach(group => {
            if (nhomSet.has(group.id)) { 
                nhomSelect.innerHTML += `<option value="${group.id}">Nhóm ${group.groupNumber}</option>`;
            }
        });
        
        if (nhomSet.has(oldNhomValue) || (oldNhomValue === 'NULL' && nhomSet.has(null))) {
            nhomSelect.value = oldNhomValue;
        }

        // Khôi phục lựa chọn Vùng
        vungSelect.value = selectedVung;
    }

    /**
     * (SỬA v45) Thêm logic kiểm tra biến 'showNhnnMarkers'
     */
    function applyFilter() {
        const selVung = document.getElementById('filter-vung');
        const selChiNhanh = document.getElementById('filter-chinhanh');
        const selTermid = document.getElementById('filter-termid');
        const selVuotHM = document.getElementById('filter-vuothm'); 
        const selNhom = document.getElementById('filter-nhom'); // (MỚI v40)

        const selectedVung = selVung ? selVung.value : 'ALL';
        const selectedChiNhanh = selChiNhanh ? selChiNhanh.value : 'ALL';
        const selectedTermid = selTermid ? selTermid.value : 'ALL';
        const selectedVuotHM = selVuotHM ? selVuotHM.value : 'ALL'; 
        const selectedNhom = selNhom ? selNhom.value : 'ALL'; // (MỚI v40)

        allPoints.forEach(p => {
            const vungMatch = (selectedVung === 'ALL' || p.vung === selectedVung);
            const chiNhanhMatch = (selectedChiNhanh === 'ALL' || p.chinhanh === selectedChiNhanh);
            const termidMatch = (selectedTermid === 'ALL' || String(p.id) === String(selectedTermid));
            
            let vuotHMMatch = true; 
            if (p.nhnn) { 
                vuotHMMatch = true;
            } else if (selectedVuotHM === 'YES') {
                vuotHMMatch = p.vuotHanMuc === true;
            } else if (selectedVuotHM === 'NO') {
                vuotHMMatch = p.vuotHanMuc === false;
            }
            
            // (MỚI v40) Logic lọc Nhóm
            let nhomMatch = true;
            if (selectedNhom === 'ALL') {
                nhomMatch = true; // Luôn hiển thị
            } else if (selectedNhom === 'NULL') {
                nhomMatch = (p.groupId === null); // Chỉ hiển thị PGD chưa nhóm (NHNN sẽ là 'REFERENCE')
            } else {
                // Ẩn NHNN nếu 1 nhóm cụ thể được chọn
                if (p.nhnn) {
                    nhomMatch = false; 
                } else {
                    nhomMatch = (String(p.groupId) === String(selectedNhom));
                }
            }
            
            // (*** MỚI v45 ***) Thêm điều kiện kiểm tra nút Ẩn/Hiện NHNN
            let nhnnToggleMatch = true;
            if (p.nhnn && !showNhnnMarkers) {
                nhnnToggleMatch = false; // Tắt nếu là NHNN và nút đang "Tắt"
            }
            // (*** HẾT MỚI v45 ***)

            // Thêm 'nhnnToggleMatch' vào phép tính cuối cùng
            p.isVisible = vungMatch && chiNhanhMatch && termidMatch && vuotHMMatch && nhomMatch && nhnnToggleMatch;
        });

        if (currentPopup) {
            map.closePopup(currentPopup);
            currentPopup = null;
        }
        
        updateMarkersVisibility(); 
        drawAllGroups();           
        updateRankTable();         
    }
    
/**
 * (SỬA LỚN) Cập nhật hiển thị marker dựa trên bộ lọc VÀ chế độ Pin.
 * Đảm bảo ẩn các điểm PGD (không phải TSCN) khi ở chế độ Pin.
 */
function updateMarkersVisibility() {
        
    // --- 1. XỬ LÝ CÁC ĐIỂM PGD/ATM (CÓ GOM CỤM) ---
    
    // 1a. Lấy danh sách marker PGD/ATM (KHÔNG phải NHNN) cần hiển thị
    const visiblePgdMarkers = allPoints
        .filter(p => !p.nhnn)
        .filter(p => {
             // (*** LOGIC LỌC MỚI CHO CHẾ ĐỘ PIN ***)
             // ẨN TẤT CẢ CÁC ĐIỂM KHÔNG PHẢI TSCN KHI Ở CHẾ ĐỘ PIN
             if (isBatteryView && !p.isBatteryPoint) {
                 return false; 
             }
             // (*** KẾT THÚC LOGIC LỌC MỚI ***)
             
             // Giữ nguyên điều kiện lọc cũ (Filter UI)
             return p.isVisible; 
        })
        .map(p => p.marker);

    // 1b. Xóa các PGD/ATM marker cũ khỏi lớp đang hoạt động
    pointMarkersLayer.clearLayers(); 

    // 1c. Thêm marker PGD/ATM vào lại, tùy theo loại layer
    if (isClusteringEnabled) {
        pointMarkersLayer.addLayers(visiblePgdMarkers);
    } else {
        visiblePgdMarkers.forEach(marker => {
            pointMarkersLayer.addLayer(marker);
        });
    }

    // --- 2. XỬ LÝ CÁC ĐIỂM NHNN (KHÔNG GOM CỤM) ---
    
    // Lặp qua tất cả các điểm NHNN và ẩn/hiện chúng trên lớp cố định
    allPoints.filter(p => p.nhnn).forEach(nhnnPoint => {
        if (nhnnPoint.isVisible) {
            if (!nhnnMarkersLayer.hasLayer(nhnnPoint.marker)) {
                nhnnMarkersLayer.addLayer(nhnnPoint.marker);
            }
        } else {
            if (nhnnMarkersLayer.hasLayer(nhnnPoint.marker)) {
                if (nhnnPoint.marker.getTooltip()) {
                    nhnnPoint.marker.unbindTooltip();
                }
                nhnnMarkersLayer.removeLayer(nhnnPoint.marker);
            }
        }
    });
}
    
    // --- HẾT CỤM LOGIC LỌC v35 ---


/**
 * (SỬA ĐỔI v48: Ẩn/Hiện nút 🏆 thay vì ẩn/hiện panel)
 * (*** SỬA v51: Chỉ hiển thị điểm isHub=true trong xếp hạng NEW ***)
 */
function updateRankTable() {
    const rankTableContainer = document.getElementById('rank-table-container');
    const rankToggleButton = document.getElementById('rank-toggle-btn'); // ID mới
    
    if (!rankToggleButton) return; 

    // (MỚI v39) Không hiển thị bảng xếp hạng khi ở chế độ Pin
    if (isBatteryView) {
        rankTableContainer.style.display = 'none'; 
        rankToggleButton.style.display = 'none'; 
        currentRankings = [];
        return; 
    }

    // (*** SỬA LỚN NHẤT ***)
    // 1. Lọc ra các điểm HUB CHƯA NHÓM VÀ HIỂN THỊ (Ứng viên TÂM NHÓM MỚI)
    const ungroupedHubPoints = allPoints.filter(p => p.groupId === null && p.isVisible && p.isHub);
    
    // 2. Lọc ra TẤT CẢ các điểm chưa nhóm VÀ HIỂN THỊ (Ứng viên THÀNH VIÊN)
    const allUngroupedAndVisible = allPoints.filter(p => p.groupId === null && p.isVisible);

    // (SỬA v48) Logic mới: Ẩn/Hiện NÚT BẤM
    if (ungroupedHubPoints.length === 0 && allGroups.length === 0) {
        rankToggleButton.style.display = 'none'; // Ẩn nút
        rankTableContainer.style.display = 'none'; // Tắt panel (phòng hờ)
        currentRankings = [];
        return;
    }
    
    // (SỬA v48) Hiển thị nút bấm (dạng flex)
    rankToggleButton.style.display = 'flex'; 
    
    currentRankings = []; 
    
    // ---- BƯỚC 2: Xếp hạng "TẠO NHÓM MỚI" (CHỈ DÙNG ĐIỂM HUB) ----
    for (const centerCandidate of ungroupedHubPoints) { // <--- SỬ DỤNG HUB POINTS
        let coveredPoints = [];
        let totalDistanceScore = 0; 

        // Lặp qua TẤT CẢ các điểm chưa nhóm & hiển thị
        for (const pointToTest of allUngroupedAndVisible) { 
            const distance = centerCandidate.latlng.distanceTo(pointToTest.latlng);
            if (distance <= RADIUS_METERS) {
                coveredPoints.push(pointToTest);
                totalDistanceScore += (distance * distance); 
            }
        }
        
        if (coveredPoints.length > 0) {
            currentRankings.push({
                type: 'NEW', 
                centerId: centerCandidate.id,
                centerPoint: centerCandidate, 
                coveredPoints: coveredPoints,
                score: coveredPoints.length,
                distanceScore: totalDistanceScore,
                color: PREVIEW_COLOR 
            });
        }
    }

    // ---- BƯỚC 3: Xếp hạng "DI CHUYỂN NHÓM" (Giữ nguyên) ----
    const centerPointIds = new Set(allGroups.map(g => g.centerPoint.id));
    const movablePoints = allPoints.filter(p => p.groupId !== null && p.groupId !== 'REFERENCE' && !centerPointIds.has(p.id) && p.isVisible);

    for (const pointToMove of movablePoints) { 
        for (const targetGroup of allGroups) {
            
            if (!targetGroup.centerPoint.isVisible) continue; 
            
            if (pointToMove.groupId !== targetGroup.id) {
                const distance = pointToMove.latlng.distanceTo(targetGroup.centerPoint.latlng);
                if (distance <= RADIUS_METERS) {
                    currentRankings.push({
                        type: 'MOVE',
                        pointToMove: pointToMove,
                        targetGroup: targetGroup,
                        score: 0, 
                        distanceScore: distance,
                        color: targetGroup.color
                    });
                }
            }
        }
    }
    
    currentRankings.sort((a, b) => {
        if (a.score !== b.score) {
            return b.score - a.score; 
        }
        return a.distanceScore - b.distanceScore; 
    });

    renderRankTable();
}

/**
 * (SỬA ĐỔI v51 & v52) Vẽ Bảng Xếp Hạng - Thêm logic click focus vào điểm tương ứng
 */
function renderRankTable() {
    const rankTableBody = document.getElementById('rank-table-body');
    rankTableBody.innerHTML = ''; 

    const newActions = currentRankings.filter(r => r.type === 'NEW');
    const moveActions = currentRankings.filter(r => r.type === 'MOVE');

    // 1. Render NEW (Tạo Mới)
    newActions.forEach((item, index) => {
        const row = document.createElement('div');
        row.className = 'rank-item rank-item-new';
        row.dataset.pointId = item.centerId; 
        
        const hubNameHtml = item.centerPoint.tenHub ? 
                            `<div><b>HUB:</b> ${item.centerPoint.tenHub}</div>` : 
                            '';
        
        // Gắn sự kiện Click của Row để Focus/Zoom trên bản đồ
        row.addEventListener('click', (e) => {
            // Chỉ focus nếu không click vào nút button
            if (e.target.tagName !== 'BUTTON' && e.target.closest('button') === null) {
                focusOnPoint(item.centerId);
            }
        });
        
        row.innerHTML = `
            <b>(Tạo mới) Hạng ${index + 1}</b>
            ${hubNameHtml}
            <div>Tâm ID: ${item.centerId}</div>
            <div>Cover: <b>${item.score}</b> điểm mới</div>
            <button data-center-id="${item.centerId}">
                <i class="fa-solid fa-plus"></i> Tạo Nhóm Mới
            </button>
        `;
        
        row.addEventListener('mouseenter', (e) => showPreview(item, e.currentTarget));
        row.addEventListener('mouseleave', () => clearPreview());
        row.querySelector('button').addEventListener('click', (e) => {
            e.stopPropagation();
            popup_createGroup(item.centerId); 
        });
        rankTableBody.appendChild(row);
    });

    // 2. Render MOVE (Di chuyển)
    const groupedMoveActions = new Map();
    moveActions.forEach(item => {
        if (!groupedMoveActions.has(item.pointToMove.id)) {
            groupedMoveActions.set(item.pointToMove.id, []);
        }
        groupedMoveActions.get(item.pointToMove.id).push(item);
    });

    groupedMoveActions.forEach((actions, pointId) => {
        const pointToMove = actions[0].pointToMove;
        const currentGroup = allGroups.find(g => g.id === pointToMove.groupId);
        
        const row = document.createElement('div');
        row.className = 'rank-item rank-item-move';
        row.dataset.pointId = pointId; 

        // Gắn sự kiện Click của Row để Focus/Zoom trên bản đồ
        row.addEventListener('click', (e) => {
            // Chỉ focus nếu không click vào nút button
            if (e.target.tagName !== 'BUTTON' && e.target.closest('button') === null) {
                focusOnPoint(pointId);
            }
        });

        let buttonsHTML = '';
        actions.forEach(item => {
            buttonsHTML += `
                <button data-point-id="${item.pointToMove.id}" data-group-id="${item.targetGroup.id}">
                    <i class="fa-solid fa-arrow-right-arrow-left"></i> Chuyển G${item.targetGroup.groupNumber}
                </button>
            `;
        });

        row.innerHTML = `
            <b>(Di chuyển) Điểm ID: ${pointId}</b>
            <div>Từ: Nhóm ${currentGroup.groupNumber} (Tâm ID: ${currentGroup.centerPoint.id})</div>
            <div class="button-group">
                ${buttonsHTML}
            </div>
        `;

        row.addEventListener('mouseenter', (e) => {
            showPreview(actions[0], e.currentTarget);
        });
        row.addEventListener('mouseleave', () => {
            clearPreview();
        });

        row.querySelectorAll('button').forEach((button, index) => {
            button.addEventListener('click', (e) => {
                e.stopPropagation();
                const pointId = e.currentTarget.dataset.pointId; 
                const groupId = parseInt(e.currentTarget.dataset.groupId);
                movePoint(pointId, groupId); 
            });
        });

        rankTableBody.appendChild(row);
    });
}
/**
 * (SỬA LỖI ZOOM) Hàm tập trung (Focus) vào một điểm trên bản đồ.
 */
function focusOnPoint(pointId) {
    const point = allPoints.find(p => String(p.id) === String(pointId));
    
    if (!point || !point.marker) {
        showToast(`Lỗi: Không tìm thấy điểm ID ${pointId} trên bản đồ.`, "error");
        return;
    }
    
    if (!point.isVisible) {
        showToast(`Điểm ID ${pointId} đang bị ẩn bởi bộ lọc hiện tại.`, "warning");
    }

    // [ĐÃ SỬA] Thay map.flyTo bằng map.panTo để chỉ di chuyển, giữ nguyên zoom
    map.panTo(point.latlng); 

    // 2. Mở popup (nếu có)
    if (currentPopup) {
        map.closePopup(currentPopup);
        currentPopup = null;
    }

    // Kích hoạt sự kiện click của marker (như click bằng tay)
    if (point.marker) {
        point.marker.fire('click');
    }
    
    // [ĐÃ XÓA] Loại bỏ logic zoomToShowLayer để tránh thay đổi zoom
    /*
    if (isClusteringEnabled && pointMarkersLayer.hasLayer(clusterLayer)) {
        pointMarkersLayer.zoomToShowLayer(point.marker, () => {
            if (point.marker) {
                point.marker.fire('click');
            }
        });
    }
    */

    showToast(`Đã tập trung vào Điểm ID: ${pointId}`, 'info');
}
/**
 * (SỬA LỖI HOÀN CHỈNH) Hàm xử lý sự kiện click trên Marker.
 * Quyết định hiển thị Popup Pin, Popup Tham Chiếu, hoặc Popup Hành Động (Action Popup).
 */
function handleMarkerClick(pointData) {
    if (currentPopup) {
        map.closePopup(currentPopup);
        currentPopup = null;
    }

    let shouldZoom = false; 

    if (pointData.nhnn) {
        // === XỬ LÝ ĐIỂM NHNN ===
        let html = `<div class="action-popup-header">Điểm Tham Chiếu</div>
                                <div class="action-popup-buttons">
                                    <div class="action-popup-info" style="text-align: center; padding: 10px 0;">
                                        <img src="${pointData.marker.options.icon.options.iconUrl}" style="width: 30px; height: 30px; margin: 0 auto 5px auto;"><br>
                                        <b>${pointData.id}</b><br>(Ngân hàng Nhà nước)
                                    </div>
                                </div>`;
            
        currentPopup = L.popup({ closeButton: true, minWidth: 220, className: 'action-popup' })
            .setLatLng(pointData.latlng)
            .setContent(html)
            .openOn(map);
            
        shouldZoom = true; 
        
    } else if (isBatteryView) {
        // === XỬ LÝ CHẾ ĐỘ PIN/TỒN QUỸ ===
        let html = `<div class="action-popup-header">${pointData.id}</div>
                                <div class="action-popup-info battery-info-popup">
                                    <b>Tồn quỹ:</b> ${formatFullNumber(pointData.tonQuy)}<br>
                                    <b>Hạn mức:</b> ${formatFullNumber(pointData.hanMuc)}<br>
                                    <b>Trạng thái:</b> ${pointData.vuotHanMuc ? 
                                        '<span style="color: red; font-weight: bold;">Vượt Hạn Mức</span>' : 
                                        'Trong Hạn Mức'}
                                </div>`;
            
        currentPopup = L.popup({ closeButton: true, minWidth: 220, className: 'action-popup' })
            .setLatLng(pointData.latlng)
            .setContent(html)
            .openOn(map);
            
        shouldZoom = true; 
        
    } else {
        // === XỬ LÝ POPUP HÀNH ĐỘNG (THÊM/HỦY NHÓM) ===
        
        // 1. Tìm nhóm hiện tại của điểm 
        let currentGroupId = null;
        for (const name in groups) {
            if (groups[name].pointIds.includes(pointData.id)) {
                currentGroupId = groups[name].id;
                break;
            }
        }

        // 2. Tạo nội dung Popup HÀNH ĐỘNG (gồm nút Hủy/Chuyển nhóm)
        const content = createActionPopupContent(pointData.id, currentGroupId);
        
        // 3. Gán Popup MỚI
        currentPopup = L.popup({ closeButton: true, minWidth: 220, className: 'action-popup' })
            .setLatLng(pointData.latlng)
            .setContent(content)
            .openOn(map);

        // 4. Logic Zoom: Chỉ zoom khi điểm đã có nhóm (hoặc bạn có thể chọn luôn zoom)
        shouldZoom = (currentGroupId !== null); 
    }
    
    // Chỉ zoom khi cờ shouldZoom = true
    if (shouldZoom) {
        const currentZoom = map.getZoom();
        map.flyTo(pointData.latlng, Math.max(currentZoom, 16));
    }
}

    /**
     * (SỬA ĐỔI v43: Thêm kiểm tra an toàn cho gom cụm VÀ nhãn km)
     */
    function showPreview(item, rowElement = null) { 
        clearPreview(); 
        
        const centerPoint = (item.type === 'MOVE') ? item.targetGroup.centerPoint : item.centerPoint;
        if (!centerPoint) return; 
        
        const color = item.color; // Màu của nhóm (vẫn dùng cho vòng tròn)

        L.circle(centerPoint.latlng, {
            radius: RADIUS_METERS,
            color: color, 
            weight: 2.5,
            opacity: 0.8,
            fillColor: color,
            fillOpacity: 0.2,
            dashArray: '10, 10'
        }).addTo(previewLayer); // (SỬA v39) Thêm vào previewLayer

        if (item.type === 'MOVE') {
            // ... (Toàn bộ khối 'if (item.type === 'MOVE')' giữ nguyên) ...
            const pointToMove = item.pointToMove;
            const targetGroup = item.targetGroup;

            if (rowElement) {
                // ... (code vẽ đường nối từ bảng giữ nguyên)
                const rowRect = rowElement.getBoundingClientRect();
                const rowScreenPoint = L.point(rowRect.left + (rowRect.width / 2), rowRect.top + (rowRect.height / 2));
                const mapContainer = map.getContainer();
                const mapRect = mapContainer.getBoundingClientRect();
                const mapPoint = L.point(rowScreenPoint.x - mapRect.left, rowScreenPoint.y - mapRect.top);
                const startLatLng = map.containerPointToLatLng(mapPoint);
                const endLatLng = item.pointToMove.latlng;

                L.polyline([startLatLng, endLatLng], { 
                    color: PREVIEW_COLOR, 
                    weight: 3, 
                    opacity: 0.7, 
                    dashArray: '5, 5', 
                    className: 'animated-route-line' 
                }).addTo(previewLayer);
            }
            
            // (SỬA v41) Chỉ làm mờ các marker ĐANG HIỂN THỊ (không bị gom cụm)
            allPoints.filter(p => p.isVisible && !p.nhnn).forEach(p => {
                // p.marker._map là cách kiểm tra marker có đang trên map (không bị gom)
                if (p.marker && p.marker._map) {
                    p.marker.setOpacity(0.3);
                }
            });
            
            // (SỬA v41) Làm nổi bật tâm (nếu tâm đang hiển thị)
            if (!targetGroup.centerPoint.nhnn && targetGroup.centerPoint.marker && targetGroup.centerPoint.marker._map) {
                targetGroup.centerPoint.marker.setOpacity(1.0);
            }
            
            // (SỬA v41) Làm nổi bật điểm sắp chuyển
            if (!pointToMove.nhnn && pointToMove.marker) {
                // Nếu điểm đang hiển thị (không bị gom)
                if (pointToMove.marker._map) {
                     pointToMove.marker.setOpacity(1.0);
                     pointToMove.marker.setIcon(createPGDIcon()); 
                     if (pointToMove.marker._icon) {
                         pointToMove.marker._icon.classList.add('point-move-preview');
                     }
                } else {
                    // (MỚI v41) Nếu điểm đang bị gom, zoom tới nó để nó hiện ra
                    pointMarkersLayer.zoomToShowLayer(pointToMove.marker, () => {
                        // Sau khi zoom, nó có thể vẫn bị gom nếu quá gần
                        if (pointToMove.marker && pointToMove.marker._map) {
                            pointToMove.marker.setOpacity(1.0);
                            pointToMove.marker.setIcon(createPGDIcon());
                            if (pointToMove.marker._icon) {
                                pointToMove.marker._icon.classList.add('point-move-preview');
                            }
                        }
                    });
                }
            }

        } else { // 'NEW' hoặc 'ADD'
            
            // (MỚI v34) Tìm, vẽ line, và thêm nhãn KM cho NHNN
            const allNHNNPoints = allPoints.filter(p => p.nhnn && p.isVisible);
            allNHNNPoints.forEach(nhnnPoint => {
                const distance = centerPoint.latlng.distanceTo(nhnnPoint.latlng);
                if (distance <= RADIUS_METERS) {
                    
                    const distanceInKm = (distance / 1000).toFixed(2);
                    const labelContent = `~ ${distanceInKm} km`;

                    const line = L.polyline([centerPoint.latlng, nhnnPoint.latlng], {
                        color: NHNN_PREVIEW_LINE_COLOR, // (SỬA v34) Xanh biển đậm
                        weight: 2,
                        opacity: 0.9,
                        dashArray: '8, 4', 
                        className: 'animated-route-line' // (SỬA v34) Thêm animation
                    }).addTo(previewLayer);

                    // (*** SỬA v43 ***) Chỉ binding tooltip nếu được BẬT
                    if (showDistanceLabels) {
                        line.bindTooltip(labelContent, {
                            permanent: true,
                            direction: 'center',
                            className: 'distance-tooltip',
                            offset: [0, -8] // Nâng nhãn lên một chút
                        });
                    }
                    // (*** HẾT SỬA v43 ***)
                }
            });
            // (HẾT MỚI v34)
            
            const coveredPoints = item.coveredPoints;
            const coveredIds = new Set(coveredPoints.map(p => p.id));
            
            // (SỬA v41) Chỉ làm mờ các điểm đã nhóm VÀ đang hiển thị
            allPoints.filter(p => p.groupId !== null && p.isVisible && !p.nhnn).forEach(p => {
                 if (p.marker && p.marker._map) {
                    p.marker.setOpacity(0.3);
                 }
            });
            
            // (SỬA v41) Cập nhật icon/opacity cho các điểm chưa nhóm
            allPoints.filter(p => p.groupId === null && p.isVisible).forEach(p => {
                if (p.nhnn) {
                    // Đảm bảo NHNN luôn sáng (nếu nó hiển thị)
                    if (p.marker && p.marker._map) p.marker.setOpacity(1.0); 
                    return; // Bỏ qua, không thay đổi icon NHNN
                }

                // (SỬA v37) Code bên dưới chỉ chạy cho PGD/ATM
                if (coveredIds.has(p.id)) {
                     // Chỉ cập nhật nếu nó đang hiển thị
                     if (p.marker && p.marker._map) {
                        p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());
                        p.marker.setOpacity(1.0); // Sáng rõ
                     }
                } else {
                    // Chỉ cập nhật nếu nó đang hiển thị
                     if (p.marker && p.marker._map) {
                        p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());
                        p.marker.setOpacity(0.3); // Làm mờ
                     }
                }
            });
        }
    }

    /**
     * (SỬA ĐỔI v41: Thêm kiểm tra an toàn cho gom cụm)
     */
    function clearPreview() {
        previewLayer.clearLayers();
        
        allPoints.filter(p => p.isVisible && p.marker).forEach(p => { // (SỬA v41) Thêm check p.marker
            // Chỉ reset opacity nếu marker đang hiển thị
            if (p.marker._map) {
                p.marker.setOpacity(1.0); 
            }
            
            if (p.marker._icon) {
                p.marker._icon.classList.remove('point-move-preview');
            }
            
            // Logic reset icon này đã an toàn, 
            // vì L.markerClusterGroup sẽ gọi lại icon function khi cần
            if (p.nhnn) { // Điểm NHNN
                p.marker.setIcon(createNHNNIcon());
            } else if (p.groupId === null) { // Điểm PGD chưa nhóm
                // (SỬA v37)
                p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());
            } else if (p.groupId !== 'REFERENCE') { // Điểm PGD đã vào nhóm
                const group = allGroups.find(g => g.id === p.groupId);
                if (group) {
                    if (p.id === group.centerPoint.id) {
                        p.marker.setIcon(createCenterPointIcon(group.color));
                    } else {
                        // (SỬA v37)
                        p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon());
                    }
                }
            }
        });
    }

/**
 * (FIX: Đảm bảo khởi tạo polylineCache khi tạo nhóm)
 */
function popup_createGroup(pointId) {
    if (currentPopup) {
        map.closePopup(currentPopup);
        currentPopup = null;
    }
    const centerPoint = allPoints.find(p => String(p.id) === String(pointId));

    if (!centerPoint) {
        showToast(`Lỗi: Không tìm thấy điểm ID ${pointId}.`, "error");
        return;
    }

    // Tìm các điểm CHƯA NHÓM nằm trong bán kính 30km
    const coveredPoints = allPoints.filter(p => {
        if (p.id === centerPoint.id || p.nhnn) return false;
        
        if (p.groupId !== null && p.groupId !== 'REFERENCE') return false; 
        
        const distance = centerPoint.latlng.distanceTo(p.latlng);
        return distance <= RADIUS_METERS;
    });

    const newGroupNumber = allGroups.length + 1;
    const newGroupColor = GROUP_COLORS[allGroups.length % GROUP_COLORS.length];

    const newGroupId = `G_${newGroupNumber}`; 
    
    // Tạo mảng điểm, BẮT ĐẦU VỚI ĐIỂM TÂM
    const pointsInGroup = [centerPoint, ...coveredPoints];

    const newGroup = {
        id: newGroupId, 
        centerPoint: centerPoint,
        points: pointsInGroup, // <--- THÊM ĐIỂM TÂM VÀO MẢNG NÀY
        color: newGroupColor,
        groupNumber: newGroupNumber,
        routingControls: [],
        polylineCache: {} 
    };
    allGroups.push(newGroup);

    // CẬP NHẬT DỮ LIỆU ĐIỂM TRƯỚC KHI VẼ
    centerPoint.groupId = newGroupId; 
    
    const coveredIds = new Set(coveredPoints.map(p => p.id));
    allPoints.forEach(p => {
        if (coveredIds.has(p.id)) {
            p.groupId = newGroupId; 
        }
    });

    // ĐỒNG BỘ: Cập nhật biến groups (cho Popup Chuyển Nhóm)
    const pointIdsInGroup = pointsInGroup.map(p => p.id); // Lấy tất cả ID (bao gồm tâm)

    groups[`NHÓM ${newGroupNumber}`] = { 
        id: newGroupId, 
        color: newGroupColor, 
        pointIds: pointIdsInGroup 
    };
    // ==========================================================

    drawAllGroups(); 
    updateRankTable();
    updateFilterOptions();

    // Fix Lỗi Zoom


    const message = (coveredPoints.length > 0) 
        ? `Đã tạo thành công Nhóm ${newGroupNumber} với ${coveredPoints.length} điểm.`
        : "Đã tạo Nhóm mới, nhưng không có điểm nào chưa nhóm trong bán kính 30km.";

    Toastify({
        text: message,
        className: coveredPoints.length > 0 ? "custom-toast success" : "custom-toast warning",
    }).showToast();
}


    function popup_addPointToGroup(pointId, targetGroupId) {
        const pointToAdd = allPoints.find(p => String(p.id) === String(pointId));
        const targetGroup = allGroups.find(g => g.id === targetGroupId);
        
        if (!pointToAdd || !targetGroup) {
            showToast("Lỗi: Không tìm thấy điểm hoặc nhóm", "error");
            return;
        }
        
        targetGroup.points.push(pointToAdd);
        pointToAdd.groupId = targetGroupId;

        if (currentPopup) map.closePopup();
        updateRankTable(); 
        drawAllGroups();
        updateFilterOptions(); // (MỚI v40)
        showToast(`Đã thêm Điểm ${pointId} vào Nhóm ${targetGroup.groupNumber}`, 'success');
    }

/**
 * (SỬA LỖI HOÀN CHỈNH) Hàm chuyển điểm từ Bảng Xếp Hạng.
 * Chỉ gọi hàm chính movePointToGroup để đảm bảo đồng bộ hóa dữ liệu.
 */
function movePoint(pointId, newGroupId) {
    // Gọi hàm chính (đã có logic xử lý đồng bộ dữ liệu và loại trừ lẫn nhau)
    movePointToGroup(pointId, newGroupId);
    
    // Lưu ý: Các hàm updateRankTable, drawAllGroups, updateFilterOptions 
    // đã được gọi bên trong movePointToGroup.
}

/**
 * (*** SỬA ĐỔI MỚI ***) 
 * Ẩn vòng tròn/line khi ở chế độ Pin.
 */
function drawAllGroups() {
    clearAnalysisVisuals(); 
    let bounds = L.latLngBounds();
    
    const allNHNNPoints = allPoints.filter(p => p.nhnn && p.isVisible);

    allGroups.forEach(group => {
        const { centerPoint, points, color, groupNumber } = group;

        if (!centerPoint.isVisible) { return; }
        
        // Chỉ vẽ Vòng tròn và Line nếu KHÔNG ở chế độ Pin
        if (!isBatteryView) {
            
            // Vẽ vòng tròn 30km cố định
            L.circle(centerPoint.latlng, {
                radius: RADIUS_METERS, color: color, weight: 2.5, opacity: 0.7,
                fillColor: color, fillOpacity: 0.1
            }).addTo(analysisLayer); 
            
            // Vẽ line từ TÂM NHÓM đến các NHNN lân cận
            allNHNNPoints.forEach(nhnnPoint => {
                const distance = centerPoint.latlng.distanceTo(nhnnPoint.latlng);
                if (distance <= RADIUS_METERS) {
                    const distanceInKm = (distance / 1000).toFixed(2); const labelContent = `~ ${distanceInKm} km`;
                    const line = L.polyline([centerPoint.latlng, nhnnPoint.latlng], { color: NHNN_PREVIEW_LINE_COLOR, weight: 2, opacity: 0.9, dashArray: '8, 4', className: 'animated-route-line' }).addTo(analysisLayer);
                    if (showDistanceLabels) { line.bindTooltip(labelContent, { permanent: true, direction: 'center', className: 'distance-tooltip', offset: [0, -8] }); }
                }
            });
        }
        
        bounds.extend(centerPoint.latlng);
        
        const visiblePointsInGroup = points.filter(p => p.isVisible);

        points.forEach(pointData => {
            if (!pointData.isVisible) { return; }
            bounds.extend(pointData.latlng); 

            if (pointData.id === centerPoint.id) {
                pointData.marker.setIcon(createCenterPointIcon(color));
                const centerTooltip = pointData.marker.bindTooltip(`<b>TÂM NHÓM ${groupNumber}</b><br>(${visiblePointsInGroup.length} điểm)`, { permanent: true, direction: 'bottom', offset: L.point(0, 10), className: 'distance-tooltip' }).openTooltip();
                centerTooltip.on('add', function() {
                    const container = this.getElement();
                    if (container) { 
                        container.style.borderColor = color; 
                        L.DomEvent.on(container, 'click', (e) => { L.DomEvent.stopPropagation(e); handleMarkerClick(pointData); }); 
                    }
                });
            } else {
                // Thành viên nhóm dùng icon Pin hoặc PGD (Icon Pin được kiểm tra TSCN bên trong hàm createBatteryIcon)
                pointData.marker.setIcon(isBatteryView ? createBatteryIcon(pointData) : createPGDIcon());
                
                // Chỉ vẽ đường line/routing nếu KHÔNG ở chế độ Pin
                if (!isBatteryView) {
                    calculateAndDrawLine(centerPoint.latlng, pointData.latlng, pointData, group);
                }
            }
        });
    });
}
    
/**
 * (ĐÃ SỬA LỖI REMOVELAYER) Xóa toàn bộ đường phân tích (vòng tròn, polyline)
 */
function clearAnalysisVisuals() {
    allGroups.forEach(group => {
        if (group.routingControls) {
            group.routingControls.forEach(router => {
                try {
                    // Xóa control định tuyến
                    map.removeControl(router); 
                } catch (e) {
                    // Xử lý lỗi nếu router đã bị xóa
                }
            });
            // Rất quan trọng: Xóa sạch mảng sau khi xóa khỏi map
            group.routingControls = []; 
        }
    });

    analysisLayer.clearLayers();
    
    // (FIX LỖI) Kiểm tra measureLayer có tồn tại trước khi dùng
    if (measureLayer) { 
        measureLayer.clearLayers(); 
    }

    allPoints.filter(p => p.isVisible).forEach(p => {
         if (p.nhnn) { // Giữ nguyên icon NHNN
             p.marker.setIcon(createNHNNIcon());
         } else if (p.groupId === null) { // Điểm chưa nhóm
             p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon()); 
         } else if (p.groupId !== 'REFERENCE') { // Điểm đã vào nhóm (không phải NHNN)
             // Reset về icon PGD/Pin
             p.marker.setIcon(isBatteryView ? createBatteryIcon(p) : createPGDIcon()); 
         }
         
         if (p.marker.getTooltip()) {
             p.marker.unbindTooltip();
         }
    });
}


    /**
     * (SỬA v48) Xóa logic của hàm ClearAll (vì nút đã bị xóa)
     * Giữ lại hàm rỗng để tránh lỗi nếu có code cũ gọi
     */
    function clearAll() {
        showToast("Chức năng Xóa Tất Cả đã bị tắt.", "warning");
        // (Toàn bộ logic xóa đã được gỡ bỏ)
    }
    
/**
 * (SỬA LỖI CACHE VÀ PHỤC HỒI) Hàm Hybrid: Vẽ chim bay hoặc Lái xe (Ưu tiên dùng Cache).
 * * @param {L.LatLng} startLatLng - Tọa độ Tâm Nhóm.
 * @param {L.LatLng} endLatLng - Tọa độ Điểm thành viên.
 * @param {object} pointData - Dữ liệu điểm thành viên.
 * @param {object} group - Dữ liệu nhóm (bao gồm polylineCache).
 */
function calculateAndDrawLine(startLatLng, endLatLng, pointData, group) {
    const { color, groupNumber } = group;
    const endMarker = pointData.marker;
    
    // Tính khoảng cách Chim Bay (dùng cho Tooltip chung)
    const distanceInKm = (startLatLng.distanceTo(endLatLng) / 1000).toFixed(2);
    
    let tooltipContent;
    let isCached = false;

    if (isBirdMode) {
        // === CHẾ ĐỘ CHIM BAY (Bird Mode) ===
        L.polyline([startLatLng, endLatLng], {
            color: color, 
            opacity: 1.0, 
            weight: 5, 
            dashArray: '10, 10',
            className: 'animated-route-line'
        }).addTo(analysisLayer);
        
        tooltipContent = `<span class="group-name" style="color: ${color};">NHÓM ${groupNumber}</span>~ ${distanceInKm} km (bay)`;

    } else {
        // === CHẾ ĐỘ LÁI XE (Car Mode) - ƯU TIÊN DÙNG CACHE ===
        const cachedJson = group.polylineCache[pointData.id];

        if (cachedJson) {
            // 1. NẾU CÓ CACHE: Tải và vẽ ngay lập tức
            const coordinates = JSON.parse(cachedJson);
            const latLngs = coordinates.map(c => L.latLng(c.lat, c.lon));
            
            // Vẽ đường Polyline từ chuỗi tọa độ đã cache
            L.polyline(latLngs, {
                color: color, 
                opacity: 1.0, 
                weight: 5, 
                dashArray: '10, 10', 
                className: 'animated-route-line'
            }).addTo(analysisLayer);
            
            tooltipContent = `<span class="group-name" style="color: ${color};">NHÓM ${groupNumber}</span>🚗 ~ ${distanceInKm} km (cached)`;
            isCached = true;

        } else {
            // 2. NẾU KHÔNG CÓ CACHE: Đẩy vào Hàng đợi (Queue)
            tooltipContent = `<span class="group-name" style="color: ${color};">NHÓM ${groupNumber}</span>... <i class="fa-solid fa-spinner loading-spinner"></i>`;
            
            routingQueue.push({
                startLatLng, endLatLng, endMarker, pointData, color, groupNumber, group
            });
        }
    }
    
    // (*** SỬA v43 ***) Logic hiển thị Tooltip
    if (!isBatteryView && showDistanceLabels) {
        // Phải hủy tooltip cũ trước khi bind mới (để cập nhật nội dung)
        if (endMarker.getTooltip()) endMarker.unbindTooltip(); 
        
        const tooltip = endMarker.bindTooltip(tooltipContent, {
            permanent: true,
            direction: 'top',
            className: 'distance-tooltip'
        }).openTooltip();
        
        // Thêm event handler cho Tooltip
        tooltip.on('add', function() {
            const container = this.getElement();
            if (container) {
                container.style.borderColor = color;
                
                L.DomEvent.on(container, 'click', (e) => {
                    L.DomEvent.stopPropagation(e); 
                    handleMarkerClick(pointData);
                });
            }
        });
    }

    // Chỉ chạy hàng đợi nếu đang ở chế độ Lái xe VÀ không sử dụng cache
    if (!isBirdMode && !isCached) {
        processRoutingQueue();
    }
}

/**
 * (ĐÃ SỬA LỖI REMOVELAYER) Xử lý hàng đợi định tuyến, từng bước một.
 * @param {boolean} [shouldExport=true] - Có nên gọi exportGroupsData() sau khi hoàn thành không.
 */
async function processRoutingQueue(shouldExport = true) {
    // 1. Kiểm tra trạng thái an toàn
    if (isBirdMode) {
        // Đảm bảo không còn tác vụ nào chạy khi ở chế độ chim bay
        isProcessingQueue = false;
        return;
    }

    if (isProcessingQueue || routingQueue.length === 0) {
        return;
    }
    
    isProcessingQueue = true;
    const task = routingQueue.shift(); 
    
    // === LẤY THAM SỐ ===
    const { startLatLng, endLatLng, endMarker, pointData, color, groupNumber, group } = task;

    if (!group || !pointData || !endMarker) {
        console.error("Lỗi: Tác vụ định tuyến bị thiếu dữ liệu quan trọng.");
        isProcessingQueue = false;
        processRoutingQueue(shouldExport); 
        return;
    }
    
    const cacheKey = pointData.id;

    // 2. Khởi tạo Routing Control
    const router = L.Routing.control({
        waypoints: [startLatLng, endLatLng],
        show: false,
        addWaypoints: false,
        createMarker: () => null,
        lineOptions: {
            addWaypoints: false,
            styles: [{ 
                color: color, 
                opacity: 1.0, 
                weight: 5, 
                dashArray: '10, 10',
                className: 'animated-route-line' 
            }]
        } 
    }).addTo(map);

    // Lưu router vào mảng controls của nhóm
    group.routingControls.push(router);
    
    // === HÀM KẾT THÚC AN TOÀN ===
    const finishTask = async () => {
        // Gỡ Router khỏi Map một cách an toàn
        try { 
            map.removeControl(router);
            // Xóa router khỏi mảng quản lý của nhóm để tránh xóa lần nữa
            const index = group.routingControls.indexOf(router);
            if (index > -1) {
                group.routingControls.splice(index, 1);
            }
        } catch (e) {
            // console.warn("Lỗi an toàn khi removeControl:", e); // Gỡ lỗi
        } 
        
        await new Promise(resolve => setTimeout(resolve, ROUTING_DELAY_MS));
        isProcessingQueue = false;
        processRoutingQueue(shouldExport);
    };
    // =============================


    router.on('routesfound', function(e) {
        // --- LƯU CACHE POLYLINE ---
        const route = e.routes[0];
        const coordinates = route.coordinates.map(c => ({ lat: c.lat, lon: c.lng }));
        
        group.polylineCache[cacheKey] = JSON.stringify(coordinates); 
        
        if (shouldExport) {
            exportGroupsData(); 
        }
        // -------------------------
        
        // Cập nhật tooltip
        const isMarkerStillOnMap = pointMarkersLayer.hasLayer(endMarker) || nhnnMarkersLayer.hasLayer(endMarker);
        if (pointData.isVisible && endMarker && isMarkerStillOnMap && !isBatteryView && showDistanceLabels) {
            const distanceInKm = (route.summary.totalDistance / 1000).toFixed(2); 
            const tooltipContent = `<span class="group-name" style="color: ${color};">NHÓM ${groupNumber}</span>🚗 ${distanceInKm} km (lái xe)`;
            
            endMarker.unbindTooltip(); 
            
            const newTooltip = endMarker.bindTooltip(tooltipContent, {
                permanent: true, direction: 'top', className: 'distance-tooltip'
            }).openTooltip();
            
            newTooltip.on('add', function() {
                const container = this.getElement();
                if (container) {
                    container.style.borderColor = color;
                    L.DomEvent.on(container, 'click', (e) => {
                         L.DomEvent.stopPropagation(e);
                         handleMarkerClick(pointData);
                    });
                }
            });
        }
        
        finishTask();
    });

    router.on('routingerror', function(e) {
        console.error(`Lỗi định tuyến cho điểm ${pointData.id}:`, e.message);
        showToast(`Lỗi định tuyến cho ${pointData.id}.`, "error");
        
        // Vẽ đường chim bay để thay thế
        L.polyline([startLatLng, endLatLng], {
            color: color, 
            opacity: 0.5, 
            weight: 3, 
            dashArray: '5, 5'
        }).addTo(analysisLayer);

        finishTask();
    });
}


    /**
     * Hàm hiển thị thông báo (Toastify)
     */
    function showToast(message, type = 'info') {
        const typeClasses = { info: 'info', success: 'success', warning: 'warning', error: 'error' };
        const iconMap = { info: 'ℹ️', success: '✅', warning: '⚠️', 'error': '❌' };

        Toastify({
            text: `${iconMap[type]} ${message}`,
            duration: 2500,
            gravity: "bottom",
            position: "right",
            className: `custom-toast ${typeClasses[type]} text-white`
        }).showToast();
    }
    
    function highlightRankItem(pointId) {
        const newRow = document.querySelector(`.rank-item-new[data-point-id="${pointId}"]`);
        if (newRow) {
            newRow.classList.add('rank-item-highlight');
            newRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        const moveRow = document.querySelector(`.rank-item-move[data-point-id="${pointId}"]`);
        if (moveRow) {
            moveRow.classList.add('rank-item-highlight');
            moveRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }

    function clearRankItemHighlight() {
        document.querySelectorAll('.rank-item-highlight').forEach(row => {
            row.classList.remove('rank-item-highlight');
        });
    }
    
    /**
     * (SỬA v38) Cập nhật style cho nút
     */
    function toggleRoutingMode() {
        isBirdMode = !isBirdMode; 
        const button = document.getElementById('routing-toggle-btn');
        
        if (currentPopup) map.closePopup(currentPopup);
        
        if (isBirdMode) {
            button.innerHTML = '<i class="fa-solid fa-feather w-4 h-4"></i> <span class="button-text">Đường chim Bay</span>'; // Sửa chữ v48
            button.classList.add('bird-mode');
            button.classList.remove('car-mode');
            routingQueue = []; 
            isProcessingQueue = false; 
            showToast("Đã BẬT: Chế độ Chim Bay (Nhanh)", 'warning');
        } else {
            button.innerHTML = '<i class="fa-solid fa-car w-4 h-4"></i> <span class="button-text">Lái xe (Chậm)</span>'; // Sửa chữ v48
            button.classList.add('car-mode');
            button.classList.remove('bird-mode');
            showToast("Đã BẬT: Chế độ Lái xe (Chậm)", 'info');
        }
        
        drawAllGroups();
    }

    /**
     * (MỚI v42) Hàm Bật/Tắt tính năng Gom Cụm (Clustering)
     */
    function toggleClustering() {
        // 1. Đảo ngược trạng thái
        isClusteringEnabled = !isClusteringEnabled;
        const button = document.getElementById('cluster-toggle-btn');
        
        if (currentPopup) map.closePopup(currentPopup);

        // 2. Xóa layer CŨ khỏi bản đồ
        map.removeLayer(pointMarkersLayer);
        
        // 3. (Quan trọng) Cập nhật con trỏ pointMarkersLayer
        if (isClusteringEnabled) {
            pointMarkersLayer = clusterLayer; // Trỏ sang LỚP GOM CỤM
            
            // Cập nhật nút
            button.innerHTML = '<i class="fa-solid fa-boxes-stacked w-4 h-4"></i> <span class="button-text">Gom Cụm (Bật)</span>';
            button.classList.add('cluster-on');
            button.classList.remove('cluster-off');
            showToast("Đã BẬT: Gom Cụm", 'info');

        } else {
            pointMarkersLayer = standardLayer; // Trỏ sang LỚP TIÊU CHUẨN
            
            // Cập nhật nút
            button.innerHTML = '<i class="fa-solid fa-braille w-4 h-4"></i> <span class="button-text">Gom Cụm (Tắt)</span>';
            button.classList.add('cluster-off');
            button.classList.remove('cluster-on');
            showToast("Đã TẮT: Gom Cụm (Hiển thị tất cả)", 'warning');
        }

        // 4. Thêm layer MỚI vào bản đồ
        map.addLayer(pointMarkersLayer);

        // 5. Yêu cầu vẽ lại các marker
        updateMarkersVisibility();
        
        // 6. Vẽ lại các đường line/vòng tròn
        drawAllGroups();
    }


    /**
     * (MỚI v40) Hàm tải và vẽ viền GeoJSON của Việt Nam
     */
    function loadVietnamBorder() {
        // Đường dẫn đến file GeoJSON (bao gồm Hoàng Sa, Trường Sa)
        // Nguồn: https://github.com/thangdng/vietnam-boundary
        const geoJsonUrl = 'https://raw.githubusercontent.com/thangdng/vietnam-boundary/master/vietnam-with-islands.geojson';

        // Tùy chỉnh style cho viền
        const borderStyle = {
            "color": "#00008B",  // (Bạn có thể đổi màu viền ở đây, vd: "#FF0000" cho màu đỏ)
            "weight": 2,        // Độ dày của viền
            "opacity": 0.8,
            "fillOpacity": 0.0, // Quan trọng: Không tô màu nền
            "pane": "borderPane" // (MỚI v40) Vẽ lên pane đã tạo
        };

        fetch(geoJsonUrl)
            .then(response => response.json())
            .then(data => {
                L.geoJSON(data, {
                    style: borderStyle
                }).addTo(map); // Thêm vào bản đồ
            })
            .catch(error => {
                console.error('Lỗi khi tải viền bản đồ Việt Nam:', error);
                showToast("Không tải được viền bản đồ VN", "error");
            });
    }
    
 /**
 * (SỬA LỚN) Bật/Tắt chế độ Pin và áp dụng bộ lọc hiển thị.
 */
function toggleBatteryView() {
    isBatteryView = !isBatteryView;
    const button = document.getElementById('battery-toggle-btn');
    
    if (isBatteryView) {
        button.innerHTML = '<i class="fa-solid fa-map-pin w-4 h-4"></i> <span class="button-text">Chế độ Ghim</span>';
        button.classList.add('battery-mode');
        button.classList.remove('pin-mode');
        showToast("Đã BẬT: Chế độ Pin", 'info');
        
        // YÊU CẦU MỚI: ẨN CÁC ĐƯỜNG PHÂN TÍCH (Vòng tròn Hub & Routing)
        if (analysisLayer) analysisLayer.clearLayers();
        if (measureLayer) measureLayer.clearLayers();
        
    } else {
        button.innerHTML = '<i class="fa-solid fa-battery-half w-4 h-4"></i> <span class="button-text">Chế độ Pin</span>';
        button.classList.add('pin-mode');
        button.classList.remove('battery-mode');
        showToast("Đã TẮT: Chế độ Pin", 'warning');
    }
    
    // (*** QUAN TRỌNG: Gọi hàm lọc mới để ẩn các chấm ghim ***)
    updateMarkersVisibility(); 
    // ----------------------------------------------------
    
    // Vẽ lại toàn bộ map để cập nhật icon (và vẽ lại layer analysis nếu Tắt Pin)
    drawAllGroups();
    clearPreview();
    // (MỚI v39) Cập nhật Bảng Xếp Hạng (để ẩn nó đi khi bật Pin)
    updateRankTable();
}
    
    // *** Tự động gọi hàm tải dữ liệu sau khi map khởi tạo ***
    
    loadPreloadedData();
    

    // --- LOGIC ĐIỀU KHIỂN BỘ LỌC BẢN ĐỒ ---
    const tilePane = document.querySelector('.leaflet-tile-pane');
    const grayscaleSlider = document.getElementById('grayscale-slider');
    const brightnessSlider = document.getElementById('brightness-slider');
    const contrastSlider = document.getElementById('contrast-slider');
    const blurSlider = document.getElementById('blur-slider'); 

    const grayscaleLabel = document.querySelector('label[for="grayscale-slider"]');
    const brightnessLabel = document.querySelector('label[for="brightness-slider"]');
    const contrastLabel = document.querySelector('label[for="contrast-slider"]');
    const blurLabel = document.querySelector('label[for="blur-slider"]'); 

    function updateMapFilter() {
        if (!tilePane) return;

        const grayscale = grayscaleSlider.value;
        const brightness = brightnessSlider.value;
        const contrast = contrastSlider.value;
        const blur = blurSlider.value; 

        grayscaleLabel.innerText = `Độ xám: ${Number(grayscale).toFixed(1)}`;
        brightnessLabel.innerText = `Độ sáng: ${Number(brightness).toFixed(2)}`;
        contrastLabel.innerText = `Tương phản: ${Number(contrast).toFixed(1) }`;
        if (blurLabel) {
            blurLabel.innerText = `Độ nhòe (Blur): ${Number(blur).toFixed(1)} px`; 
        }

        const filterString = `grayscale(${grayscale}) brightness(${brightness}) contrast(${contrast}) blur(${blur}px)`;

        tilePane.style.filter = filterString;
    }

    grayscaleSlider.addEventListener('input', updateMapFilter);
    brightnessSlider.addEventListener('input', updateMapFilter);
    contrastSlider.addEventListener('input', updateMapFilter);
    blurSlider.addEventListener('input', updateMapFilter); 

    // Gọi hàm lần đầu để áp dụng giá trị mặc định (từ HTML)
    updateMapFilter();

    // (MỚI v54) Bắt sự kiện Enter trong ô tìm kiếm
document.getElementById('termid-search-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault(); // Ngăn chặn form submit
        searchByTermId();
    }
});
// (*** MỚI v50 ***) Hàm đóng Bảng Xếp Hạng (gọi từ nút X)
    function closeRankPanel() {
        const panel = document.getElementById('rank-table-container');
        const button = document.getElementById('rank-toggle-btn');
        if (panel) panel.style.display = 'none';
        
        // Cũng cập nhật style của nút 🏆 trong menu ☰
        if (button) {
             button.style.cssText = 'background-color: #f3f4f6 !important; color: #4b5563 !important;'; // Style Tắt
        }
    }
</script>

</body>
</html>